/*****************************************************************************
 *                                                                            *
 * Copyright (c) 2010 Synopsys. All rights reserved.                          *
 *                                                                            *
 * This file contains confidential, proprietary information and trade         *
 * secrets of Synopsys. No part of this document may be used, reproduced      *
 * or transmitted in any form or by any means without prior written           *
 * permission of Synopsys Incorporated.                                       *
 *                                                                            *
 * DESCRIPTION: Bus Functional Model for System Logic and Functions           *
 *              Models for system logic/functions such as clocks, resets,     *
 *              errors, messages, etc.                                        *
 *                                                                            *
 *       1) Interface Pins                                                    *
 *       2) Internal Signals                                                  *
 *       3) Initialization                                                    *
 *       4) Clocks                                                            *
 *       5) Resets and Power-Up Sequence                                      *
 *       6) DDR System Configuration                                          *
 *       7) PVT manipulation                                                  *
 *       8) System Performance                                                *
 *       9) Simulation Control                                                *
 *      10) Random Tasks and Functions                                        *
 *      11) Errors, Warnings and Messages                                     *
 *      12) Configuration Reports                                             *
 *      13) Vectors and Logs                                                  *
 *      14) Miscellaneous                                                     *
 *                                                                            *
 *****************************************************************************/

`timescale 1ns/1fs

module system (
               rst_b,             // asynchronous reset
               trst_b,            // auxiliary asynchronous reset
               xrst_b,            // external bus asynchronous reset
               clk,               // clock
               refclk_200MHz,     // emulation refference 200MHz clock
               clk_emul,          // emulation clock
               tclk,              // auxiliary clock
               xclk,              // external bus clock
               dfi_clk,           // DFI (controller) clock
               dfi_phy_clk,       // DFI PHY clock
               ddr_clk,           // DDR clock
               scan_ms,           // scan mode select
               ac_atpg_lu_ctrl,
`ifdef DWC_DDRPHY_CK
               ck_atpg_se,
               ck_atpg_si,
               ck_atpg_so,
`endif
               ac_atpg_se,
               ac_atpg_si,
               ac_atpg_so,
               dx_atpg_lu_ctrl,
               dx_atpg_se,
               dx_atpg_si,
               dx_atpg_so,
               jtag_atpg_se, // jtag scan chain
               jtag_atpg_si,
               jtag_atpg_so,
               cfg_atpg_se, 	// cfg register scan chain
               cfg_atpg_si,
               cfg_atpg_so,
               ctl_atpg_se,	 	// ctl register scan chain	
               ctl_atpg_si,
               ctl_atpg_so,
               ctl_sdr_atpg_se, 	// ctl_sdr register scan chain
               ctl_sdr_atpg_si,
               ctl_sdr_atpg_so,
               test_mode,         // test mode
               parity_err,        // insert error on parity input (parity)
               jtag_en,           // enable jtag pin for alternate pin config
               hdr_odd_cmd        // HDR command is on odd clock slot
               );
  
  //---------------------------------------------------------------------------
  // Parameters
  //---------------------------------------------------------------------------
  // by default, the duty cycle of the clock is set at 50%
    parameter tCKH  = `CLK_DCYC * `CLK_PRD,             // clock high width
                tCKL  = (1.0 - `CLK_DCYC) * `CLK_PRD;   // clock low low width
              //tACKH = `TCLK_DCYC * `TCLK_PRD,         // aux clock high width
              //tACKL = (1.0 - `TCLK_DCYC) * `TCLK_PRD, // aux clock low width
              //tXCKH = `XCLK_DCYC * `XCLK_PRD,         // xbus clock high width
              //tXCKL = (1.0 - `XCLK_DCYC) * `XCLK_PRD; // xbus clock low width

  parameter MSG_IDENT     = 15; // some messages idented n spaces
  
  // controller clock is always going to have a bigger clock insertion delay
  // compared to the DDR PHY clocks; set a delay on command lane PLL cclk
  // output relative to clk output
  parameter CCLK_DLY      = 0.3;  // 300 ps insertion delay

  // maximum time to wait for results before timing out
  parameter MAX_RSLT_WAIT = 2000;

  parameter pNO_OF_DX_DQS    = `DWC_DX_NO_OF_DQS
  ,         pNUM_LANES       = `DWC_NO_OF_BYTES * pNO_OF_DX_DQS  // Number of independent lanes
  ,         pDBEAT_WIDTH     = 8 / pNO_OF_DX_DQS                 // Number of DQ bits per lane
  ,         pDMBEAT_WIDTH    = 1                                 // 1 bits per lane
  ,         pNUM_BEATS       = 4                                 // 4 beats per word
  ,         pDATABEATS_WIDTH = pDBEAT_WIDTH * pNUM_BEATS         // 4 bits per lane * num beats
  ,         pDMBEATS_WIDTH   = pDMBEAT_WIDTH * pNUM_BEATS        // 1 bit per lane * num beats
  ,         pDATADM_WIDTH    = pDATABEATS_WIDTH + pDMBEATS_WIDTH // All data + mask beats per lane (per word)
  ,         pNO_OF_PRANKS    = `DWC_NO_OF_RANKS                  // Number of physical ranks
  ,         pNO_OF_LRANKS    = `DWC_NO_OF_LRANKS                 // Number of logical ranks
  ,         pNO_OF_CSNS      = `DWC_PHY_CS_N_WIDTH               // Number of chip selects
  ;

`ifdef RDIMM_DUAL_RANK 
    parameter NO_OF_TRANKS   = ((`DWC_RCD_MODE >= 2) && ((`DWC_NO_OF_RANKS-1) % 4>=2))? 2 : `DWC_NO_OF_TRANKS ;
`else
    parameter NO_OF_TRANKS    = `DWC_NO_OF_TRANKS ;
`endif
 
`ifdef DWC_DDRPHY_TYPEB
  `ifdef DWC_DDRPHY_ACX48
    parameter AC_ATPG_CHAINS          = 13;
  `else
    parameter AC_ATPG_CHAINS          = 12;
  `endif
  `ifdef DWC_DDRPHY_X4X2
    parameter DX_ATPG_CHAINS          = 16*`NO_OF_BYTES;
  `else
    parameter DX_ATPG_CHAINS          = 13*`NO_OF_BYTES;
  `endif
`else
    parameter AC_ATPG_CHAINS          = 13;
    parameter DX_ATPG_CHAINS          = 12*`NO_OF_BYTES;
`endif
`ifdef DWC_DDRPHY_CK
    parameter CK_ATPG_CHAINS          = 4;
`endif
 
  parameter PUB_TIMEOUT    = 100000; // 7000

  // rank configuration select
  parameter pRANK_CONNECT_ALL      = 0;
  parameter pRANK_DISCONNECT_ALL   = 1;
  parameter pRANK_CONNECT_CHIPS    = 2;
  parameter pRANK_BYTE_EN          = 3;
  parameter pRANK_CLOCK_CHECK_EN   = 4;
  parameter pRANK_CLOCK_CHECK_DIS  = 5;
  parameter pRANK_SETUP_CHECK_EN   = 6;
  parameter pRANK_SETUP_CHECK_DIS  = 7;
  parameter pRANK_PULSE_CHECK_EN   = 8;
  parameter pRANK_PULSE_CHECK_DIS  = 9;
  parameter pRANK_RFSH_CHECK_EN    = 10;
  parameter pRANK_RFSH_CHECK_DIS   = 11;
  parameter pRANK_MNT_EN           = 12;
  parameter pRANK_MNT_DIS          = 13;
  parameter pRANK_ODT_MNT_EN       = 14;
  parameter pRANK_ODT_MNT_DIS      = 15;
  parameter pRANK_RTT_MNT_EN       = 16;
  parameter pRANK_RTT_MNT_DIS      = 17;
  parameter pRANK_UNDF_MNT_EN      = 18;
  parameter pRANK_UNDF_MNT_DIS     = 19;
  parameter pRANK_FLYBY_DLY        = 20;  // Not used anymore
  parameter pRANK_RDBRD_DLY        = 21;  // Not used anymore
  parameter pRANK_WRBRD_DLY        = 22;  // Not used anymore
  parameter pRANK_WL_FDBACK        = 23;
  parameter pRANK_QS_DLY           = 24;
  parameter pRANK_INIT_MNT_EN      = 25;
  parameter pRANK_INIT_MNT_DIS     = 26;
  parameter pRANK_RESET_CKE_MNT_EN   = 27;
  parameter pRANK_RESET_CKE_MNT_DIS  = 28;
  parameter pRANK_DQS_CK_SETUP_CHECK_EN  = 29;
  parameter pRANK_DQS_CK_SETUP_CHECK_DIS = 30;
  parameter pRANK_CMD_ADDR_TIMING_CHECK_EN  = 31;
  parameter pRANK_CMD_ADDR_TIMING_CHECK_DIS = 32;
  parameter pRANK_CTRL_ADDR_PULSE_CHECK_EN  = 33;
  parameter pRANK_CTRL_ADDR_PULSE_CHECK_DIS = 34;
  parameter pRANK_RDIMM_MNT_EN     = 35;
  parameter pRANK_RDIMM_MNT_DIS    = 36;
  parameter pRANK_MPR_MNT_EN       = 37;
  parameter pRANK_MPR_MNT_DIS      = 38;
  parameter pRANK_CHIP_DIS_MASK    = 39;      
  parameter pRANK_ODTH_TIMING_CHECK_EN = 40;
  parameter pRANK_ODTH_TIMING_CHECK_DIS = 41;
  parameter pRANK_DQS_LATCH_EN  = 42;
  parameter pRANK_DQS_LATCH_DIS = 43;
  parameter pRANK_PD_MAX_EN     = 44;
  parameter pRANK_PD_MAX_DIS    = 45;
  //parameter pRANK_GET_FLYBY_DLY = 46;
  //parameter pRANK_GET_RDBRD_DLY = 47;
  //parameter pRANK_GET_WRBRD_DLY = 48;
  //parameter pRANK_GET_QS_DLY    = 49;
  parameter pRANK_BYTE_ENABLE_PER_CHNL = 50;
  parameter pRANK_LOW_POWER_MNT_EN     = 51;
  parameter pRANK_LOW_POWER_MNT_DIS    = 52; 
  parameter pRANK_BYTE_EN_DIS_REF      = 53;
  parameter pRANK_BYTE_ENABLE_PER_CHNL_DIS_REF = 54;
  parameter pRANK_TPDMAX_CHECK_EN              = 55;
  parameter pRANK_TPDMAX_CHECK_DIS             = 56;
  parameter pCHN_NO_OF_RANKS = (pNO_OF_PRANKS > 1)? (pNO_OF_PRANKS/2) : 1;
 
  // Default Jitter/DCD values, plus setting for bubbles
  parameter integer pJITTER_ALL_RANKS       = 99;
  parameter integer pJITTER_ALL_SIGNALS     = 99;
  parameter integer pJITTER_DIR_IN          = 1;
  parameter integer pJITTER_DIR_OUT         = 0;
  parameter integer pSKEW_RNDMZ_VALUE       = 2;
`ifdef DWC_BUBBLES
  parameter integer pRANDOM_JITTER_PK2PK    = 20;
  parameter integer pRANDOM_JITTER_SIGMA    = 0;
  parameter integer pSIN_JITTER_PK2PK       = 0;
  parameter integer pSIN_JITTER_FREQ        = 1;
  parameter integer pSIN_JITTER_PHASE       = 0;
  parameter integer pSIN_JITTER_PHASE_RNDM  = 0;
  parameter integer pDCD_VALUE              = 0;
  parameter integer pISI_VALUE              = 0;
  parameter integer pDCD_RNDMZ_VALUE        = 0;
  parameter integer pDCD_WIDE_SYMBOL        = 0;
  parameter integer pDISABLE_DEFAULT_JITTER = 1;
`elsif DWC_JITTER_DEFAULTS
  parameter integer pRANDOM_JITTER_PK2PK    = 0.04 * `CLK_PRD*1e3/2 / 2;//0.04 * UI = max usable value when SJ and DCD are also used; use half that max
  parameter integer pDCD_VALUE              = 0.1  * `CLK_PRD*1e3/2 / 2;  //0.1 * UI = max usable value when RJ and SJ are also used; use half that max
  parameter integer pISI_VALUE              = 0;
  parameter integer pRANDOM_JITTER_SIGMA    = 3;                          //3-sig, for faster obtention of peak values while keeping some norm. dist.
  parameter integer pSIN_JITTER_PK2PK       = 0.03 * `CLK_PRD*1e3/2 / 2;  //0.03 * UI = max usable value when RJ and DCD are also used; use half that max
  parameter integer pSIN_JITTER_FREQ        = 1e5;                        //1MHz, for faster variability of results
  parameter integer pSIN_JITTER_PHASE       = 5;                          //5 degree phase variation multiplier for SJ waves between DATX8 signals
  parameter integer pSIN_JITTER_PHASE_RNDM  = 1;                          //randomize phase value to apply to each signal
  parameter integer pDCD_RNDMZ_VALUE        = 1;                          //randomize DCD value to apply to each signal
  parameter integer pDCD_WIDE_SYMBOL        = 88;                         //randomize symbol to extend on each signal
  parameter integer pDISABLE_DEFAULT_JITTER = 0;
`else
  parameter integer pRANDOM_JITTER_PK2PK    = 0;
  parameter integer pRANDOM_JITTER_SIGMA    = 0;
  parameter integer pSIN_JITTER_PK2PK       = 0;
  parameter integer pSIN_JITTER_FREQ        = 1;
  parameter integer pSIN_JITTER_PHASE       = 0;
  parameter integer pSIN_JITTER_PHASE_RNDM  = 0;
  parameter integer pDCD_VALUE              = 0;
  parameter integer pISI_VALUE              = 0;
  parameter integer pDCD_RNDMZ_VALUE        = 0;
  parameter integer pDCD_WIDE_SYMBOL        = 0;
  parameter integer pDISABLE_DEFAULT_JITTER = 1;
`endif
`ifdef DWC_DDRPHY_EMUL_XILINX 
  parameter integer pMAX_DC_BOARD_DLY       = 2000;    // max dc board delay component in ps
`endif

`ifdef DWC_DEFAULT_SKEWS
  parameter integer pMAX_DX_SIGNAL_SKEW     = 0.2 * `CLK_PRD*1e3/2;       //0.2 * UI is a large but still "safe" skew to use between DQs, and DQ-to-DQS
  parameter integer pDISABLE_DEFAULT_SKEWS  = 0;
`else
  parameter integer pMAX_DX_SIGNAL_SKEW     = 0;
  parameter integer pDISABLE_DEFAULT_SKEWS  = 1;
`endif

  // when compiled for only 10 address bits, limit the probe for the debug 
  // signals to the correct address range
  parameter pDBG_A_BIT_10 = (`DWC_ADDR_WIDTH == 10) ? 9 : 10;
  parameter pDBG_A_BIT_11 = (`DWC_ADDR_WIDTH == 10) ? 9 : 11;
  parameter pDBG_A_BIT_12 = (`DWC_ADDR_WIDTH == 10) ? 9 : 12;
  parameter pDBG_A_BIT_13 = (`DWC_ADDR_WIDTH == 10) ? 9 : 13;
  parameter pDBG_SDRAM_ROW_WIDTH = (`DWC_ADDR_WIDTH == 10) ? 10 : `SDRAM_ROW_WIDTH;

`ifdef DWC_NO_OF_3DS_STACKS
  parameter pNO_OF_3DS_STACKS = `DWC_NO_OF_3DS_STACKS;
`else
  parameter pNO_OF_3DS_STACKS = 0;
`endif  

  parameter pRANK_WIDTH = (`NUM_3DS_STACKS == 0) ? 2 : 2 + `DWC_CID_WIDTH;

`ifdef ENDSIM_EYE_PLOTS
  parameter pGET_EYES_END_SIM = 1 ;
`else
  parameter pGET_EYES_END_SIM = 0 ;
`endif    

  parameter pMIN_LCDL_CNT      = 8;

//Board Delays parameters    
  localparam pDRAM_IO_WIDTH       = `SDRAM_DATA_WIDTH;
  localparam pDATA_WIDTH          = (`NO_OF_BYTES*8);
  localparam pBYTES_PER_DRAM      = (pDRAM_IO_WIDTH/8);
  
`ifdef SDRAMx4
    localparam pNO_OF_DQS_PER_SDRAM = 1;    
`else
    localparam pNO_OF_DQS_PER_SDRAM = pBYTES_PER_DRAM;                                     
`endif

//INDEX vakues for Board Delays
  localparam pDQ_DELAY_WIDTH = `SDRAM_DATA_WIDTH;
  localparam pDQS_DELAY_WIDTH = pNO_OF_DQS_PER_SDRAM;
`ifdef DDR4MPHY
  localparam pADDR_DELAY_WIDTH = `DWC_PHY_ADDR_WIDTH;
`else
  localparam pADDR_DELAY_WIDTH = `SDRAM_ADDR_WIDTH;
`endif 

`ifdef DDR4
  localparam pBA_DELAY_WIDTH = `DWC_PHY_BA_WIDTH;
`else
  localparam pBA_DELAY_WIDTH = `SDRAM_BANK_WIDTH;
`endif 
  localparam pCID_DELAY_WIDTH = `DWC_CID_WIDTH;

  
  // 2:1 or 4:1 (SDR/HDR) modes on CTL-DFI 
  localparam pCTL_HDR_MODE_EN    = `DWC_DDRPHY_CHDR_EN;
  // Num data beats per cycle
  localparam pNO_OF_BEATS        = 4;
  localparam pMEMCTL_NO_OF_BEATS = (pCTL_HDR_MODE_EN == 0) ? 2 : pNO_OF_BEATS;
  localparam pMEMCTL_NO_OF_CMDS  = (pCTL_HDR_MODE_EN == 0) ? 1 : 2;

`ifdef DWC_DDRPHY_BOARD_DELAYS   //this ifdef enables the *framework*
parameter    pBOARD_CONFIG_TYPE = 0 ;
// 0 --> no config (just delays framework is present)
// 1 to 3 --> Matched Fly-By topology, BC, AVG, and WC
// 4 to 6 --> Matched T topology, BC, AVG, and WC
// 7 to 9 --> UNmatched Fly-By topology, BC, AVG, and WC
// 10 to 12 --> UNmatched T topology, BC, AVG, and WC
`ifdef DWC_JITTER_DEFAULTS
   parameter integer  pBOARD_DELAY_MIN  =  ((0.12 * `CLK_PRD*1e3) /2) / 2 ;
`else
   parameter integer  pBOARD_DELAY_MIN  =  20 ;
`endif   

   real      pPVT_CORNER = 0.0 ;
   integer   pODR_MAX    = 0 ;
   integer   pBOARD_SKEW_MAX = 0 ;
   integer   pAC_BOARD_MAX  = 0 ;
   integer   pDX_BOARD_MAX  = 0 ;
   integer   pDX_AC_BOARD_MATCH = 0 ;
   integer   pFLYBY_UNIT_DELAY_MAX = 0 ;
   integer   pLOAD_STARTUP_DELAYS = 0 ;

`endif 

   integer mod_factor;

  //---------------------------------------------------------------------------
  // Interface Pins
  //---------------------------------------------------------------------------
  output                           rst_b;        // asynchronous reset
  output                           trst_b;       // auxiliary asynchronous reset
  output                           xrst_b;       // external bus asynchronous reset
  output                           clk;          // clock
  output                           refclk_200MHz; // emulation IDELAYCTRL clock
  output                           clk_emul;     // emulation clock
  output                           tclk;         // auxliary clock
  output                           xclk;         // external bus clock
  output                           dfi_clk;      // DFI (controller) clock
  output                           dfi_phy_clk;  // DFI PHY clock
  output                           ddr_clk;      // DDR clock
  output                           scan_ms;      // scan mode select
  output [3                 -1:0]  ac_atpg_lu_ctrl;
  output [`DWC_NO_OF_BYTES*3-1:0]  dx_atpg_lu_ctrl;

// ONLY FOR GATE level simulation otherwise no pins exist //
`ifdef DWC_DDRPHY_NO_HIER_ATPG_PINS
  `ifdef GATE_LEVEL_SIM
    `ifndef DWC_DDRPHY_ATPG_USE_PHY_PORTS
      `ifdef DWC_DDRPHY_CK
      output                       ck_atpg_se;
      output                       ck_atpg_si;
      input                        ck_atpg_so;
      `endif
      output                       ac_atpg_se;
      output                       ac_atpg_si;
      input                        ac_atpg_so;
      output [pNO_OF_BYTES-1:0]    dx_atpg_se;
      output [pNO_OF_BYTES-1:0]    dx_atpg_si;
      input  [pNO_OF_BYTES-1:0]    dx_atpg_so;
    `else
      // no ac_atpg_s* or dx_atpg_s* pins
    `endif
  `else 
    // RTL also no ac_atpg_s* or dx_atpg_s* pins
  `endif
`else
// not DWC_DDRPHY_NO_HIER_ATPG_PINS; both GATE and RTL sim
  `ifdef DWC_DDRPHY_CK
    output [CK_ATPG_CHAINS-1:0]    ck_atpg_se;
    output [CK_ATPG_CHAINS-1:0]    ck_atpg_si;
    input  [CK_ATPG_CHAINS-1:0]    ck_atpg_so;
  `endif
    output [AC_ATPG_CHAINS-1:0]    ac_atpg_se;
    output [AC_ATPG_CHAINS-1:0]    ac_atpg_si;
    input  [AC_ATPG_CHAINS-1:0]    ac_atpg_so;
    output [DX_ATPG_CHAINS-1:0]    dx_atpg_se;
    output [DX_ATPG_CHAINS-1:0]    dx_atpg_si;
    input  [DX_ATPG_CHAINS-1:0]    dx_atpg_so;
`endif
 
  // ATPG mode interface signals
  output                         ctl_atpg_se;
  output                         ctl_atpg_si;
  input                          ctl_atpg_so;

  output                         ctl_sdr_atpg_se;
  output                         ctl_sdr_atpg_si;
  input                          ctl_sdr_atpg_so;
   
  output                         cfg_atpg_se;
  output                         cfg_atpg_si;
  input                          cfg_atpg_so;

  output                         jtag_atpg_se;
  output                         jtag_atpg_si;
  input                          jtag_atpg_so;
  output [1:0]                   test_mode;    // test mode select
  output                         parity_err;      // insert error on parity input (par)
  output                         jtag_en;      // JTAG enable pin
  output                         hdr_odd_cmd;  // HDR command is on odd slot

    //---------------------------------------------------------------------------
  // Local Parameters
  //---------------------------------------------------------------------------
  localparam tPHY_DATA_DLY   = `CLK_PRD/100;

  // Changed how num of channels is calculated for Gen2.
  // localparam pSHARED_AC        = ((`DWC_NO_OF_BYTES > 1) && (`DWC_NO_OF_RANKS > 1));
`ifdef DWC_USE_SHARED_AC_TB
  localparam pSHARED_AC        = 1;
`else
  localparam pSHARED_AC        = 0;
`endif


  localparam pNUM_CHANNELS     = (pSHARED_AC        == 1) ? 2  : 1
  ,          pCHN0_DX8_NUM     = (pNUM_CHANNELS     == 1) ? `DWC_NO_OF_BYTES : (`DWC_NO_OF_BYTES/2)
  ,          pCHN1_DX8_NUM     = (pNUM_CHANNELS     == 1) ? `DWC_NO_OF_BYTES : (`DWC_NO_OF_BYTES - pCHN0_DX8_NUM)
  ,          pCHN0_NO_OF_RANKS = (pNUM_CHANNELS     == 1) ? pNO_OF_PRANKS : 
                                 (pNO_OF_PRANKS  == 1) ? 1                :
                                 (pNO_OF_PRANKS  == 4) ? 2                : (pNO_OF_PRANKS - 1)
  ,          pCHN1_NO_OF_RANKS = (pNUM_CHANNELS == 1) ? pNO_OF_PRANKS     : (pNO_OF_PRANKS - pCHN0_NO_OF_RANKS)
  ;

  localparam pDX0GTR         = `DX0GTR0
  ,          pDX1GTR         = `DX1GTR0
  ,          pDX2GTR         = `DX2GTR0
  ,          pDX3GTR         = `DX3GTR0
  ,          pDX4GTR         = `DX4GTR0
  ,          pDX5GTR         = `DX5GTR0
  ,          pDX6GTR         = `DX6GTR0
  ,          pDX7GTR         = `DX7GTR0
  ,          pDX8GTR         = `DX8GTR0
  ,          pMR_LAST        = `MR7_REG
  ;



  //---------------------------------------------------------------------------
  // Internal Signals
  //---------------------------------------------------------------------------
  reg       scan_ms;
  reg [1:0] test_mode; 
  reg       cal_done;
  reg       init;
  reg       pll_byp;
  reg       cal_byp;
  reg       init_byp;
  reg       bypass_mode;
  reg       ddr2_mode;
  reg       clk_inv;
  reg       hdr_odd_cmd;

  reg       phy_init_done;
  reg       phy_calib_done;
  reg       write_levelling;
  reg       write_levelling_2;
  reg       dqs_gate_training;
  reg       data_eye_training;
  reg       static_read_training;
  reg       exp_write_level_err;
  reg       exp_write_level_adj_err;
  reg       exp_dqs_gate_train_err;
  reg       exp_data_eye_train_err;
  reg       chk_write_level_done;
  reg       chk_write_level_adj_done;
  reg       chk_dqs_gate_train_done;
  reg       chk_data_eye_train_done;
  reg       pll_bypass_en;
  reg       zcal_all_done;
  reg       train_for_loopback;
  reg       train_for_srd;

  reg                                                  load_mode_pda_en;
  reg [(`DWC_DX_NO_OF_DQS * `DWC_NO_OF_BYTES) - 1 : 0] load_mode_pda_lane;

  reg [3                 -1:0] ac_atpg_lu_ctrl;
  reg [`DWC_NO_OF_BYTES*3-1:0] dx_atpg_lu_ctrl;

// ONLY FOR GATE level simulation otherwise no pins exist //
`ifdef DWC_DDRPHY_NO_HIER_ATPG_PINS
  `ifdef GATE_LEVEL_SIM
    `ifndef DWC_DDRPHY_ATPG_USE_PHY_PORTS
      `ifdef DWC_DDRPHY_CK
      reg                        ck_atpg_se;
      reg                        ck_atpg_si;
      reg                        ck_atpg_so;
      `endif
      reg                        ac_atpg_se;
      reg                        ac_atpg_si;
      reg                        ac_atpg_so;
      reg  [pNO_OF_BYTES-1:0]    dx_atpg_se;
      reg  [pNO_OF_BYTES-1:0]    dx_atpg_si;
      reg  [pNO_OF_BYTES-1:0]    dx_atpg_so;
    `else
      // no ac_atpg_s* or dx_atpg_s* pins
    `endif
  `else 
    // RTL also no ac_atpg_s* or dx_atpg_s* pins
  `endif
`else
    // not DWC_DDRPHY_NO_HIER_ATPG_PINS; both GATE and RTL sim
  `ifdef DWC_DDRPHY_CK
    reg  [CK_ATPG_CHAINS-1:0]    ck_atpg_se;
    reg  [CK_ATPG_CHAINS-1:0]    ck_atpg_si;
    reg  [CK_ATPG_CHAINS-1:0]    ck_atpg_so;
  `endif
    reg  [AC_ATPG_CHAINS-1:0]    ac_atpg_se;
    reg  [AC_ATPG_CHAINS-1:0]    ac_atpg_si;
    reg  [AC_ATPG_CHAINS-1:0]    ac_atpg_so;
    reg  [DX_ATPG_CHAINS-1:0]    dx_atpg_se;
    reg  [DX_ATPG_CHAINS-1:0]    dx_atpg_si;
    reg  [DX_ATPG_CHAINS-1:0]    dx_atpg_so;
`endif
 

  // ATPG mode interface signals
  reg 	ctl_atpg_se;
  reg   ctl_atpg_si;

  reg   ctl_sdr_atpg_se;
  reg   ctl_sdr_atpg_si;
   
  reg   cfg_atpg_se;
  reg   cfg_atpg_si;

  reg  jtag_atpg_se;
  reg  jtag_atpg_si;

  reg rst_b;
  reg clk;
  reg ddr_clk;
  reg clk_i;
  reg ddr_clk_i;
  reg clk_i_delayed;
  reg ddr_clk_i_delayed;
  reg [2:0] clk_cntr;

  reg       dfi_clk;
  reg       dfi_phy_clk;
  reg       clk_emul;
  reg       refclk_200MHz;
  reg [1:0] clk_emul_ctr;
  
  reg trst_b;
  reg tclk;
  reg tclk_i;

  reg xrst_b;
  reg xclk;
  reg xclk_i;

  reg clock_en;
  reg tclock_en;
  reg xclock_en;
  reg after_reset;
  reg powering_up;
  reg init_done;
  reg jtag_en;

  real PRD;
  real tCLK_HI;
  real tCLK_LO;
  real tCLK_PRD;
  real tCLK_DCYC;
  real tCLK_DLY;
  real ddr_clk_delay_value_lo;
  real ddr_clk_delay_value_hi;
  real ddr_clk_delay_value_by_2_lo;
  real ddr_clk_delay_value_by_2_hi;

  real tTCLK_HI;
  real tTCLK_LO;
  real tTCLK_PRD;
  real tTCLK_DCYC;
  real tTCLK_DLY;

  real tACKH;
  real tACKL;
  real tXCKH;
  real tXCKL;

  real tXCLK_HI;
  real tXCLK_LO;
  real tXCLK_PRD;
  real tXCLK_DCYC;
  real tXCLK_DLY;

  real tREFCK_200MHz_HI;
  real tREFCK_200MHz_LO;

  // refresh period
  integer tPRD_ps;
  reg [`tRFPRD_WIDTH-1:0] tRFC_max;

  // Simulation variables
  // Value of the simulation seed from the command line is stored here.
  // It is not altered again.
  integer seed;
  // seed_rr is used in the funtion RANDOM_RANGE. Its initial value is 
  // copied from SEED in this initial block.
  integer seed_rr;
  integer seed_rr1;
  integer errors;
  integer n_err_max;
  integer warnings;
  integer denali_errCount;
  integer tc_log_file_ptr;  // file pointer for logging testcase simulation
  integer tester_vec_file_ptr;  // file pointer for logging tester vectors
  integer svb_vec_file_ptr;      // file pointer for logging an svb vector
  integer opcode_vec_file_ptr;  // file pointer for logging opcode vectors
  reg     check_all_phy_init_flow;
  reg     check_dqs_gate_training;
  reg     check_dram_init_done;
  reg     check_cal_values;
  reg     enable_mdlen;
  reg     wr_dqs_gate_default;
  reg     rdimm_auto_train_en;
  reg     disable_pub_own_rfsh_mode;
  reg     populate_wl_to_grm;
  reg     train_dqs_gate_en;
  reg     fail_on_warning;
  reg     check_dfi_fsm;
  reg     disable_signal_probing;
  reg     lpddrx_mode;
  
  integer   verbose;
  integer   pvt_debug;    initial pvt_debug = 2;
  integer   pvt_detail_debug; initial pvt_detail_debug = 4;
  integer   i;
  integer no_of_chips;

  // Enable/disable DFI block FIFO checks
  reg       dfi_fifo_chk_en;

  reg [8*MSG_IDENT-1:0] ident;
  reg [16*MSG_IDENT-1:0] dident;

  reg xpct_illegal;

  reg svb_vector_enable;  // control start of vector dump

  wire [31:0] dq_oe;

  reg         data_trained;
  reg         rst_rfsh_after_dt;
  reg         suppress_err_msg;
  reg         init_sdram_array;
  reg [3:0]   sdram_init_nibble;
  reg         initializing_sdram_array;

  reg  force_pvt_in_progress;
  real rounding;

 
  reg [`REG_DATA_WIDTH-1:0] reg_data;
  reg bypass_zq_cal;
  reg ac_lb_rnd;
  reg tc_ac_lb_only; // indicates testcase for AC loopback only
  reg ac_lb_on;

  reg               reset_in_power_up;
  reg               pub_train_en;
  reg [30*8-1:0]    pub_text;
    
  reg [`REG_DATA_WIDTH - 1 : 0] reg_dxnlcdlr1_init [pNO_OF_LRANKS-1: 0][pNUM_LANES - 1 : 0];
  reg [31:0]  tmp;
  reg         force_zcomp_status;

  // events
  event e_sys_reset;
  event e_sys_reset_done;
  event e_sys_powerup_start;

  // PHY Initialization sequence of event 
  event e_pll_lock_done;
  event e_phy_cal_done;
  event e_phy_init_done;
  event e_emul_sdram_connect;
  event e_emul_sdram_disconnect;
  event e_sdram_init_done;
  event e_write_level_done;
  event e_dqs_gate_training_done; //optional
  event e_phy_ready;
   
  event e_end_simulation;
  event e_data_cmp_error;

  // event for pvt multiplier update if applicable
  event e_update_with_init_force_pvt;
  event e_check_calibrated_values;

  real    cfg2dfi_clk_ratio = `CFG_CLK_PRD/`CLK_PRD;
  integer wait_clks;
  
`ifdef SDF_ANNOTATE
  event force_notifiers;
  event release_calib_notifiers;
  event release_train_notifiers;
  `ifdef  DWC_DDRPHY_EMUL_XILINX
    event force_emulXV6_notifiers;
    event release_emulXV6_notifiers;
  `endif
`endif



  // variables for board delay module instantiated in the I/O module
  // (generate tck and tck/4) must be in ps
  wire [63:0]  board_dly_tck_real;
  wire [63:0]  board_dly_tck; 
  wire [63:0]  board_dly_tck_div4;

  assign board_dly_tck_real = (tCLK_LO+tCLK_HI)*2*1000;
  assign board_dly_tck      = board_dly_tck_real;
  assign board_dly_tck_div4 = board_dly_tck/4; 

  //assign board_dly_tck      = `CLK_PRD_PS;
  //assign board_dly_tck_div4 = `CLK_PRD_PS/4;
  
  localparam                MAX_DQS_PIPE   = 4;
  localparam                MAX_LCDL_VALUE = 256;
  localparam                LCDL_INC       = 4;

  // dqs_training specifics
  reg                       rdqs_training;
  integer                   dqs_pipe_i;
  integer                   lcdl_i;
  reg                       flip_word;
// adjust for X4 by using pNUM_LANES instead of DWC_NO_OF_BYTES  
  reg                       tmp_pass      [0:pNUM_LANES-1];

  integer                   first_pass    [0:pNUM_LANES-1];
  integer                   fail_aft_pass [0:pNUM_LANES-1];

  reg [pNUM_LANES-1:0]      lane_done;
  reg [pNUM_LANES-1:0]      lane_pass;
  reg                       shorten_ddl_cal;
  
  reg                       skip_phy_power_up;
  reg [1:0]                 dram_init_type;
  wire                      ctl_sdram_init; // ***TBD
  reg                       rdimm_reg_randomize;
  reg                       parity_err;
  reg                       parity_err_val;
  reg                       parity_err_xpctd;
  reg                       parity_err_chk;
  reg                       stop_on_perr;

  // DCU caches read from the design
  reg  [`CCACHE_DATA_WIDTH -1:0] ccache [0:`CCACHE_DEPTH-1];
  reg  [`ECACHE_DATA_WIDTH -1:0] ecache [0:`ECACHE_DEPTH-1];
  reg  [`RCACHE_DATA_WIDTH -1:0] rcache [0:`RCACHE_DEPTH-1];
  reg                            dcu_skip_dcusr1_chk;

  integer                 rank_cfg_id;
  integer                 rank_cfg_sel;
  integer                 rank_cfg_val [0:2];
  event                   e_configure_rank;
  event                   e_disconn_rank;
  event                   e_data_ck;
  event                   e_conn_rank_all;

  reg                     long_training;
  integer                 lpddr3_term_type;


`ifdef DWC_DDRPHY_BOARD_DELAYS  
  wire  [31:0]  read_dqs_brd_dly [0:pNO_OF_LRANKS-1][`DWC_NO_OF_BYTES-1:0];  //read dqs board delay values
`endif

  integer       lcdlr2_dqs_gate_tolerence; initial lcdlr2_dqs_gate_tolerence = 2;
   
  // Jitter skews pass-around for whole PHY skew compensation
  integer       dqs_extra_step_tolerance;
  
  event         e_align_dqs_and_phy_clk;
  reg   [31:0]  dqs_to_clk_offset;                          //measured delay from DQS to CLK, at PHY FIFO

  // aux signals for bubble-related tasks
//   reg           bubbles_train_status;
//   reg   [31:0]  bubbles_sys_lat [0:`DWC_NO_OF_RANKS-1][0:`DWC_NO_OF_BYTES-1];
//   reg   [31:0]  bubbles_dqs_sel [0:`DWC_NO_OF_RANKS-1][0:`DWC_NO_OF_BYTES-1];
  reg           disable_bubbles;
  reg           bubbles_created;
  reg           rank_disconnected;
  event         e_force_phy_qvld;
  event         e_release_phy_qvld;
  reg           need_data_train;
  reg           sch_pub_mode_dtp_chk_en;
  reg           rfsh_cmd_from_pub_mnt_en;
  reg           rfsh_cnt_en;
  reg           disable_rfsh_cnt_check;
  integer       rfsh_cmd_tx;
  integer       rfsh_rqst_vld_cnt;
  integer       init_rfsh_rqst_vld_cnt;
  event         e_auto_cmd_is_refresh;
  event         e_refresh_burst_match_dtcr_rfshdt;
  reg           add_qtr_clk_aclcdlr;
  
  reg  [pNO_OF_PRANKS-1:0]   ckep;
  wire [pNO_OF_PRANKS-1:0]   cke_chip;

`ifdef DWC_DDRPHY_EMUL_XILINX
  reg           dqs_train_in_sdram_init = 0;
  reg           wl_train_in_sdram_init  = 0;
  reg           tc_trigger_dqs_wl_train = 0;
  reg           skip_init_sdram_in_power_up =0; //This is mainly for the reg testcases
`endif
  integer       pr_dummy;
  
  genvar        dwc_byte, dwc_dim, dwc_rnk, dwc_chip, dwc_dly;
  reg           rand_odtcr;
  
  
  //---------------------------------------------------------------------------
  // initialization
  //---------------------------------------------------------------------------
  
  initial
    begin: initialize
      integer i;

      seed        = `SEED;
      seed_rr     = `SEED;
      seed_rr1    = `SEED;
      // Start pr sequence.
      pr_dummy = $random(seed_rr1);
      //verbose     = 0;
      verbose     = 8;
      disable_signal_probing  = 1;
      `ifdef LPDDRX
        lpddrx_mode = 1'b1;
      `else
        lpddrx_mode = 1'b0;
      `endif
      case (`DWC_DRAM_INIT)
        0: dram_init_type = `PUB_DRAM_INIT;
        1: dram_init_type = `CTL_DRAM_INIT;
        2: dram_init_type = `CFG_DRAM_INIT;
        default:  dram_init_type = `PUB_DRAM_INIT;
      endcase

      skip_phy_power_up = 1'b0;
      
      load_mode_pda_en   = 1'b0;
      load_mode_pda_lane = {(`DWC_DX_NO_OF_DQS * `DWC_NO_OF_BYTES){1'b0}};

      {scan_ms, 
      test_mode}  = `MISSION_MODE;

      ac_atpg_lu_ctrl = {3{1'b1}};
      `ifdef DWC_DDRPHY_CK
      ck_atpg_se      = 1'b0;
      ck_atpg_si      = 1'b0;
      `endif
      ac_atpg_se      = 1'b0;
      ac_atpg_si      = 1'b0;
      dx_atpg_lu_ctrl = {(`DWC_NO_OF_BYTES*3){1'b1}};
      dx_atpg_se      = {(`DWC_NO_OF_BYTES){1'b0}};
      dx_atpg_si      = {(`DWC_NO_OF_BYTES){1'b0}};
      cfg_atpg_se      = 1'b0;
      cfg_atpg_si      = 1'b0;		
      jtag_atpg_se      = 1'b0;
      jtag_atpg_si      = 1'b0;		
      ctl_atpg_se      = 1'b0;
      ctl_atpg_si      = 1'b0;		
      ctl_sdr_atpg_se      = 1'b0;
      ctl_sdr_atpg_si      = 1'b0;		

      cal_byp  = 1'b0;
      pll_byp  = 1'b0;
      init_byp = 1'b0;    

`ifdef DWC_DDRPHY_SMODE
      `TB.phy_smode = {`DWC_SMODE_WIDTH{1'b0}};
`endif

`ifdef DDR2
      ddr2_mode = 1'b1;
`else
      ddr2_mode = 1'b0;
`endif
      clk_inv   = 1'b0;

`ifdef MSD_HDR_ODD_CMD
      hdr_odd_cmd = 1'b1;
`else
      hdr_odd_cmd = 1'b0;
`endif

      shorten_ddl_cal = 1'b0;
      
      phy_init_done   = 1'b0;
      phy_calib_done  = 1'b0;
      write_levelling = 1'b0;
      write_levelling_2 = 1'b0;
      
      dqs_gate_training = 1'b0;
      data_eye_training = 1'b0;
      static_read_training = 1'b0;

      exp_write_level_err = 1'b0;
      exp_write_level_adj_err = 1'b0;
      exp_dqs_gate_train_err = 1'b0;
      exp_data_eye_train_err = 1'b0;

      chk_write_level_done = 1'b1;
      chk_write_level_adj_done = 1'b1;
      chk_dqs_gate_train_done = 1'b1;
      chk_data_eye_train_done = 1'b1;

`ifdef DWC_PLL_BYPASS
      pll_bypass_en   = 1'b1;
`else
      pll_bypass_en   = 1'b0;
`endif

`ifdef DWC_LOOP_BACK      
      train_for_loopback = 1'b1;
`else
      train_for_loopback = 1'b0;
`endif

`ifdef DWC_STATIC_RD_RESPP     
      train_for_srd = 1'b1;
`else
      train_for_srd = 1'b0;
`endif
        
      add_qtr_clk_aclcdlr = 1'b0;
      
      rst_b        = 1'b0;
      trst_b       = 1'b0;
      xrst_b       = 1'b0;

      dfi_clk      = 1'b0;
      dfi_phy_clk  = 1'b0;
      clk_emul     = 1'b0;
      refclk_200MHz = 1'b0;
      clk_emul_ctr = 0;
      clk_i       = 1'b0;
      ddr_clk_i   = 1'b1;
      ddr_clk     = 1'b1;
      tclk_i      = 1'b0;
      xclk_i      = 1'b0;
      clk_cntr    = 3'b001;

      clock_en    = 1'b1; // clock enabled by default
      tclock_en   = 1'b1;
      xclock_en   = 1'b1;
      //$display("clock_en = %0b", clock_en);  
      
      no_of_chips = 0;
`ifdef DWC_DDRPHY_USE_JTAG
      jtag_en     = 1;
`else
      jtag_en     = 0;
`endif

      // clock hi and low pulse width
      tCLK_PRD    = `CLK_PRD;
      tCLK_DCYC   = `CLK_DCYC;
      tCLK_DLY    = 0.0;
      tCLK_HI     = tCKH;
      tCLK_LO     = tCKL;

      //$display("CLK_PRD = %0f", `CLK_PRD);
      //$display("CLK_DCYC = %0f",`CLK_DCYC);
      //$display("tCLK_DLY = %0f", tCLK_DLY);
      //
      //$display("tCLK_HI = %0f", tCLK_HI);
      //$display("tCLK_LO = %0f", tCLK_LO);
      
      //---------------------------------------------------------------------------
      // Check to see if cfg_clk is faster than ctl_clk; in SDR mode an additional factor of 2
`ifdef DWC_DDRPHY_HDR_MODE
      if (`TCLK_PRD < `DWC_CFGCLK_RATIO * `CLK_PRD) begin
        $display("%t Modifying tTCLK_PRD from %0f to be %0f ", $time, `TCLK_PRD,(`DWC_CFGCLK_RATIO*`CLK_PRD));
        $display("%t           cfg_ck should not be faster than ctl_ck ", $time);
        tTCLK_PRD   = `DWC_CFGCLK_RATIO*`CLK_PRD;
      end
`else
      if (`TCLK_PRD < `DWC_CFGCLK_RATIO * 2 *`CLK_PRD) begin
        $display("%t Modifying tTCLK_PRD from %0f to be %0f ", $time, `TCLK_PRD,(`DWC_CFGCLK_RATIO*2*`CLK_PRD));
        $display("%t           cfg_ck should not be faster than ctl_ck ", $time);
        tTCLK_PRD   = `DWC_CFGCLK_RATIO * 2 *`CLK_PRD;
      end
`endif        
      else
        tTCLK_PRD   = `TCLK_PRD;

      tACKH = `TCLK_DCYC * tTCLK_PRD;
      tACKL = (1.0 - `TCLK_DCYC) * tTCLK_PRD;
 
      tTCLK_DCYC  = `TCLK_DCYC;
      tTCLK_DLY   = 0.0;
      tTCLK_HI    = tACKH;
      tTCLK_LO    = tACKL;

      //---------------------------------------------------------------------------
      // Check to see if xclk is faster than cfg_clk
      if (`XCLK_PRD < `DWC_XCLK_RATIO * tTCLK_PRD) begin
        $display("%t Modifying tXCLK_PRD from %0f to be %0f ", $time, `XCLK_PRD,(`DWC_XCLK_RATIO * tTCLK_PRD));
        $display("%t           xclk should not be faster than cfg_ck ", $time);
        tXCLK_PRD   = `DWC_XCLK_RATIO * tTCLK_PRD;
      end
      else
        tXCLK_PRD   = `XCLK_PRD;
        
      tXCKH = `XCLK_DCYC * tXCLK_PRD;         // xbus clock high width
      tXCKL = (1.0 - `XCLK_DCYC) * tXCLK_PRD; // xbus clock low width

      tXCLK_DCYC  = `XCLK_DCYC;
      tXCLK_DLY   = 0.0;
      tXCLK_HI    = tXCKH;
      tXCLK_LO    = tXCKL;
      
      //---------------------------------------------------------------------------

      tREFCK_200MHz_HI = 2.5;
      tREFCK_200MHz_LO = 2.5;

      powering_up  = 1'b0;
      init_done    = 1'b0;
      init_sdram_array = 1'b0;
      initializing_sdram_array = 1'b0;

      pub_train_en         = 1'b0;
      reset_in_power_up    = 1'b1;
 
      errors      = 0;
      warnings    = 0;
      n_err_max   = 1;
      // Get the number of errors to tolerate from the command-line
      if ($value$plusargs("n_err_max=%d", n_err_max)) begin
        if (verbose >= 3)
          $display("%t Using n_err_max = %0d ", $time, n_err_max);
      end
      else begin
        if (verbose >= 3)
          $display("%t Using n_err_max = %0d ", $time, n_err_max);
      end

      check_all_phy_init_flow   = 1'b0;
      check_dqs_gate_training   = 1'b0;
      check_dram_init_done      = 1'b1;
      check_cal_values          = 1'b0;
      enable_mdlen              = 1'b0;
      wr_dqs_gate_default       = 1'b1;
      rdimm_auto_train_en       = 1'b1;
      disable_pub_own_rfsh_mode = 1'b0;
      populate_wl_to_grm        = 1'b1;
      train_dqs_gate_en         = 1'b1;
      fail_on_warning           = 1'b1; // by default, testcase will fail on warnings
      xpct_illegal              = 1'b0; // not expecting illegal accesses
      check_dfi_fsm             = 1'b1;

      dcu_skip_dcusr1_chk       = 0;  // by default we always check this status register

      ident = "               ";
      dident = {ident, ident};

      force_pvt_in_progress = 1'b0;
 
      data_trained      = 1'b0;
      rst_rfsh_after_dt = 1'b1;
      suppress_err_msg  = 1'b0;
      long_training     = 1'b0;
      lpddr3_term_type  = `LPDDR3_NO_TERM;

//       bubbles_train_status  = 1'b0;
//       for (j=0; j<`DWC_NO_OF_RANKS; j=j+1) begin
//         for (i=0; i<`DWC_NO_OF_BYTES; i=i+1) begin
//           bubbles_sys_lat[j][i] = 0;
//           bubbles_dqs_sel[j][i] = 0;
//         end
//       end
      need_data_train   = 1'b0;
      disable_bubbles   = 1'b0;
      bubbles_created   = 1'b0;
      rank_disconnected = 1'b0;

      bypass_zq_cal = 1'b1; // by default ZQ calibration is bypassed *** TBD
      ac_lb_rnd = 1'b0;     // drive random address/command for AC loopback
      tc_ac_lb_only = 1'b0;
      ac_lb_on = 1'b0;

      dfi_fifo_chk_en = 1;  // by deafault check the FIFOs for overflow/underflow errors

      rdimm_reg_randomize  = 1'b1;
      parity_err              = 1'b0;
      // t=0 seed modification!  Bad!
      // Add a 0 delay, see above initial block where seed is set.
      #0;
      parity_err_val          = {$random} % 2;
      parity_err_xpctd        = 1'b0;
     `ifdef DWC_AC_PARITY_USE
      parity_err_chk          = 1'b1;
     `endif
      stop_on_perr            = 1'b0;
      rand_odtcr              = 1'b0;
      

      // determine the refresh period based on the speed (the equivalent 
      // number of clocks for 70000ns) - a value of 32 clock cycles is
      // subtracted to account for instruction pipeline and flushing of
      // previous instructions, especially if command reordering is
      // enabled
      tPRD_ps  = `CLK_PRD*1000;
     tRFC_max = (70000*1000)/tPRD_ps - 32;
      //tRFC_max = (70000*1000)/tPRD_ps - 400;

      // indicates period after reset
      after_reset = 1'b0;
      //@(negedge rst_b);
      @(posedge rst_b);
      after_reset = 1'b1;
    end // block: initialize

  assign ctl_sdram_init = (dram_init_type == `CTL_DRAM_INIT) ? 1'b1 : 1'b0;
//assign zcal_all_done = zcal_done;


  // parameter override
  // ------------------
  // overrides parameters of certain macros and RTL blocks to set specific
  // simulation conditions and/or speed-up simulation

  // initialization sequence is normally very long - so change it to reduced
  // value unless it the testcase specially checks initialization, in which
  // case it has to define the FULL_SDRAM_INIT compile define
`ifdef SDF_ANNOTATE
  `ifdef  DWC_DDRPHY_EMUL_XILINX
   // Use regsiter write
  `else
    `ifdef FULL_SDRAM_INIT
    `else
      defparam `PUB.u_DWC_ddrphy_cfg.pPTR0_TPLLPD_DFLT  = `PTR0_TPLLPD_DFLT;
      defparam `PUB.u_DWC_ddrphy_cfg.pPTR0_TPLLGS_DFLT  = `PTR0_TPLLGS_DFLT;
      defparam `PUB.u_DWC_ddrphy_cfg.pPTR1_TPLLRST_DFLT = `PTR1_TPLLRST_DFLT;
      defparam `PUB.u_DWC_ddrphy_cfg.pPTR1_TPLLLCK_DFLT = `PTR1_TPLLLCK_DFLT;
      defparam `PUB.u_DWC_ddrphy_cfg.pTPLLFFCGS_DFLT    = `TPLLFFCGS_DFLT;
      defparam `PUB.u_DWC_ddrphy_cfg.pTPLLFFCRGS_DFLT   = `TPLLFFCRGS_DFLT;
      defparam `PUB.u_DWC_ddrphy_cfg.pTPLLRLCK_DFLT     = `TPLLRLCK_DFLT;

      defparam `PUB.u_DWC_ddrphy_cfg.tBCSTAB_DFLT  = `tBCSTAB_c_ssi;
      defparam `PUB.u_DWC_ddrphy_cfg.tDINIT0_DFLT  = `tDINIT0_c_ssi;
      defparam `PUB.u_DWC_ddrphy_cfg.tDINIT1_DFLT  = `tDINIT1_c_ssi;
      defparam `PUB.u_DWC_ddrphy_cfg.tDINIT2_DFLT  = `tDINIT2_c_ssi;
      defparam `PUB.u_DWC_ddrphy_cfg.tDINIT3_DFLT  = `tDINIT3_c_ssi;
    `endif
  `endif
`else
  `ifndef GATE_LEVEL_SIM
  	`ifdef FULL_SDRAM_INIT
  	`else
  	  defparam `PUB.u_DWC_ddrphy_cfg.pPTR0_TPLLPD_DFLT  = `PTR0_TPLLPD_DFLT;
  	  defparam `PUB.u_DWC_ddrphy_cfg.pPTR0_TPLLGS_DFLT  = `PTR0_TPLLGS_DFLT;
  	  defparam `PUB.u_DWC_ddrphy_cfg.pPTR1_TPLLRST_DFLT = `PTR1_TPLLRST_DFLT;
  	  defparam `PUB.u_DWC_ddrphy_cfg.pPTR1_TPLLLCK_DFLT = `PTR1_TPLLLCK_DFLT;
  	  defparam `PUB.u_DWC_ddrphy_cfg.pTPLLFFCGS_DFLT  = `TPLLFFCGS_DFLT;
  	  defparam `PUB.u_DWC_ddrphy_cfg.pTPLLFFCRGS_DFLT = `TPLLFFCRGS_DFLT;
  	  defparam `PUB.u_DWC_ddrphy_cfg.pTPLLRLCK_DFLT   = `TPLLRLCK_DFLT;
  	
  	  defparam `PUB.u_DWC_ddrphy_cfg.tBCSTAB_DFLT  = `tBCSTAB_c_ssi;
  	  defparam `PUB.u_DWC_ddrphy_cfg.tDINIT0_DFLT  = `tDINIT0_c_ssi;
  	  defparam `PUB.u_DWC_ddrphy_cfg.tDINIT1_DFLT  = `tDINIT1_c_ssi;
  	  defparam `PUB.u_DWC_ddrphy_cfg.tDINIT2_DFLT  = `tDINIT2_c_ssi;
  	  defparam `PUB.u_DWC_ddrphy_cfg.tDINIT3_DFLT  = `tDINIT3_c_ssi;
  	`endif
  // if GATE, but BUILD or GATE_SIM_EXCEPTION
  `elsif DWC_DDRPHY_GATE_SIM_EXCEPT
  	`ifdef FULL_SDRAM_INIT
  	`else
  	  defparam `PUB.u_DWC_ddrphy_cfg.pPTR0_TPLLPD_DFLT  = `PTR0_TPLLPD_DFLT;
  	  defparam `PUB.u_DWC_ddrphy_cfg.pPTR0_TPLLGS_DFLT  = `PTR0_TPLLGS_DFLT;
  	  defparam `PUB.u_DWC_ddrphy_cfg.pPTR1_TPLLRST_DFLT = `PTR1_TPLLRST_DFLT;
  	  defparam `PUB.u_DWC_ddrphy_cfg.pPTR1_TPLLLCK_DFLT = `PTR1_TPLLLCK_DFLT;
  	  defparam `PUB.u_DWC_ddrphy_cfg.pTPLLFFCGS_DFLT  = `TPLLFFCGS_DFLT;
  	  defparam `PUB.u_DWC_ddrphy_cfg.pTPLLFFCRGS_DFLT = `TPLLFFCRGS_DFLT;
  	  defparam `PUB.u_DWC_ddrphy_cfg.pTPLLRLCK_DFLT   = `TPLLRLCK_DFLT;
  	
  	  defparam `PUB.u_DWC_ddrphy_cfg.tBCSTAB_DFLT  = `tBCSTAB_c_ssi;
  	  defparam `PUB.u_DWC_ddrphy_cfg.tDINIT0_DFLT  = `tDINIT0_c_ssi;
  	  defparam `PUB.u_DWC_ddrphy_cfg.tDINIT1_DFLT  = `tDINIT1_c_ssi;
  	  defparam `PUB.u_DWC_ddrphy_cfg.tDINIT2_DFLT  = `tDINIT2_c_ssi;
  	  defparam `PUB.u_DWC_ddrphy_cfg.tDINIT3_DFLT  = `tDINIT3_c_ssi;
  	`endif
  `endif
`endif

`ifdef SVB_VECTORS
  // control the start of the vector dump (svb)
  initial begin
    svb_vector_enable = 1'b0;
  end
`endif

  //---------------------------------------------------------------------------
  // Clocks
  //---------------------------------------------------------------------------
  // free-running clock
`ifdef DWC_CLK_MAX_JITTER
  `define DWC_ADD_PHY_DELAY
  `define DWC_PHY_DELAY (`DWC_CLK_MAX_JITTER+0.002)

  real jitter;
  always begin
    jitter = $dist_uniform(seed,-500000.0*`DWC_CLK_MAX_JITTER,500000.0*`DWC_CLK_MAX_JITTER)/1000000.0; 
    #(`CLK_NX*tCLK_LO + jitter) clk_i = (clock_en) ? 1'b1 : 1'b0;
    #(`CLK_NX*tCLK_HI + jitter) clk_i = 1'b0;
   end

`else
  always 
    begin
      //$display("-> %0t: ==> clk_i = ", $time, clk_i);
      //$display("clock_en = %0b", clock_en);
      //$display("CLK_NX   = %0d", `CLK_NX);
      
      #(`CLK_NX*tCLK_LO) clk_i = (clock_en) ? 1'b1 : 1'b0;
      //$display("-> %0t: ==> clk_i = ", $time, clk_i);
      #(`CLK_NX*tCLK_HI) clk_i = 1'b0;
      //$display("-> %0t: ==> clk_i = 1'b0", $time);
    end
`endif

  always
    begin
      //$display("-> %0t: ==> tclk_i = ", $time, tclk_i);
      #(`CLK_NX*tTCLK_LO) tclk_i = (tclock_en) ? 1'b1 : 1'b0;
      #(`CLK_NX*tTCLK_HI) tclk_i = 1'b0;
    end

  always
    begin
      //$display("-> %0t: ==> xclk_i = ", $time, xclk_i);
      #(`CLK_NX*tXCLK_LO) xclk_i = (xclock_en) ? 1'b1 : 1'b0;
      #(`CLK_NX*tXCLK_HI) xclk_i = 1'b0;
    end

  always
    begin
      #(tREFCK_200MHz_HI) refclk_200MHz = (clock_en) ? 1'b1 : 1'b0;
      #(tREFCK_200MHz_LO) refclk_200MHz = 1'b0;
    end

  always @(posedge clk) begin
    clk_emul_ctr <= clk_emul_ctr + 1'b1;
  end

  // clock delay
  always @(clk_i)  clk_i_delayed <= #tCLK_DLY  clk_i;
  always @(tclk_i) tclk          <= #tTCLK_DLY tclk_i;
  always @(xclk_i) xclk          <= #tXCLK_DLY xclk_i;

  // Generate clk synchronously so in SDR mode we can also generate the
  // dfi_phy_clk synchronously and avoid race conditions between these
  // two clocks
  always @(posedge clk_i_delayed) begin
    //$display("-> %0t: ==> clk_i_delayed = ", $time, clk_i_delayed);
    clk <= 1'b1;
    //$display("-> %0t: ==> clk = ", $time, clk);
  end

  always @(negedge clk_i_delayed) begin
    //$display("-> %0t: ==> clk_i_delayed = ", $time, clk_i_delayed);
    clk <= 1'b0;
    //$display("-> %0t: ==> clk = ", $time, clk);
  end

  // SDR clock in PLL bypass mode is clk divided by 4 since the byp_clkout
  // is clk divided by 8
  // NOTE: drive the clock a little bit later to prevent race conditions
  // with the internal clock during RTL simulations - this is done by skewing
  // the rising edge of SDR clock earlier using the initialization of the 
  // counter
  always @(posedge clk_i_delayed) begin
    clk_cntr <= #(0.001) clk_cntr + 1;
  end

  // in HDR mode controller runs at the same speed as the PHY;
  // in SDR mode controller runs at twice the speed of the PHY
  // NOTE: when in PLL bypass mode, the clock used by the controller
  //       is the PLL bypass clock output
`ifdef DWC_DDRPHY_HDR_MODE
  `ifdef DWC_DDRPHY_EMUL_XILINX
     always @(*)       #(tPHY_DATA_DLY) dfi_clk <= clk;
  `else  
     always @(*)       dfi_clk <= clk;
  `endif
  always @(clk) dfi_phy_clk <= clk;
`else
  // Generate dfi_phy_clk off same edges that clk is generated off to avoid
  // race conditions
//  always @(*)      dfi_clk <= (`GRM.pll_bypass) ? clk_cntr[2] : clk;

    always @(*)      dfi_clk <= clk;

  generate
    if (`DWC_DDRPHY_SDR_MODE == 2'b10) begin : gen_phy_dfi_clk
      // when running the PHY is SDR mode, the main input clock is the same
      // frequency as the DRAM clock
      always @(posedge clk_i_delayed) begin
        dfi_phy_clk <= 1'b1;
      end

      always @(negedge clk_i_delayed) begin
        dfi_phy_clk <= 1'b0;
      end
    end else begin : gen_phy_dfi_clk
      always @(posedge clk_i_delayed) dfi_phy_clk <= ~dfi_phy_clk;
    end
  endgenerate
`endif

  always @(clk_emul_ctr[1]) clk_emul <= clk_emul_ctr[1];

always@(*) ddr_clk_delay_value_lo = (`CLK_NX*tCLK_LO/2);
always@(*) ddr_clk_delay_value_hi = (`CLK_NX*tCLK_HI/2);
always@(*) ddr_clk_delay_value_by_2_lo = (`CLK_NX*tCLK_LO/4);
always@(*) ddr_clk_delay_value_by_2_hi = (`CLK_NX*tCLK_HI/4);

`ifndef DWC_DDRPHY_EMUL_XILINX
//     always 
//       begin
//        #0.001    ddr_clk_i = 1'b0;
//       end
//`else
   `ifdef DWC_DDR_CLK_EN
     always 
       begin
     `ifdef DWC_PHY_SDR_MODE
	 #(ddr_clk_delay_value_lo) ddr_clk_i = (clock_en) ? 1'b1 : 1'b0;
	 #(ddr_clk_delay_value_hi) ddr_clk_i =  1'b0;
     `else
	`ifdef DWC_CTL_SDR_MODE  
           #(ddr_clk_delay_value_lo) ddr_clk_i = (clock_en) ? 1'b1 : 1'b0;
           #(ddr_clk_delay_value_hi) ddr_clk_i = 1'b0;
	`else
           #(ddr_clk_delay_value_by_2_lo) ddr_clk_i = (clock_en) ? 1'b1 : 1'b0;
           #(ddr_clk_delay_value_by_2_hi) ddr_clk_i = 1'b0;
	`endif
     `endif
       end
       
  always @(ddr_clk_i) ddr_clk_i_delayed  <= #tCLK_DLY  ddr_clk_i;

  always @(posedge ddr_clk_i_delayed) begin
    ddr_clk <= 1'b1;
  end

  always @(negedge ddr_clk_i_delayed) begin
    ddr_clk <= 1'b0;
  end
`endif
`endif

  // stop/restart clock
  task stop_clock;
    begin
      clock_en = 1'b0;
    end
  endtask // stop_clock

  task restart_clock;
    begin
      clock_en = 1'b1;
    end
  endtask // restart_clock

  // stop/restart test clock
  task stop_test_clock;
    begin
      tclock_en = 1'b0;
    end
  endtask // stop_test_clock

  task restart_test_clock;
    begin
      tclock_en = 1'b1;
    end
  endtask // restart_test_clock

  // stop/restart extnal bus clock
  task stop_xbus_clock;
    begin
      xclock_en = 1'b0;
    end
  endtask // stop_xbus_clock

  task restart_xbus_clock;
    begin
      xclock_en = 1'b1;
    end
  endtask // restart_xbus_clock


  // set clock period
  // ----------------
  // sets clock period to a value other than the default
  // NOTE: the passed period must be in picoseconds (ps), e.g. 3000 for 333MHz
  task set_clock_period;
    input [31:0] period;  // period in ps
    begin
      tCLK_PRD = period/1000.0;                // clock period in ns
      tCLK_HI  = tCLK_DCYC * tCLK_PRD;         // clock high level width
      tCLK_LO  = (1.0 - tCLK_DCYC) * tCLK_PRD; // clock low level width
    end
  endtask // set_clock_period

  task set_test_clock_period;
    input [31:0] period;  // period in ps
    begin
      tTCLK_PRD = period/1000.0;                  // clock period in ns
      tTCLK_HI  = tTCLK_DCYC * tTCLK_PRD;         // clock high level width
      tTCLK_LO  = (1.0 - tTCLK_DCYC) * tTCLK_PRD; // clock low level width
    end
  endtask // set_test_clock_period

  task set_xbus_clock_period;
    input [31:0] period;  // period in ps
    begin
      tXCLK_PRD = period/1000.0;                  // clock period in ns
      tXCLK_HI  = tXCLK_DCYC * tXCLK_PRD;         // clock high level width
      tXCLK_LO  = (1.0 - tXCLK_DCYC) * tXCLK_PRD; // clock low level width
    end
  endtask // set_xbus_clock_period


  // set clock duty cycle
  // --------------------
  // sets clock duty cycle to a value other than the default
  // NOTE: the passed value must be the percentage of the clock high time, e.g.
  //       55 for a 55% duty cycle
  task set_clock_duty_cycle;
    input [31:0] duty_cycle; // duty cycle as percentage of clock high time
    begin
      tCLK_DCYC = duty_cycle/100.0;
      tCLK_HI   = tCLK_DCYC * tCLK_PRD;         // clock high level width
      tCLK_LO   = (1.0 - tCLK_DCYC) * tCLK_PRD; // clock low level width
    end
  endtask // set_clock_duty_cycle

  task set_test_clock_duty_cycle;
    input [31:0] duty_cycle; // duty cycle as percentage of clock high time
    begin
      tTCLK_DCYC = duty_cycle/100.0;
      tTCLK_HI   = tTCLK_DCYC * tTCLK_PRD;         // clock high level width
      tTCLK_LO   = (1.0 - tTCLK_DCYC) * tTCLK_PRD; // clock low level width
    end
  endtask // set_test_clock_duty_cycle

  task set_xbus_clock_duty_cycle;
    input [31:0] duty_cycle; // duty cycle as percentage of clock high time
    begin
      tXCLK_DCYC = duty_cycle/100.0;
      tXCLK_HI   = tXCLK_DCYC * tXCLK_PRD;         // clock high level width
      tXCLK_LO   = (1.0 - tXCLK_DCYC) * tXCLK_PRD; // clock low level width
    end
  endtask // set_xbus_clock_duty_cycle


  // delay clock
  // -----------
  // delays the clock by so many ps; this is used to provide different values
  // of skews with other clocks
  task delay_clock;
    input [31:0] dly;  // delay in ps
    begin
      tCLK_DLY = dly/1000.0; // clock delay in ns
    end
  endtask // delay_clock

  task delay_test_clock;
    input [31:0] dly;  // delay in ps
    begin
      tTCLK_DLY = dly/1000.0; // clock delay in ns
    end
  endtask // delay_test_clock

  task delay_xbus_clock;
    input [31:0] dly;  // delay in ps
    begin
      tXCLK_DLY = dly/1000.0; // clock delay in ns
    end
  endtask // delay_xbus_clock


  // NOP
  // ---
  task nops;
    input [31:0] no_of_nops;
    integer i;
    begin
      for (i=0; i<no_of_nops; i=i+1)
        begin
          @(posedge clk);
      end
    end
  endtask // nops

  task nop;
    begin
      nops(1);
    end
  endtask // nop

  // NOPs in the PUB clock domain (in SDR mode PUB clock is half the system
  // clock
  task pub_nops;
    input [31:0] no_of_nops;
    integer i;
    begin
      for (i=0; i<no_of_nops; i=i+1)
        begin
          @(posedge dfi_phy_clk);
      end
    end
  endtask // pub_nops

  task pub_nop;
    begin
      pub_nops(1);
    end
  endtask // pub_nop

  
  //---------------------------------------------------------------------------
  // Resets and Power-Up Sequence
  //---------------------------------------------------------------------------

  // reset
  // -----
  // pulse reset (asynchronous)
  task reset;
    integer rst_clk_cnt;
    begin
      rst_clk_cnt = `RST_CLKS;
      `ifdef DWC_NO_RST_PIN
        rst_clk_cnt = rst_clk_cnt + 200;
      `endif
      $display("\n");
      drive_reset(1'b0);
      drive_test_reset(1'b0);
      drive_xbus_reset(1'b0);
      -> e_sys_reset;
      repeat(rst_clk_cnt) @(posedge clk);
      @(negedge clk);
      drive_reset(1'b1);
      drive_test_reset(1'b1);
      drive_xbus_reset(1'b1);
      -> e_sys_reset_done;
    end
  endtask // reset

  // drive hard reset to a value
  task drive_reset;
    input val;
    begin
      rst_b = val;
      message(`SYS_OP, `SYS_RST, val);
      $display("%0t => rst_b = %0b",$time, rst_b);
    end
  endtask // drive_reset

  task drive_test_reset;
    input val;
    begin
      trst_b = val;
      message(`SYS_OP, `SYS_TRST, val);
      $display("%0t => trst_b = %0b",$time, trst_b);
    end
  endtask // drive_test_reset

  task drive_xbus_reset;
    input val;
    begin
      xrst_b = val;
      //message(`SYS_OP, `SYS_XRST, val); *** TBD
      $display("%0t => xrst_b = %0b",$time, xrst_b);
    end
  endtask // drive_xbus_reset

  
  // PHY soft reset
  // --------------
  // soft resets the PHY by writing to the PHY initialization register or PGCR1
  task phy_soft_reset;
    input reset_type;
    begin
      if (reset_type == `AC_DX_ONLY) begin
        `GRM.pgcr1[25] = 1'b0;
        @(posedge `CFG.clk);
        `CFG.write_register(`PGCR1, `GRM.pgcr1);
        `FCOV_REG.set_cov_registers_write(`PGCR1 ,`GRM.pgcr1,`VALUE_REGISTER_DATA);
        `CFG.nops(3);
        `GRM.pgcr1[25] = 1'b1;
        @(posedge `CFG.clk);
        `CFG.write_register(`PGCR1, `GRM.pgcr1);
        `FCOV_REG.set_cov_registers_write(`PGCR1 ,`GRM.pgcr1,`VALUE_REGISTER_DATA);
        `CFG.nops(3);
      end
      else begin // `WHOLE_PHY
        `GRM.pir[6] = 1'b0;
        @(posedge `CFG.clk);
        `FCOV_REG.set_cov_registers_write(`PIR ,`GRM.pir,`VALUE_REGISTER_DATA);
        `FCOV_REG.set_cov_init_trig_pll_dcal_phy_dram_scenario;
        `FCOV_REG.set_cov_init_trig_wl_dqsg_data_eye_train_scenario;
        `CFG.write_register(`PIR, `GRM.pir);
        `CFG.nops(3); // results in a reset that is 4 clocks wide
        `GRM.pir[6] = 1'b1;
        `FCOV_REG.set_cov_registers_write(`PIR ,`GRM.pir,`VALUE_REGISTER_DATA);
        `FCOV_REG.set_cov_init_trig_pll_dcal_phy_dram_scenario;
        `FCOV_REG.set_cov_init_trig_wl_dqsg_data_eye_train_scenario;
        `CFG.write_register(`PIR, `GRM.pir);
        `CFG.nops(4); // wait 4 clock cycles
      end
    end
  endtask // phy_soft_reset

  // soft resets the PHY FIFOs by writing to the PGCR0
  task phy_fifo_reset;
    begin
      `GRM.pgcr0[26] = 1'b0;
      @(posedge `CFG.clk);
      `CFG.write_register(`PGCR0, `GRM.pgcr0);
      `FCOV_REG.set_cov_registers_write(`PGCR0 ,`GRM.pgcr0,`VALUE_REGISTER_DATA);
      `CFG.nops(3);
      `GRM.pgcr0[26] = 1'b1;
      @(posedge `CFG.clk);
      `CFG.write_register(`PGCR0, `GRM.pgcr0);
      `FCOV_REG.set_cov_registers_write(`PGCR0 ,`GRM.pgcr0,`VALUE_REGISTER_DATA);
      `CFG.nops(3);
    end
  endtask // phy_fifo_reset

  
  // phy power-up
  // --------
  // executes the power-up sequence
  task phy_power_up;
    reg [`REG_DATA_WIDTH-1:0] word;
    integer                   nop_cnt_after_rst;
    integer                   i;
    `ifdef DWC_DDRPHY_BOARD_DELAYS   //this ifdef enables the *framework*
      integer  brd_cfg_idx, brd_cfg_idx2, brd_cfg_idx3, brd_cfg_idx4, tempvar_brddly, flybydelay_temp ;
    `endif

    begin
  `ifdef DWC_DDRPHY_EMUL_XILINX
      -> e_emul_sdram_disconnect;
       `SYS.disconnect_all_sdrams;
  `endif
      `ifdef DWC_DDRPHY_BOARD_DELAYS
        //implement the chosen topology into ddr_board_cfg
        `ifdef DWC_DDRPHY_EMUL_XILINX 
          pPVT_CORNER           = 0.5 ;
          pODR_MAX              = 25  ;
          pBOARD_SKEW_MAX       = 10  ;
          pAC_BOARD_MAX         = 500 ;
          pDX_BOARD_MAX         = 500 ;
          pDX_AC_BOARD_MATCH    = 1   ;
          pFLYBY_UNIT_DELAY_MAX = 100 ;
          pLOAD_STARTUP_DELAYS  = 1   ;
        `else 
          case(pBOARD_CONFIG_TYPE)
            `BC_MATCHED_FLYBY_TOPOLOGY : begin
               pPVT_CORNER           = 0.0 ;
               pODR_MAX              = 0   ;
               pBOARD_SKEW_MAX       = 0   ;
               pAC_BOARD_MAX         = 250 ;
               pDX_BOARD_MAX         = 250 ;
               pDX_AC_BOARD_MATCH    = 1   ;   
               pFLYBY_UNIT_DELAY_MAX = 50  ;
               pLOAD_STARTUP_DELAYS  = 1   ;
            end
            `AVG_MATCHED_FLYBY_TOPOLOGY : begin
               pPVT_CORNER           = 0.5 ;
               pODR_MAX              = 25  ;
               pBOARD_SKEW_MAX       = 10  ;
               pAC_BOARD_MAX         = 500 ;
               pDX_BOARD_MAX         = 500 ;
               pDX_AC_BOARD_MATCH    = 1   ;
               pFLYBY_UNIT_DELAY_MAX = 100 ;
               pLOAD_STARTUP_DELAYS  = 1   ;
            end
            `WC_MATCHED_FLYBY_TOPOLOGY : begin
               pPVT_CORNER           = 1.0 ;
               pODR_MAX              = 75  ;
               pBOARD_SKEW_MAX       = 25  ;
               pAC_BOARD_MAX         = 1000;
               pDX_BOARD_MAX         = 1000;
               pDX_AC_BOARD_MATCH    = 1   ;
               pFLYBY_UNIT_DELAY_MAX = 100 ;
               pLOAD_STARTUP_DELAYS  = 1   ;
            end
            `BC_MATCHED_T_TOPOLOGY : begin
               pPVT_CORNER           = 0.0 ;
               pODR_MAX              = 0   ;
               pBOARD_SKEW_MAX       = 0   ;
               pAC_BOARD_MAX         = 500 ;
               pDX_BOARD_MAX         = 500 ;
               pDX_AC_BOARD_MATCH    = 1   ;
               pFLYBY_UNIT_DELAY_MAX = 0   ;
               pLOAD_STARTUP_DELAYS  = 1   ;
            end   
            `AVG_MATCHED_T_TOPOLOGY : begin
               pPVT_CORNER           = 0.5 ;
               pODR_MAX              = 25  ;
               pBOARD_SKEW_MAX       = 10  ;
               pAC_BOARD_MAX         = 1000;
               pDX_BOARD_MAX         = 1000;
               pDX_AC_BOARD_MATCH    = 1   ;
               pFLYBY_UNIT_DELAY_MAX = 0   ;
               pLOAD_STARTUP_DELAYS  = 1   ;
            end   
            `WC_MATCHED_T_TOPOLOGY : begin
               pPVT_CORNER           = 1.0 ;
               pODR_MAX              = 75  ;
               pBOARD_SKEW_MAX       = 25  ;
               pAC_BOARD_MAX         = 2000;
               pDX_BOARD_MAX         = 2000;
               pDX_AC_BOARD_MATCH    = 1   ;
               pFLYBY_UNIT_DELAY_MAX = 0   ;
               pLOAD_STARTUP_DELAYS  = 1   ;
            end   
            `BC_UNMATCH_FLYBY_TOPOLOGY : begin
               pPVT_CORNER           = 0.0 ;
               pODR_MAX              = 0   ;
               pBOARD_SKEW_MAX       = 0   ;
               pAC_BOARD_MAX         = 150 ;
               pDX_BOARD_MAX         = 150 ;
               pDX_AC_BOARD_MATCH    = 0   ;
               pFLYBY_UNIT_DELAY_MAX = 25  ;
               pLOAD_STARTUP_DELAYS  = 1   ;
            end  
            `AVG_UNMATCH_FLYBY_TOPOLOGY : begin
               pPVT_CORNER           = 0.5 ;
               pODR_MAX              = 25  ;
               pBOARD_SKEW_MAX       = 10  ;
               pAC_BOARD_MAX         = 300 ;
               pDX_BOARD_MAX         = 300 ;
               pDX_AC_BOARD_MATCH    = 0   ;
               pFLYBY_UNIT_DELAY_MAX = 50  ;
               pLOAD_STARTUP_DELAYS  = 1   ;
            end   
            `WC_UNMATCH_FLYBY_TOPOLOGY : begin
               pPVT_CORNER           = 1.0 ;
               pODR_MAX              = 75  ;
               pBOARD_SKEW_MAX       = 25  ;
               pAC_BOARD_MAX         = 500 ;
               pDX_BOARD_MAX         = 500 ;
               pDX_AC_BOARD_MATCH    = 0   ;
               pFLYBY_UNIT_DELAY_MAX = 50  ;
               pLOAD_STARTUP_DELAYS  = 1   ;
            end   
            `BC_UNMATCH_T_TOPOLOGY : begin
               pPVT_CORNER           = 0.0 ;
               pODR_MAX              = 0   ;
               pBOARD_SKEW_MAX       = 0   ;
               pAC_BOARD_MAX         = 150 ;
               pDX_BOARD_MAX         = 150 ;
               pDX_AC_BOARD_MATCH    = 0   ;
               pFLYBY_UNIT_DELAY_MAX = 0   ;
               pLOAD_STARTUP_DELAYS  = 1   ;
            end   
            `AVG_UNMATCH_T_TOPOLOGY : begin
               pPVT_CORNER           = 0.5 ;
               pODR_MAX              = 25  ;
               pBOARD_SKEW_MAX       = 10  ;
               pAC_BOARD_MAX         = 300 ;
               pDX_BOARD_MAX         = 300 ;
               pDX_AC_BOARD_MATCH    = 0   ;
               pFLYBY_UNIT_DELAY_MAX = 0   ;
               pLOAD_STARTUP_DELAYS  = 1   ;
            end   
            `WC_UNMATCH_T_TOPOLOGY : begin
               pPVT_CORNER           = 1.0 ;
               pODR_MAX              = 75  ;
               pBOARD_SKEW_MAX       = 25  ;
               pAC_BOARD_MAX         = 500 ;
               pDX_BOARD_MAX         = 500 ;
               pDX_AC_BOARD_MATCH    = 0   ;
               pFLYBY_UNIT_DELAY_MAX = 0   ;
               pLOAD_STARTUP_DELAYS  = 1   ;
            end   
            default : begin   //cases when we want board delays, but not a specific topology
               pPVT_CORNER           = 0.0 ;
               pODR_MAX              = 0   ;
               pBOARD_SKEW_MAX       = 0   ;
               pAC_BOARD_MAX         = 0   ;
               pDX_BOARD_MAX         = 0   ;
               pDX_AC_BOARD_MATCH    = 0   ;
               pFLYBY_UNIT_DELAY_MAX = 0   ;
               pLOAD_STARTUP_DELAYS  = 0   ;
            end
          endcase
        `endif
        
        
        `ifdef DDR2
          if (pFLYBY_UNIT_DELAY_MAX != 0)  $display("WARNING: DDR2 mode can not be used with fly-by topology due to lack of WL. Matching fly-by delay in DX lanes...");
          //pFLYBY_UNIT_DELAY_MAX = 0 ;   //no fly-by in DDR2...
        `endif  
        
//`ifndef DWC_DDRPHY_EMUL_XILINX
        if (pLOAD_STARTUP_DELAYS==1)  begin
           //`TB.u_ddr_board_cfg.set_pvt(pPVT_CORNER);
           flybydelay_temp = 0 ;

        `ifdef BIDIRECTIONAL_SDRAM_DELAYS 
           for(brd_cfg_idx=0 ;brd_cfg_idx < pNO_OF_PRANKS; brd_cfg_idx = brd_cfg_idx+1) begin
        `else 
            begin //without BiDir SDRAM delays, only rank 0 delays will be used
             brd_cfg_idx=0;
        `endif     
             //AC configs    
             if (pAC_BOARD_MAX - pBOARD_DELAY_MIN +1 > 0)  tempvar_brddly = {$random} % (pAC_BOARD_MAX - pBOARD_DELAY_MIN +1) + pBOARD_DELAY_MIN;  //min delay is 20ps
             else tempvar_brddly = 0 ;    
//             `TB.u_ddr_board_cfg.config_delay("AC",0,brd_cfg_idx,0,0,tempvar_brddly);

             for(brd_cfg_idx3=0;brd_cfg_idx3<`DWC_CK_WIDTH;brd_cfg_idx3=brd_cfg_idx3+1) begin
               `TB.u_ddr_board_cfg.config_delay("ck_io"  , 0, brd_cfg_idx, 0, brd_cfg_idx3, {$random} % (pODR_MAX+1));        //ck_io_delay OUT (BOARD)
               `TB.u_ddr_board_cfg.config_delay("ck_io"  , 1, brd_cfg_idx, 0, brd_cfg_idx3, {$random} % (pODR_MAX+1));        //ck_io_delay IN  (BOARD)
               `TB.u_ddr_board_cfg.config_delay("ck"     , 0, brd_cfg_idx, 0, brd_cfg_idx3, {$random} % (pBOARD_SKEW_MAX+1)); //ck_delay -> ck_sdram_dly (sdram model)
               `TB.u_ddr_board_cfg.config_delay("ckn_io" , 0, brd_cfg_idx, 0, brd_cfg_idx3, {$random} % (pODR_MAX+1));
               `TB.u_ddr_board_cfg.config_delay("ckn_io" , 1, brd_cfg_idx, 0, brd_cfg_idx3, {$random} % (pODR_MAX+1));
               `TB.u_ddr_board_cfg.config_delay("ckn"    , 0, brd_cfg_idx, 0, brd_cfg_idx3, {$random} % (pBOARD_SKEW_MAX+1));   
             end       
        `ifdef BIDIRECTIONAL_SDRAM_DELAYS     
             `TB.u_ddr_board_cfg.config_delay("csn_io"   , 0, brd_cfg_idx, 0, brd_cfg_idx2, {$random} % (pODR_MAX+1));
             `TB.u_ddr_board_cfg.config_delay("csn_io"   , 1, brd_cfg_idx, 0, brd_cfg_idx2, {$random} % (pODR_MAX+1));
             `TB.u_ddr_board_cfg.config_delay("csn"      , 0, brd_cfg_idx, 0, brd_cfg_idx2, {$random} % (pBOARD_SKEW_MAX+1));       
             `TB.u_ddr_board_cfg.config_delay("cke_io"   , 0, brd_cfg_idx, 0, brd_cfg_idx2, {$random} % (pODR_MAX+1));
             `TB.u_ddr_board_cfg.config_delay("cke_io"   , 1, brd_cfg_idx, 0, brd_cfg_idx2, {$random} % (pODR_MAX+1));
             `TB.u_ddr_board_cfg.config_delay("cke"      , 0, brd_cfg_idx, 0, brd_cfg_idx2, {$random} % (pBOARD_SKEW_MAX+1));       
             `TB.u_ddr_board_cfg.config_delay("odt_io"   , 0, brd_cfg_idx, 0, brd_cfg_idx2, {$random} % (pODR_MAX+1));
             `TB.u_ddr_board_cfg.config_delay("odt_io"   , 1, brd_cfg_idx, 0, brd_cfg_idx2, {$random} % (pODR_MAX+1));
             `TB.u_ddr_board_cfg.config_delay("odt"      , 0, brd_cfg_idx, 0, brd_cfg_idx2, {$random} % (pBOARD_SKEW_MAX+1));   
        `else                                                                               
             `TB.u_ddr_board_cfg.config_delay("csn_io"   , 0, `ALL_RANKS,  0, brd_cfg_idx2, {$random} % (pODR_MAX+1));
             `TB.u_ddr_board_cfg.config_delay("csn_io"   , 1, `ALL_RANKS,  0, brd_cfg_idx2, {$random} % (pODR_MAX+1));
             `TB.u_ddr_board_cfg.config_delay("csn"      , 0, `ALL_RANKS,  0, brd_cfg_idx2, {$random} % (pBOARD_SKEW_MAX+1));       
             `TB.u_ddr_board_cfg.config_delay("cke_io"   , 0, `ALL_RANKS,  0, brd_cfg_idx2, {$random} % (pODR_MAX+1));
             `TB.u_ddr_board_cfg.config_delay("cke_io"   , 1, `ALL_RANKS,  0, brd_cfg_idx2, {$random} % (pODR_MAX+1));
             `TB.u_ddr_board_cfg.config_delay("cke"      , 0, `ALL_RANKS,  0, brd_cfg_idx2, {$random} % (pBOARD_SKEW_MAX+1));       
             `TB.u_ddr_board_cfg.config_delay("odt_io"   , 0, `ALL_RANKS,  0, brd_cfg_idx2, {$random} % (pODR_MAX+1));
             `TB.u_ddr_board_cfg.config_delay("odt_io"   , 1, `ALL_RANKS,  0, brd_cfg_idx2, {$random} % (pODR_MAX+1));
             `TB.u_ddr_board_cfg.config_delay("odt"      , 0, `ALL_RANKS,  0, brd_cfg_idx2, {$random} % (pBOARD_SKEW_MAX+1));   
        `endif                                                                              

             `TB.u_ddr_board_cfg.config_delay("rasn_io"  , 0, brd_cfg_idx, 0, brd_cfg_idx2, {$random} % (pODR_MAX+1));
             `TB.u_ddr_board_cfg.config_delay("rasn_io"  , 1, brd_cfg_idx, 0, brd_cfg_idx2, {$random} % (pODR_MAX+1));
             `TB.u_ddr_board_cfg.config_delay("rasn"     , 0, brd_cfg_idx, 0, brd_cfg_idx2, {$random} % (pBOARD_SKEW_MAX+1));       
             `TB.u_ddr_board_cfg.config_delay("casn_io"  , 0, brd_cfg_idx, 0, brd_cfg_idx2, {$random} % (pODR_MAX+1));
             `TB.u_ddr_board_cfg.config_delay("casn_io"  , 1, brd_cfg_idx, 0, brd_cfg_idx2, {$random} % (pODR_MAX+1));
             `TB.u_ddr_board_cfg.config_delay("casn"     , 0, brd_cfg_idx, 0, brd_cfg_idx2, {$random} % (pBOARD_SKEW_MAX+1));       
             `TB.u_ddr_board_cfg.config_delay("wen_io"   , 0, brd_cfg_idx, 0, brd_cfg_idx2, {$random} % (pODR_MAX+1));
             `TB.u_ddr_board_cfg.config_delay("wen_io"   , 1, brd_cfg_idx, 0, brd_cfg_idx2, {$random} % (pODR_MAX+1));
             `TB.u_ddr_board_cfg.config_delay("wen"      , 0, brd_cfg_idx, 0, brd_cfg_idx2, {$random} % (pBOARD_SKEW_MAX+1));

             `TB.u_ddr_board_cfg.config_delay("cid_io"   , 0, brd_cfg_idx, 0, brd_cfg_idx2, {$random} % (pODR_MAX+1));
             `TB.u_ddr_board_cfg.config_delay("cid_io"   , 1, brd_cfg_idx, 0, brd_cfg_idx2, {$random} % (pODR_MAX+1));
             `TB.u_ddr_board_cfg.config_delay("cid"      , 0, brd_cfg_idx, 0, brd_cfg_idx2, {$random} % (pBOARD_SKEW_MAX+1));       
             `TB.u_ddr_board_cfg.config_delay("actn_io"  , 0, brd_cfg_idx, 0, brd_cfg_idx2, {$random} % (pODR_MAX+1));
             `TB.u_ddr_board_cfg.config_delay("actn_io"  , 1, brd_cfg_idx, 0, brd_cfg_idx2, {$random} % (pODR_MAX+1));
             `TB.u_ddr_board_cfg.config_delay("actn"     , 0, brd_cfg_idx, 0, brd_cfg_idx2, {$random} % (pBOARD_SKEW_MAX+1));       
             `TB.u_ddr_board_cfg.config_delay("parin_io" , 0, brd_cfg_idx, 0, brd_cfg_idx2, {$random} % (pODR_MAX+1));
             `TB.u_ddr_board_cfg.config_delay("parin_io" , 1, brd_cfg_idx, 0, brd_cfg_idx2, {$random} % (pODR_MAX+1));
             `TB.u_ddr_board_cfg.config_delay("parin"    , 0, brd_cfg_idx, 0, brd_cfg_idx2, {$random} % (pBOARD_SKEW_MAX+1));       
             `TB.u_ddr_board_cfg.config_delay("alertn_io", 0, brd_cfg_idx, 0, brd_cfg_idx2, {$random} % (pODR_MAX+1));
             `TB.u_ddr_board_cfg.config_delay("alertn_io", 1, brd_cfg_idx, 0, brd_cfg_idx2, {$random} % (pODR_MAX+1));
             `TB.u_ddr_board_cfg.config_delay("alertn"   , 0, brd_cfg_idx, 0, brd_cfg_idx2, {$random} % (pBOARD_SKEW_MAX+1));       

             for(brd_cfg_idx3=0;brd_cfg_idx3<`DWC_ADDR_WIDTH; brd_cfg_idx3=brd_cfg_idx3+1) begin    
               `TB.u_ddr_board_cfg.config_delay("addr_io", 0, brd_cfg_idx, 0, brd_cfg_idx3, {$random} % (pODR_MAX+1));
               `TB.u_ddr_board_cfg.config_delay("addr_io", 1, brd_cfg_idx, 0, brd_cfg_idx3, {$random} % (pODR_MAX+1));
               `TB.u_ddr_board_cfg.config_delay("addr"   , 0, brd_cfg_idx, 0, brd_cfg_idx3, {$random} % (pBOARD_SKEW_MAX+1));
             end  
             for(brd_cfg_idx3=0;brd_cfg_idx3<`SDRAM_BANK_WIDTH;brd_cfg_idx3=brd_cfg_idx3+1) begin      
               `TB.u_ddr_board_cfg.config_delay("ba_io"  , 0, brd_cfg_idx, 0, brd_cfg_idx3, {$random} % (pODR_MAX+1));
               `TB.u_ddr_board_cfg.config_delay("ba_io"  , 1, brd_cfg_idx, 0, brd_cfg_idx3, {$random} % (pODR_MAX+1));
               `TB.u_ddr_board_cfg.config_delay("ba"     , 0, brd_cfg_idx, 0, brd_cfg_idx3, {$random} % (pBOARD_SKEW_MAX+1));
             end
             
             for(brd_cfg_idx2=0;brd_cfg_idx2<`DWC_NO_OF_BYTES;brd_cfg_idx2=brd_cfg_idx2+1) begin
               //SDRAM configs
               flybydelay_temp = flybydelay_temp + {$random} % (pFLYBY_UNIT_DELAY_MAX*(`SDRAM_DATA_WIDTH/8) +1);  
//        `ifdef BIDIRECTIONAL_SDRAM_DELAYS   
//               `TB.u_ddr_board_cfg.config_delay("AC"     ,0,brd_cfg_idx,0,brd_cfg_idx2,flybydelay_temp);
//        `else   //put same flyby delay in other ranks
//               `TB.u_ddr_board_cfg.config_delay("AC"     ,0,`ALL_RANKS,0,brd_cfg_idx2,flybydelay_temp);
//        `endif
                    
               //Dx8 configs
//        `ifdef DDR2      
//               if (pDX_AC_BOARD_MATCH==1) `TB.u_ddr_board_cfg.config_delay("DXN",0,brd_cfg_idx,0,brd_cfg_idx2,tempvar_brddly+flybydelay_temp);
//               else `TB.u_ddr_board_cfg.config_delay("DXN",0,brd_cfg_idx,0,brd_cfg_idx2,{$random} % (pDX_BOARD_MAX - pBOARD_DELAY_MIN +1) + pBOARD_DELAY_MIN + flybydelay_temp);
//        `else       
//               if (pDX_AC_BOARD_MATCH==1) `TB.u_ddr_board_cfg.config_delay("DXN",0,brd_cfg_idx,0,brd_cfg_idx2,tempvar_brddly);
//               else `TB.u_ddr_board_cfg.config_delay("DXN",0,brd_cfg_idx,0,brd_cfg_idx2,{$random} % (pDX_BOARD_MAX - pBOARD_DELAY_MIN +1) + pBOARD_DELAY_MIN);
//        `endif       
           end  // rank loop      

        `ifdef BIDIRECTIONAL_SDRAM_DELAYS 
           for(brd_cfg_idx=0; brd_cfg_idx < pNO_OF_LRANKS; brd_cfg_idx = brd_cfg_idx+1) begin
        `else 
            begin //without BiDir SDRAM delays, only rank 0 delays will be used
             brd_cfg_idx=0;
        `endif     
               `TB.u_ddr_board_cfg.config_delay("dqs_io"   , 0, brd_cfg_idx, 0, brd_cfg_idx2, {$random} % (pODR_MAX+1));
               `TB.u_ddr_board_cfg.config_delay("dqs_io"   , 1, brd_cfg_idx, 0, brd_cfg_idx2, {$random} % (pODR_MAX+1));
               `TB.u_ddr_board_cfg.config_delay("dqs"      , 0, brd_cfg_idx, 0, brd_cfg_idx2, {$random} % (pBOARD_SKEW_MAX+1));
               `TB.u_ddr_board_cfg.config_delay("dqsn_io"  , 0, brd_cfg_idx, 0, brd_cfg_idx2, {$random} % (pODR_MAX+1));
               `TB.u_ddr_board_cfg.config_delay("dqsn_io"  , 1, brd_cfg_idx, 0, brd_cfg_idx2, {$random} % (pODR_MAX+1));
               `TB.u_ddr_board_cfg.config_delay("dqsn"     , 0, brd_cfg_idx, 0, brd_cfg_idx2, {$random} % (pBOARD_SKEW_MAX+1));
               `TB.u_ddr_board_cfg.config_delay("dm_io"    , 0, brd_cfg_idx, 0, brd_cfg_idx2, {$random} % (pODR_MAX+1));
               `TB.u_ddr_board_cfg.config_delay("dm_io"    , 1, brd_cfg_idx, 0, brd_cfg_idx2, {$random} % (pODR_MAX+1));
               `TB.u_ddr_board_cfg.config_delay("dm"       , 0, brd_cfg_idx, 0, brd_cfg_idx2, {$random} % (pBOARD_SKEW_MAX+1));
               for(brd_cfg_idx3=0;brd_cfg_idx3<8;brd_cfg_idx3=brd_cfg_idx3+1) begin
                 `TB.u_ddr_board_cfg.config_delay("dq_io"  , 0, brd_cfg_idx, 0, brd_cfg_idx2*8+brd_cfg_idx3, {$random} % (pODR_MAX+1));
                 `TB.u_ddr_board_cfg.config_delay("dq_io"  , 1, brd_cfg_idx, 0, brd_cfg_idx2*8+brd_cfg_idx3, {$random} % (pODR_MAX+1));
                 `TB.u_ddr_board_cfg.config_delay("dq"     , 0, brd_cfg_idx, 0, brd_cfg_idx2*8+brd_cfg_idx3, {$random} % (pBOARD_SKEW_MAX+1));
               end
             end
           end  // rank loop         
           
           if (pBOARD_CONFIG_TYPE!==0) `TB.u_ddr_board_cfg.set_board_cfg ;
        end   
        
        #0.001;  
          `ifdef DWC_JITTER_DEFAULTS
             for(brd_cfg_idx4=0;   brd_cfg_idx4 <`DWC_NO_OF_RANKS; brd_cfg_idx4 = brd_cfg_idx4+1) begin
               for(brd_cfg_idx2=0; brd_cfg_idx2 <`NUM_DEVICES;     brd_cfg_idx2 = brd_cfg_idx2+1) begin
                 
                 `TB.u_ddr_board_cfg.config_jitter("rj_peak" ,"dqs"  ,brd_cfg_idx4, brd_cfg_idx2, pRANDOM_JITTER_PK2PK);
                 `TB.u_ddr_board_cfg.config_jitter("rj_peak" ,"dqsn" ,brd_cfg_idx4, brd_cfg_idx2, pRANDOM_JITTER_PK2PK);
                 `TB.u_ddr_board_cfg.config_jitter("rj_peak" ,"dm"   ,brd_cfg_idx4, brd_cfg_idx2, pRANDOM_JITTER_PK2PK);
                 `TB.u_ddr_board_cfg.config_jitter("rj_peak" ,"dq"   ,brd_cfg_idx4, brd_cfg_idx2, pRANDOM_JITTER_PK2PK);
                 `TB.u_ddr_board_cfg.config_jitter("rj_peak" ,"dqs"  ,brd_cfg_idx4, brd_cfg_idx2, pRANDOM_JITTER_PK2PK);
                 `TB.u_ddr_board_cfg.config_jitter("rj_peak" ,"dqsn" ,brd_cfg_idx4, brd_cfg_idx2, pRANDOM_JITTER_PK2PK);
                 `TB.u_ddr_board_cfg.config_jitter("rj_peak" ,"dm"   ,brd_cfg_idx4, brd_cfg_idx2, pRANDOM_JITTER_PK2PK);
                 `TB.u_ddr_board_cfg.config_jitter("rj_peak" ,"dq"   ,brd_cfg_idx4, brd_cfg_idx2, pRANDOM_JITTER_PK2PK);
                                                                                                  
                 `TB.u_ddr_board_cfg.config_jitter("rj_sigma","dqs"  ,brd_cfg_idx4, brd_cfg_idx2, pRANDOM_JITTER_SIGMA);
                 `TB.u_ddr_board_cfg.config_jitter("rj_sigma","dqsn" ,brd_cfg_idx4, brd_cfg_idx2, pRANDOM_JITTER_SIGMA);
                 `TB.u_ddr_board_cfg.config_jitter("rj_sigma","dm"   ,brd_cfg_idx4, brd_cfg_idx2, pRANDOM_JITTER_SIGMA);
                 `TB.u_ddr_board_cfg.config_jitter("rj_sigma","dq"   ,brd_cfg_idx4, brd_cfg_idx2, pRANDOM_JITTER_SIGMA);
                 `TB.u_ddr_board_cfg.config_jitter("rj_sigma","dqs"  ,brd_cfg_idx4, brd_cfg_idx2, pRANDOM_JITTER_SIGMA);
                 `TB.u_ddr_board_cfg.config_jitter("rj_sigma","dqsn" ,brd_cfg_idx4, brd_cfg_idx2, pRANDOM_JITTER_SIGMA);
                 `TB.u_ddr_board_cfg.config_jitter("rj_sigma","dm"   ,brd_cfg_idx4, brd_cfg_idx2, pRANDOM_JITTER_SIGMA);
                 `TB.u_ddr_board_cfg.config_jitter("rj_sigma","dq"   ,brd_cfg_idx4, brd_cfg_idx2, pRANDOM_JITTER_SIGMA);
                                                                                                  
                 `TB.u_ddr_board_cfg.config_jitter("sj_peak" ,"dqs"  ,brd_cfg_idx4, brd_cfg_idx2, pSIN_JITTER_PK2PK);
                 `TB.u_ddr_board_cfg.config_jitter("sj_peak" ,"dqsn" ,brd_cfg_idx4, brd_cfg_idx2, pSIN_JITTER_PK2PK);
                 `TB.u_ddr_board_cfg.config_jitter("sj_peak" ,"dm"   ,brd_cfg_idx4, brd_cfg_idx2, pSIN_JITTER_PK2PK);
                 `TB.u_ddr_board_cfg.config_jitter("sj_peak" ,"dq"   ,brd_cfg_idx4, brd_cfg_idx2, pSIN_JITTER_PK2PK);
                 `TB.u_ddr_board_cfg.config_jitter("sj_peak" ,"dqs"  ,brd_cfg_idx4, brd_cfg_idx2, pSIN_JITTER_PK2PK);
                 `TB.u_ddr_board_cfg.config_jitter("sj_peak" ,"dqsn" ,brd_cfg_idx4, brd_cfg_idx2, pSIN_JITTER_PK2PK);
                 `TB.u_ddr_board_cfg.config_jitter("sj_peak" ,"dm"   ,brd_cfg_idx4, brd_cfg_idx2, pSIN_JITTER_PK2PK);
                 `TB.u_ddr_board_cfg.config_jitter("sj_peak" ,"dq"   ,brd_cfg_idx4, brd_cfg_idx2, pSIN_JITTER_PK2PK);
                                                                                                  
                 `TB.u_ddr_board_cfg.config_jitter("sj_freq" ,"dqs"  ,brd_cfg_idx4, brd_cfg_idx2, pSIN_JITTER_FREQ);
                 `TB.u_ddr_board_cfg.config_jitter("sj_freq" ,"dqsn" ,brd_cfg_idx4, brd_cfg_idx2, pSIN_JITTER_FREQ);
                 `TB.u_ddr_board_cfg.config_jitter("sj_freq" ,"dm"   ,brd_cfg_idx4, brd_cfg_idx2, pSIN_JITTER_FREQ);
                 `TB.u_ddr_board_cfg.config_jitter("sj_freq" ,"dq"   ,brd_cfg_idx4, brd_cfg_idx2, pSIN_JITTER_FREQ);
                 `TB.u_ddr_board_cfg.config_jitter("sj_freq" ,"dqs"  ,brd_cfg_idx4, brd_cfg_idx2, pSIN_JITTER_FREQ);
                 `TB.u_ddr_board_cfg.config_jitter("sj_freq" ,"dqsn" ,brd_cfg_idx4, brd_cfg_idx2, pSIN_JITTER_FREQ);
                 `TB.u_ddr_board_cfg.config_jitter("sj_freq" ,"dm"   ,brd_cfg_idx4, brd_cfg_idx2, pSIN_JITTER_FREQ);
                 `TB.u_ddr_board_cfg.config_jitter("sj_freq" ,"dq"   ,brd_cfg_idx4, brd_cfg_idx2, pSIN_JITTER_FREQ);
                                                                                                  
                 `TB.u_ddr_board_cfg.config_jitter("sj_phase","dqs"  ,brd_cfg_idx4, brd_cfg_idx2, pSIN_JITTER_PHASE);
                 `TB.u_ddr_board_cfg.config_jitter("sj_phase","dqsn" ,brd_cfg_idx4, brd_cfg_idx2, pSIN_JITTER_PHASE);
                 `TB.u_ddr_board_cfg.config_jitter("sj_phase","dm"   ,brd_cfg_idx4, brd_cfg_idx2, pSIN_JITTER_PHASE);
                 `TB.u_ddr_board_cfg.config_jitter("sj_phase","dq"   ,brd_cfg_idx4, brd_cfg_idx2, pSIN_JITTER_PHASE);
                 `TB.u_ddr_board_cfg.config_jitter("sj_phase","dqs"  ,brd_cfg_idx4, brd_cfg_idx2, pSIN_JITTER_PHASE);
                 `TB.u_ddr_board_cfg.config_jitter("sj_phase","dqsn" ,brd_cfg_idx4, brd_cfg_idx2, pSIN_JITTER_PHASE);
                 `TB.u_ddr_board_cfg.config_jitter("sj_phase","dm"   ,brd_cfg_idx4, brd_cfg_idx2, pSIN_JITTER_PHASE);
                 `TB.u_ddr_board_cfg.config_jitter("sj_phase","dq"   ,brd_cfg_idx4, brd_cfg_idx2, pSIN_JITTER_PHASE);
                                                                                                  
                 `TB.u_ddr_board_cfg.config_jitter("dcd"     ,"dqs"  ,brd_cfg_idx4, brd_cfg_idx2, pDCD_VALUE);
                 `TB.u_ddr_board_cfg.config_jitter("dcd"     ,"dqsn" ,brd_cfg_idx4, brd_cfg_idx2, pDCD_VALUE);
                 `TB.u_ddr_board_cfg.config_jitter("dcd"     ,"dm"   ,brd_cfg_idx4, brd_cfg_idx2, pDCD_VALUE);
                 `TB.u_ddr_board_cfg.config_jitter("dcd"     ,"dq"   ,brd_cfg_idx4, brd_cfg_idx2, pDCD_VALUE);
                 `TB.u_ddr_board_cfg.config_jitter("dcd"     ,"dqs"  ,brd_cfg_idx4, brd_cfg_idx2, pDCD_VALUE);
                 `TB.u_ddr_board_cfg.config_jitter("dcd"     ,"dqsn" ,brd_cfg_idx4, brd_cfg_idx2, pDCD_VALUE);
                 `TB.u_ddr_board_cfg.config_jitter("dcd"     ,"dm"   ,brd_cfg_idx4, brd_cfg_idx2, pDCD_VALUE);
                 `TB.u_ddr_board_cfg.config_jitter("dcd"     ,"dq"   ,brd_cfg_idx4, brd_cfg_idx2, pDCD_VALUE);
                                                                                                  
                 `TB.u_ddr_board_cfg.config_jitter("isi"     ,"dqs"  ,brd_cfg_idx4, brd_cfg_idx2, pISI_VALUE);
                 `TB.u_ddr_board_cfg.config_jitter("isi"     ,"dqsn" ,brd_cfg_idx4, brd_cfg_idx2, pISI_VALUE);
                 `TB.u_ddr_board_cfg.config_jitter("isi"     ,"dm"   ,brd_cfg_idx4, brd_cfg_idx2, pISI_VALUE);
                 `TB.u_ddr_board_cfg.config_jitter("isi"     ,"dq"   ,brd_cfg_idx4, brd_cfg_idx2, pISI_VALUE);
                 `TB.u_ddr_board_cfg.config_jitter("isi"     ,"dqs"  ,brd_cfg_idx4, brd_cfg_idx2, pISI_VALUE);
                 `TB.u_ddr_board_cfg.config_jitter("isi"     ,"dqsn" ,brd_cfg_idx4, brd_cfg_idx2, pISI_VALUE);
                 `TB.u_ddr_board_cfg.config_jitter("isi"     ,"dm"   ,brd_cfg_idx4, brd_cfg_idx2, pISI_VALUE);
                 `TB.u_ddr_board_cfg.config_jitter("isi"     ,"dq"   ,brd_cfg_idx4, brd_cfg_idx2, pISI_VALUE);
               end
             end
             
             `TB.u_ddr_board_cfg.set_board_jitter_cfg ; 
          `endif
      `endif
//`endif      
`ifdef DWC_DDRPHY_EMUL_XILINX
  `ifdef DWC_DDRPHY_BOARD_DELAYS
        
        for (brd_cfg_idx=0; brd_cfg_idx <`DWC_NO_OF_RANKS; brd_cfg_idx=brd_cfg_idx+1) begin
          for (brd_cfg_idx2=0; brd_cfg_idx2<`RANK0.get_number_of_chips(`DWC_NO_OF_BYTES); brd_cfg_idx2=brd_cfg_idx2+1) begin
            tempvar_brddly = {$random(`SYS.seed)}%(pMAX_DC_BOARD_DLY);
            `SYS.set_write_board_delay(brd_cfg_idx, brd_cfg_idx2, tempvar_brddly);
            `SYS.set_read_board_delay (brd_cfg_idx, brd_cfg_idx2, tempvar_brddly);
          end
        end
        
        
        for(brd_cfg_idx=0;brd_cfg_idx<pNO_OF_PRANKS;brd_cfg_idx=brd_cfg_idx+1) begin
          for(brd_cfg_idx2=0;brd_cfg_idx2<`DWC_NO_OF_BYTES;brd_cfg_idx2=brd_cfg_idx2+1) begin
            tempvar_brddly = {$random(`SYS.seed)}%(pMAX_DC_BOARD_DLY);
            
            for(brd_cfg_idx3=0;brd_cfg_idx3<`TB.u_ddr_board_cfg.pNO_OF_DQS_PER_SDRAM;brd_cfg_idx3=brd_cfg_idx3+1) begin
              `TB.u_ddr_board_cfg.config_delay("dqs" ,`IN , brd_cfg_idx, brd_cfg_idx2, brd_cfg_idx3, tempvar_brddly);
              `TB.u_ddr_board_cfg.config_delay("dqsn",`IN , brd_cfg_idx, brd_cfg_idx2, brd_cfg_idx3, tempvar_brddly);
              `TB.u_ddr_board_cfg.config_delay("dm"  ,`IN , brd_cfg_idx, brd_cfg_idx2, brd_cfg_idx3, tempvar_brddly);
              `TB.u_ddr_board_cfg.config_delay("dqs" ,`OUT, brd_cfg_idx, brd_cfg_idx2, brd_cfg_idx3, tempvar_brddly);
              `TB.u_ddr_board_cfg.config_delay("dqsn",`OUT, brd_cfg_idx, brd_cfg_idx2, brd_cfg_idx3, tempvar_brddly);
              `TB.u_ddr_board_cfg.config_delay("dm"  ,`OUT, brd_cfg_idx, brd_cfg_idx2, brd_cfg_idx3, tempvar_brddly);
              for(brd_cfg_idx3=0;brd_cfg_idx3<8;brd_cfg_idx3=brd_cfg_idx3+1) begin
                 `TB.u_ddr_board_cfg.config_delay("dq",`IN , brd_cfg_idx, brd_cfg_idx2, brd_cfg_idx3, tempvar_brddly);
                 `TB.u_ddr_board_cfg.config_delay("dq",`OUT, brd_cfg_idx, brd_cfg_idx2, brd_cfg_idx3, tempvar_brddly);
              end
            end
            
            #0.001;  
          end
        end
        
        `TB.u_ddr_board_cfg.set_board_cfg ;
        #0.001;  
        /*
        `ifdef DWC_JITTER_DEFAULTS
          for(brd_cfg_idx4=0;brd_cfg_idx4<`DWC_NO_OF_RANKS;brd_cfg_idx4=brd_cfg_idx4+1) begin
            for(brd_cfg_idx2=0;brd_cfg_idx2<`NUM_DEVICES;brd_cfg_idx2=brd_cfg_idx2+1) begin
              `TB.u_ddr_board_cfg.config_jitter("rj_peak","dqs" ,brd_cfg_idx4,brd_cfg_idx2,pRANDOM_JITTER_PK2PK);
              `TB.u_ddr_board_cfg.config_jitter("rj_peak","dqsn",brd_cfg_idx4,brd_cfg_idx2,pRANDOM_JITTER_PK2PK);
              `TB.u_ddr_board_cfg.config_jitter("rj_peak","dm"  ,brd_cfg_idx4,brd_cfg_idx2,pRANDOM_JITTER_PK2PK);
              `TB.u_ddr_board_cfg.config_jitter("rj_peak","dq"  ,brd_cfg_idx4,brd_cfg_idx2,pRANDOM_JITTER_PK2PK);
              `TB.u_ddr_board_cfg.config_jitter("rj_sigma","dqs" ,brd_cfg_idx4,brd_cfg_idx2,pRANDOM_JITTER_SIGMA);
              `TB.u_ddr_board_cfg.config_jitter("rj_sigma","dqsn",brd_cfg_idx4,brd_cfg_idx2,pRANDOM_JITTER_SIGMA);
              `TB.u_ddr_board_cfg.config_jitter("rj_sigma","dm"  ,brd_cfg_idx4,brd_cfg_idx2,pRANDOM_JITTER_SIGMA);
              `TB.u_ddr_board_cfg.config_jitter("rj_sigma","dq"  ,brd_cfg_idx4,brd_cfg_idx2,pRANDOM_JITTER_SIGMA);
              `TB.u_ddr_board_cfg.config_jitter("sj_peak","dqs" ,brd_cfg_idx4,brd_cfg_idx2,pSIN_JITTER_PK2PK);
              `TB.u_ddr_board_cfg.config_jitter("sj_peak","dqsn",brd_cfg_idx4,brd_cfg_idx2,pSIN_JITTER_PK2PK);
              `TB.u_ddr_board_cfg.config_jitter("sj_peak","dm"  ,brd_cfg_idx4,brd_cfg_idx2,pSIN_JITTER_PK2PK);
              `TB.u_ddr_board_cfg.config_jitter("sj_peak","dq"  ,brd_cfg_idx4,brd_cfg_idx2,pSIN_JITTER_PK2PK);
              `TB.u_ddr_board_cfg.config_jitter("sj_freq","dqs" ,brd_cfg_idx4,brd_cfg_idx2,pSIN_JITTER_FREQ);
              `TB.u_ddr_board_cfg.config_jitter("sj_freq","dqsn",brd_cfg_idx4,brd_cfg_idx2,pSIN_JITTER_FREQ);
              `TB.u_ddr_board_cfg.config_jitter("sj_freq","dm"  ,brd_cfg_idx4,brd_cfg_idx2,pSIN_JITTER_FREQ);
              `TB.u_ddr_board_cfg.config_jitter("sj_freq","dq"  ,brd_cfg_idx4,brd_cfg_idx2,pSIN_JITTER_FREQ);
              `TB.u_ddr_board_cfg.config_jitter("dcd","dqs" ,brd_cfg_idx4,brd_cfg_idx2,pDCD_VALUE);
              `TB.u_ddr_board_cfg.config_jitter("dcd","dqsn",brd_cfg_idx4,brd_cfg_idx2,pDCD_VALUE);
              `TB.u_ddr_board_cfg.config_jitter("dcd","dm"  ,brd_cfg_idx4,brd_cfg_idx2,pDCD_VALUE);
              `TB.u_ddr_board_cfg.config_jitter("dcd","dq"  ,brd_cfg_idx4,brd_cfg_idx2,pDCD_VALUE);
              #0.001;
            end
          end
        `endif //DWC_JITTER_DEFAULTS
        `TB.u_ddr_board_cfg.set_board_jitter_cfg ; 
        */
        #0.001;  
  `endif //DWC_DDRPHY_BOARD_DELAYS
`endif //DWC_DDRPHY_EMUL_XILINX

`ifdef OVRD_TDQSCK
      // disable the flagging of undefined data buses as warnings because
      // disabled bytes will drive 'z' on DQS and DQ buses
      `CFG.nops(10);
      `SYS.disable_undefined_warning;
`endif

  `ifdef DWC_DDRPHY_EMUL_XILINX
       `SYS.disable_signal_probing =1;
  `endif

      nop_cnt_after_rst = `NOPS_AFTER_RST;

      // report simulation environment
      report_environment_configuration;

`ifdef SDF_ANNOTATE
      // disable timing checks of some flops during calibration and training
      ->force_notifiers;
      `ifdef DWC_DDRPHY_EMUL_XILINX
        ->force_emulXV6_notifiers;
      `endif
`endif

      if (reset_in_power_up) begin
        // reset
        //-> e_sys_powerup_start;
        reset;
        repeat (nop_cnt_after_rst) @(posedge clk);
      end

      `ifdef DWC_DDRPHY_JTAG
        // When using the JTAG interface put the TAP controller into a state
        // where we can access the Data Register
        `JTAG.t_set_IR_for_DR_access;
        repeat (10) @(posedge xclk);  
      `endif
          
      //  The PA Include file 
      @(posedge clk);
      `include "pa_phy_include.v"
      
      // set the SDRAM configuration
      word        = `DCR_DEFAULT;
      word[2:0]   = `DDR_MODE;

      // number of banks can be 4 or 8 for these sdram config
`ifdef LPDDR2
      word[9:8]   = (`LPDDR2_SX == 2) ? 2'b01 : 2'b00;
`endif
      word[27]    = `DWC_NO_SRA;
      word[28]    = `DWC_2T_MODE;
      word[29]    = `DWC_UDIMM;
   
   
`ifdef DWC_UDIMM         
   if (`DWC_UDIMM == 1 ) begin 
     `ifdef SDRAMx16        
        word[30]    = 1'b1; // ubg to indicate that BG[1] is unused
     `endif
   end
   else 
     word[30]    = 1'b0; // ubg to indicate that BG[1] is used
`endif
  


      if (word !== `DCR_DEFAULT) 
        `CFG.write_register(`DCR, word);
      // sample DCR
      `FCOV_REG.set_cov_registers_write(`DCR, word,`VALUE_REGISTER_DATA);           
      `FCOV_REG.set_cov_mpr_scenario;

`ifdef DWC_USE_SHARED_AC_TB
      `GRM.pgcr1[15] = 1'b1;
`endif
          
`ifdef DWC_DDRPHY_D4M_IO
      `GRM.pgcr1[8:7] = 2'b01;
`endif

`ifdef DWC_PER_RANK_RCD_CONFIG_EN      
      `GRM.pgcr1[19] = 1'b1;
`endif
	  
`ifdef DWC_SERIAL_DDL_CAL         
      // reduce PGCR1 filter depth to be 2'b00 (depth of 2), long dl calib cause tRFC_max
      // violation  
      if (shorten_ddl_cal)
        `GRM.pgcr1[14:13] = 2'b00;
`endif
      
      `CFG.write_register(`PGCR1, `GRM.pgcr1);

      `ifdef CTL_CAL_CLK_USE
        // use cal_clk for DDL calibration
        {`GRM.pgcr7[25], `GRM.pgcr7[5]} = 2'b11;
        `CFG.write_register(`PGCR7, `GRM.pgcr7);
      `endif


      // bypass the PLL if needed
`ifdef DWC_PLL_BYPASS
      pll_bypass;
`endif

      //trigger phy initialization
      `GRM.pir[0]  = 1'b1;                              // INIT
      `GRM.pir[1]  = 1'b1;                              // ZCAL
      `GRM.pir[4]  = 1'b1;                              // PLL
      `GRM.pir[5]  = 1'b1;                              // DCAL
      `GRM.pir[6]  = 1'b1;                              // PHYRST
      `FCOV_REG.set_cov_registers_write(`PIR, `GRM.pir,`VALUE_REGISTER_DATA);
      `FCOV_REG.set_cov_init_trig_pll_dcal_phy_dram_scenario;
      `FCOV_REG.set_cov_init_trig_wl_dqsg_data_eye_train_scenario;
      `CFG.write_register(`PIR, `GRM.pir);
`ifdef DWC_DDRPHY_X4MODE
      //set x4mode bit
      `GRM.dxccr[31]  = 1'b1;
      `CFG.write_register(`DXCCR, `GRM.dxccr);
      `FCOV_REG.set_cov_registers_write(`DXCCR, `GRM.dxccr,`VALUE_REGISTER_DATA);
`endif

      `CFG.poll_register(`PGSR0, 0, 0, 1'b1,  100, 1000000, "PHY initialization done...");
      `GRM.pgsr0[3:0] = {4{1'b1}}; // done status bits are set
      init = 1'b1;

      `ifdef SDF_ANNOTATE
            // re-enable timing checks of some flops disabled during calibration
            ->release_calib_notifiers;
      `endif

      
// TODO - initial code for controlling smode from the cmd line. Still needs more debug.
/*
      // check for SMODE register programming for skip init
     `ifdef DWC_DDRPHY_SMODE
      `ifdef DWC_SMODE_NO_INIT_ON_RST `TB.phy_smode[`SMODE_OFFSET_NO_INIT_ON_RST] = `DWC_SMODE_NO_INIT_ON_RST; `endif
      `ifdef DWC_SMODE_INIT_EN        `TB.phy_smode[`SMODE_OFFSET_INIT_EN       ] = `DWC_SMODE_INIT_EN;        `endif
      `ifdef DWC_SMODE_ZCAL_INIT_EN   `TB.phy_smode[`SMODE_OFFSET_ZCAL_INIT_EN  ] = `DWC_SMODE_ZCAL_INIT_EN;   `endif
      `ifdef DWC_SMODE_PLL_INIT_EN    `TB.phy_smode[`SMODE_OFFSET_PLL_INIT_EN   ] = `DWC_SMODE_PLL_INIT_EN;    `endif
      `ifdef DWC_SMODE_DDL_INIT_EN    `TB.phy_smode[`SMODE_OFFSET_DDL_INIT_EN   ] = `DWC_SMODE_DDL_INIT_EN;    `endif
     `endif // DWC_DDRPHY_SMODE
*/

      // if PLL bypass is enabled, enable it now
      if (pll_bypass_en)
        begin
            // since the controller clock will be slowed down, slow down the
            // configuration clock
            tTCLK_LO = 8*tACKL;
            tTCLK_HI = 8*tACKH;

          // PLL bypass transition point will cause some illegal clock
          // changes during transitions - disable clock checks; also some
          // SDRAM speed grades may complain at running with very low clock 
          // frequiecies
          disable_clock_checks;

          // enable bypass
          pll_bypass;
        end

      if (enable_mdlen) begin
        `SYS.phy_mdlen_bit(`TRUE);
        `CFG.write_register(`DXCCR, (`GRM.dxccr | 32'h0000_0004));
        `FCOV_REG.set_cov_registers_write(`DXCCR ,`GRM.dxccr,`VALUE_REGISTER_DATA);
      end

    end
    `GRM.dcutpr[7:0] = 8'hff;
    `CFG.write_register(`DCUTPR, `GRM.dcutpr);
  endtask   // phy_power_up

  // power-up
  // --------
  // executes the power-up sequence
  task power_up;
    reg [`REG_DATA_WIDTH-1:0] word;
    integer                   dx_idx;
    integer                   nop_cnt_after_rst;
    integer                   rnk_idx;
    `ifdef DWC_DDRPHY_BOARD_DELAYS   //this ifdef enables the *framework*
      integer  brd_cfg_idx, brd_cfg_idx2, brd_cfg_idx3, tempvar_brddly, flybydelay_temp ;
    `endif
    reg                       use_mpr;
    reg                       upd_dtcr;
    
    begin

      if (skip_phy_power_up != 1'b1)
        phy_power_up;
      
`ifdef SDF_ANNOTATE
       // re-enable timing checks of some flops disabled during calibration
       ->release_calib_notifiers;
 `endif
 
      // set the controller configuration
      configure_controller;

/*
      // wait for PHY initialization done
      if (disable_signal_probing) begin
        `CFG.poll_register(`PGSR0, 0, 0, 1'b1,  100, 1000000, "PHY initialization done...");
      end
      else begin
`ifndef DWC_DDRPHY_EMUL_XILINX
        wait (`PUB.init_done);
`endif
      end
*/

`ifndef DWC_DX_DM_USE
  // We need to de-assert mr5[10] to disable the DM when that is not USED
        `GRM.mr5[0][10] = 1'b0;
        //`CFG.write_register(`MR5_REG, `GRM.mr5);
        write_rank_register(`MR5_REG, `GRM.mr5[0], 0);
`endif


`ifdef DWC_DDRPHY_EMUL_XILINX
  // For write leveling use the fine delay ONLY! WLSTEP=1
      `GRM.pgcr1[2] = 1'b1;
      `CFG.write_register(`PGCR1, `GRM.pgcr1);

   // set the controller configuration -moved in the same place with NOM -!race condition for LPDDR3
//   configure_controller;

   `ifdef SDF_ANNOTATE
      // Set the PLL counter to lower value in emulation
      `GRM.ptr0[20:6]  =  96;
      `GRM.ptr1[31:15] = 128;
      `CFG.write_register(`PTR0, `GRM.ptr0);
      `CFG.write_register(`PTR1, `GRM.ptr1);
      // Set the SDRAM initialization to smaller value
      `GRM.ptr3[19: 0] =  40000;
      `GRM.ptr3[28:20] =  90;
      `GRM.ptr4[17: 0] =  40000;
      `GRM.ptr4[27:18] =  130;
      `CFG.write_register(`PTR3, `GRM.ptr3);
      `CFG.write_register(`PTR4, `GRM.ptr4);
   `endif
      // for emulation, disable all delay line calibration
      `GRM.pir[15:11] = 6'b000000;

       // Disable PHY Update Request
      `GRM.dsgcr[0] = 1'b0;
      `CFG.write_register(`DSGCR, `GRM.dsgcr);
 `endif
       
    -> e_phy_init_done;

`ifdef DDR3
      // use twlo greater than 6 for cwl>=9 or cl>=9
      if( `CAS_LAT >= 4'b1010  || `CAS_WLAT > 3'b100) begin    
        word = `GRM.dtpr4;
        if (word[11:8] < 4'h7) begin
          word[11:8] = 4'h7;
          `CFG.write_register(`DTPR4, word);
          `FCOV_REG.set_cov_registers_write(`DTPR4 ,`GRM.dtpr4,`VALUE_REGISTER_DATA);
        end
      end

      `ifndef DWC_DDRPHY_EMUL_XILINX 
        // if planning to trigger DQS gating through this power-up routine, use
        // MPR register if DDR3 mode
        // also disable the manual DQS training that happens at the end of this task
        if (`GRM.pir[10] == 1'b1) begin
          `GRM.dtcr0[6] = 1'b1;
          `CFG.write_register(`DTCR0, `GRM.dtcr0);
          `FCOV_REG.set_cov_registers_write(`DTCR0 ,`GRM.dtcr0,`VALUE_REGISTER_DATA);
        end
      `endif
      // if planning to trigger write leveling adjustment through power-up routine,
      // and if the 7 DQ bits of the most significant byte are not used, the default
      // data training data is not good enough because there is only one valid bit;
      // load in a special pattern that can be used with 1 DQ bit
      if (`GRM.pir[11] == 1'b1 && `GRM.msbyte_udq == 7) begin
        `CFG.write_register(`DTDR0, 32'h00111100);
        `CFG.write_register(`DTDR1, 32'h11000011);
      end
`endif

`ifndef DWC_DDRPHY_EMUL_XILINX 
      // Do not write default value if training is in place
      if (`GRM.pir[10] == 1'b1) begin
          train_dqs_gate_en = 1'b0;
      end
`endif

      // the longer training sequences of bit deskew or eye training were enabled
      if (`GRM.pir[15:12]) begin
        long_training = 1'b1;
      end

`ifdef DWC_DDRPHY_EMUL_XILINX
      -> e_emul_sdram_connect;
      `HOST.nops(1);
      `SYS.connect_all_sdrams;
      `HOST.nops(1);
      `SYS.enable_all_rank_monitors;
      `HOST.nops(1);
      `SYS.xilinx_emulation_setup;
`endif

      // trigger PUB SDRAM initialization and wait for it to finish
      initialize_sdram;
      
      // trigger data buffer training 
`ifdef DWC_DDR_LRDIMM
  `ifdef LRDIMM_MULTI_RANK
      `SYS.chk_dqs_gate_train_done  = 1'b0;
      `SYS.chk_write_level_adj_done = 1'b0;
      do_lrdimm_training;
      `CFG.dcu_reset;
      `GRM.dcu_was_run = 0;  //skip the dcu caches checking in end_simulation

      
  `endif
`endif

`ifdef DWC_STATIC_RD_RESPP
      `SYS.chk_dqs_gate_train_done  = 1'b0;
      `SYS.chk_write_level_adj_done = 1'b0;
      
      if (train_for_srd) begin
        dqs_gate_train(pNO_OF_LRANKS, 0);
  `ifdef DWC_RD_FIFO_BYP
        `GRM.pgcr3[24] = 1'b1; // bypass read FIFO
  `endif
        `GRM.pgcr3[4:3] = 2'b01; // programmable static read response
        `CFG.write_register(`PGCR3, `GRM.pgcr3);

        for (dx_idx = 0; dx_idx < `NO_OF_BYTES; dx_idx = dx_idx + 1) begin
          `GRM.dxngcr0[dx_idx][23:20] = `DWC_STATIC_RD_DLY;
          `CFG.write_register(`DX0GCR0 + `DX_REG_RANGE*dx_idx, `GRM.dxngcr0[dx_idx]);

	        if (`DWC_DX_NO_OF_DQS== 2'd2) begin	      
            `GRM.dxngcr7[dx_idx][23:20] = `DWC_STATIC_RD_DLY;
            `CFG.write_register(`DX0GCR0 + `DX_REG_RANGE*dx_idx, `GRM.dxngcr7[dx_idx]);
	        end
        end

        // if programming static rd read resp mode, need to verify that DQS IO's have no
        // pulldown enabled (i.e., pullup).  if not, then program the DXCCR.DQSRES register
        // to enable pullup.
        //      if(`GRM.dxccr[8] != 1'b1) begin
        //        $display("-> %0t: [SYSTEM] running in static read response mode, need to configure DQS to be pullup", $time);
        //
        //        // DQS has pulldown:
        //        //   - Program DQS to have pulldown    (DQSRES[8]==1'b1)
        //        //   - Program DQS# to have pullup (DQSRES[12]==1'b0)
        //        `GRM.dxccr[8]  = 1'b0;
        //        `GRM.dxccr[12] = 1'b1;
        //        `CFG.write_register(`DXCCR, `GRM.dxccr);
        //        `FCOV_REG.set_cov_registers_write(`DXCCR, `GRM.dxccr, `VALUE_REGISTER_DATA);
        //      end
        `SYS.static_read_train(2'b01);
      end
`else
  `ifdef DWC_RD_FIFO_BYP
      `GRM.pgcr3[24] = 1'b1;
      `CFG.write_register(`PGCR3, `GRM.pgcr3);
  `endif
`endif

`ifdef DWC_STATIC_RD_RESPC
      // if programming static rd read resp mode, need to verify that DQS IO's have no
      // pulldown enabled (i.e., pullup).  if not, then program the DXCCR.DQSRES register
      // to enable pullup.
      if(`GRM.dxccr[8] != 1'b1) begin
        $display("-> %0t: [SYSTEM] running in static read response mode, need to configure DQS to be pullup", $time);

        // DQS has pulldown:
        //   - Program DQS to have pulldown    (DQSRES[8]==1'b1)
        //   - Program DQS# to have pullup (DQSRES[12]==1'b0)
        `GRM.dxccr[8]  = 1'b0;
        `GRM.dxccr[12] = 1'b1;
        `CFG.write_register(`DXCCR, `GRM.dxccr);
        `FCOV_REG.set_cov_registers_write(`DXCCR, `GRM.dxccr, `VALUE_REGISTER_DATA);
      end

      // if static read response computed defined, set the PGCR3.RDMODE register, then write to PUB
      `GRM.pgcr3[4:3] = 2'b10;
      `CFG.write_register(`PGCR3, `GRM.pgcr3);
      `SYS.static_read_train(2'b10);
`endif

      

      
`ifndef DWC_DDRPHY_EMUL_XILINX // Emulation doesn't run LCDL calibration, GRM doesn't have to be changed
      if (!force_pvt_in_progress)
        `GRM.update_cal_values;
      else
        -> e_update_with_init_force_pvt;
      
//      fork
 `ifdef SDF_ANNOTATE
        // *** TBD: for SDF don't check yet until we figure the expected numbers
        //          based on delay line lineraity/step size
 `else
        if (check_cal_values)
          begin
            `ifdef LPDDR3
               `ifdef DWC_PLL_BYPASS
	          wait_clks = 400 * cfg2dfi_clk_ratio;
               `else
	          wait_clks = 100 * cfg2dfi_clk_ratio;
               `endif
            `else 
	          wait_clks = 100 * cfg2dfi_clk_ratio;
            `endif  
            repeat (wait_clks) @(posedge clk); // allow some time for update to finish 
            -> e_check_calibrated_values;
            `ifdef LPDDR3
               `ifdef DWC_PLL_BYPASS
	          wait_clks = 800 * cfg2dfi_clk_ratio;
               `else
	          wait_clks = 200 * cfg2dfi_clk_ratio;
               `endif
            `elsif LPDDR2
               `ifdef DWC_PLL_BYPASS
	          wait_clks = 800 * cfg2dfi_clk_ratio;
               `else
	          wait_clks = 200 * cfg2dfi_clk_ratio;
               `endif
            `else 
               `ifdef DWC_PLL_BYPASS
	          wait_clks = 250 * cfg2dfi_clk_ratio;
               `else
	          wait_clks = 200 * cfg2dfi_clk_ratio;
               `endif
            `endif 
            repeat (wait_clks) @(posedge clk); // allow some time to check initial values
          end
 `endif
`endif
       
`ifndef DWC_DDRPHY_EMUL_XILINX
    // for non-rdimm mode
    if (`DWC_RDIMM == 1'b0) begin
        // train the DQS gating
        if (wr_dqs_gate_default) begin   
          if (train_dqs_gate_en) begin 
            train_dqs_gate(`FALSE); // write specific delay, not random
            -> e_dqs_gate_training_done;
          end
        end else begin
          auto_train_dqs_gate;    // automatic train read dqs per rank and byte lane
          -> e_dqs_gate_training_done;
        end
    end 
    else begin
    `ifndef LRDIMM_MULTI_RANK
      if (rdimm_auto_train_en ) begin
        // write some specific system latency values before training.
        train_dqs_gate(`FALSE); 

        // do not check LCDLR0 or LCDLR2 values for RDIMM; cannot predict what values are inserted
        // by the model
        `SYS.chk_dqs_gate_train_done  = 1'b0;
        `SYS.chk_write_level_adj_done = 1'b0;
        
        // RDIMM training
        rdimm_training;
      end
    `endif
    end
`endif
      
      // report SDRAM configuration
      report_sdram_configuration;
      
      // report Address/Command Pin Mapping
      report_add_cmd_pin_mapping;

     // this wait is for the erroneous refresh check in the SDRAM model;
      // (shouldn't check refresh before any write)
      repeat (5) @(posedge clk); // separation from last mode register
      init_done = 1'b1; // initialization is done

`ifdef SDF_ANNOTATE
      // re_enable timing checks of some flops disabled during training
      ->release_train_notifiers;
`endif

      // Enable ODT monitor
      // *** TBD: for mixed even/odd command, the ddr_mctl may not drive the ODT
      //          very accuartely - so disable it
`ifdef MSD_RND_HDR_ODD_CMD
`ifdef DDR3
      // disable the ODTH{4,8} checks since the ddr_mctl may not drive the ODT accurately
      disable_odth_timing_checks;
`endif
`else
      if (!rank_disconnected) enable_all_odt_monitors;
`endif
      repeat (`GRM.t_rfc) @(posedge clk);


`ifdef DWC_LOOP_BACK    
  // train read gate
  `ifndef DWC_DDRPHY_EMUL_XILINX

    if (train_for_loopback) begin  
    `ifndef LPDDRX
        `GRM.pir[10] = 1'b1;   // Read DQS gate training for non LPDDR mode
    `else
      `ifdef LPDDR3
        // random case for gate training.
        `SYS.lpddr3_term_type = {$random(`SYS.seed)} % 3;
        
        case(`SYS.lpddr3_term_type)
          2: // VDD term wihtout PU/PD
            begin
              `SYS.lpddr3_term_type = `LPDDR3_TERM;
              `GRM.pir[10] = 1'b1;   // Perform Read DQS gate training for LPDDR3 mode
              $display("-> %0t: [SYSTEM]  gate training for LPDDR3 TERM type without PU/PD ", $time);
            end
          default: begin
            `GRM.pir[10] = 1'b1;   // Read DQS gate training for LPDDR3 mode; default to NO TERM type
            `SYS.lpddr3_term_type = `LPDDR3_NO_TERM;
          end
          
        endcase // case(lpddr3_term_type)

      `else
        // Do not turn on gate train for LPDDR2 mode...  
      `endif
    `endif
        
    `ifdef DDR4
        use_mpr = 1'b1;
    `else
      `ifdef DDR3
        use_mpr = 1'b1;
      `else
        `ifdef LPDDR3
        use_mpr = 1'b1; // In LPDDR3 use the MRR pattern A (from register address 32)
        `else
        use_mpr = 1'b0; // DDR2 doesn't have MPR
        `endif
      `endif
    `endif  

        // configure DQS gate training
        if (`GRM.dtcr0[6] != use_mpr) begin
          `GRM.dtcr0[6] = use_mpr;
          upd_dtcr = 1;
        end
        
        // Enables refreshes by default through setting refresh repeat value
        if (`GRM.dtcr0[31:28] == 0) begin
          `GRM.dtcr0[31:28] = 1;  // Ensure it's never 0 to avoid tRFC timing violations
          upd_dtcr = 1;
        end
        

    `ifdef DWC_BUBBLES
        // When jitter is enabled, multiple reads are required for stable results
        if (`GRM.dtcr0[3:0] < 6) begin  // Pick 6 reads - this should work in all cases...
          `GRM.dtcr0[3:0] = 6;
          upd_dtcr = 1;
        end
    `endif

        // Write out the DTCR0 register, iff it has been updated
        if (upd_dtcr) begin
          `CFG.write_register(`DTCR0, `GRM.dtcr0);
        end

        if (use_mpr && `GRM.lpddrx_mode) begin
          $display("-> %0t: [SYSTEM] disable read-leveling as gate training can only run with gate extended only ", $time);
          `GRM.dtcr1[1] = 1'b0;
          `CFG.write_register(`DTCR1, `GRM.dtcr1);
        end  

        // trigger training now for loopback
        `GRM.pir[0] = 1'b1;
        `CFG.write_register(`PIR, `GRM.pir);
        repeat (100) @(posedge `PUB.cfg_clk);
        
        // Poll train state done
        `CFG.poll_register(`PGSR0, 0, 0, 1'b1,  1000, 1500000, "PUB initialization done...");
        init = 1'b1;
      end
      
  `endif //DWC_DDRPHY_EMUL_XILINX
`endif //  `ifdef DWC_LOOP_BACK
      
       

      // if loop back is selected, enable it now; make sure the enable is
      // is synchronous to CK
`ifdef DWC_LOOP_BACK
      @(negedge `RANK0.ck);
      `SYS.enable_loopback(`GRM.pgcr1[27], `GRM.pgcr1[28], `GRM.pgcr1[30:29]);
`endif

      // when using Tetramax models, there will be no 90 degress delay
      // on DQS - insert it artifically in the board delay model
`ifdef DWC_DDRPHY_ATPG_MODEL
  `ifdef DWC_DDRPHY_BOARD_DELAYS
    for(brd_cfg_idx=0;brd_cfg_idx<pNO_OF_LRANKS;brd_cfg_idx=brd_cfg_idx+1) begin
      for(brd_cfg_idx2=0;brd_cfg_idx2<`DWC_NO_OF_BYTES;brd_cfg_idx2=brd_cfg_idx2+1) begin
        `TB.u_ddr_board_cfg.config_delay("dqs",0,brd_cfg_idx,0,brd_cfg_idx2,(1000*`SDRAM_CK_PRD/4));  
        `TB.u_ddr_board_cfg.config_delay("dqsn",0,brd_cfg_idx,0,brd_cfg_idx2,(1000*`SDRAM_CK_PRD/4));     
      end
    end  
    `TB.u_ddr_board_cfg.set_board_cfg ;
  `else
      rank_cfg_sel    = pRANK_QS_DLY;
      rank_cfg_val[0] = 0;
      rank_cfg_val[1] = (1000*`SDRAM_CK_PRD/4);
      -> e_configure_rank;
      #0.0001;
  `endif
`endif

      // enable the generation of bubbles on the read data valid by the PHY
  `ifdef DWC_DDRPHY_BOARD_DELAYS      
    `ifdef DWC_BUBBLES
        // Create bubbles only when the SDRAM is connected up
        if (!rank_disconnected) begin
          if (!disable_bubbles) begin 
            if (!bubbles_created) begin 
              create_bubbles;
              print_table("DQS_DOUT_DLY",  " DQS OUT delay (ps)");
              print_table("DQS_DIN_DLY",   " DQS IN  delay (ps)");
              print_table("DQSN_DOUT_DLY", " DQSN OUT delay (ps)");
              print_table("DQSN_DIN_DLY",  " DQSN IN  delay (ps)");
              print_table("DM_DOUT_DLY",   " DM OUT delay (ps)");
              print_table("DM_DIN_DLY",    " DM IN  delay (ps)");
              print_table("DQ_DIN_DLY",    " DQ IN  delay (ps)");
              print_table("DQ_DOUT_DLY",   " DQ OUT  delay (ps)");
              $display(""); //Temporary Commented Miguel O
            end
          end
        end
    `endif
  `endif

      // send a refereh at the end of training if the longer training
      // sequences of bit deskew or eye training were enabled
      if (long_training) begin
       `SYS.precharge_all(`ALL_RANKS);
       `SYS.refresh(`ALL_RANKS);
       `SYS.nops(`GRM.t_rfc);
      end
      
     `ifdef DWC_SDRAM_DLL_BYPASS
        `SYS.disable_clock_checks;
        `SYS.disable_refresh_check;
      `else 
        `SYS.enable_clock_checks;
      `endif

      `ifdef DWC_DDRPHY_EMUL_XILINX   
        // In case if wl/dqs train is not performed inside sdram init, 
        // the training will be trigger here
        if(tc_trigger_dqs_wl_train==1'b0 && skip_init_sdram_in_power_up==0) begin
          if(need_data_train)begin
            if(`GRM.dtcr0[20]==1 && `GRM.dtcr0[21]==1) begin
              `HOST.nops(1);
              disable_all_rank_monitors;
              `HOST.nops(1);
              disable_dq_setup_hold_checks;
              `HOST.nops(1);
              disable_undefined_warning;
              `HOST.nops(1);
              disable_dqs_ck_setup_hold_checks;
              `HOST.nops(1);
              disable_dq_pulse_width_checks;
              `HOST.nops(1);
              `ifdef DDR3
                disable_dqs_latch_timing_checks;
                `HOST.nops(1);
              `endif
              // Stage 1
              $display("\n\n=> Triggering DQS gate training in PSTA...\n");
              `SYS.dqs_gate_train(pNO_OF_LRANKS, 0);
              // Stage 3
              `GRM.dtcr0[20] = 0;  // debug
              `GRM.dtcr0[21] = 0;  // stage
              `CFG.write_register(`DTCR0, `GRM.dtcr0); 
              `HOST.nops(1);
              enable_all_rank_monitors;
              `HOST.nops(1);
              enable_dq_setup_hold_checks;
              `HOST.nops(1);
              enable_undefined_warning;
              `HOST.nops(1);
              enable_dqs_ck_setup_hold_checks;
              `HOST.nops(1);
              enable_dq_pulse_width_checks;
              `HOST.nops(1);
              `ifdef DDR3
                enable_dqs_latch_timing_checks;
                `HOST.nops(1);
              `endif
            end else begin
              `ifdef OVRD_TDQSCK
                disable_undefined_warning;
                `HOST.nops(1);
              `endif 
              `ifdef MICRON_DDR
                `ifdef DDR4
                  // TBD: ddr4 in micron's monitor need to be fixed
                  disable_undefined_warning;
                  `HOST.nops(1);
                `endif
              `endif
              $display("\n\n=> Triggering DQS gate training ...\n");
              `SYS.dqs_gate_train(pNO_OF_LRANKS, 0);
            end
          end else begin
            if(dqs_train_in_sdram_init)begin
              dqs_train_in_sdram_init = 1'b0;
            end else begin
              `ifdef DWC_DDRPHY_EMUL_CFGFILE // run with config file (-cfgfile)
                `ifndef DWC_DDRPHY_BOARD_DELAYS
                  `SYS.error;
                  $display("-> %0t: ==> ERROR: Please trigger Data Training when running with configuration file.", $realtime);
                `endif
              `else
                $display("\n\n=> Load pre-default value for DQS gate training ...\n");
                `SYS.load_dqs_gate_DT_val_emul();
              `endif
            end
          end
        end
        `ifdef MICRON_DDR
          `ifdef DDR4
            // TBD: ddr4 in micron's monitor need to be fixed
            disable_undefined_warning;
            `HOST.nops(1);
          `endif
        `endif
        `ifdef DWC_SDRAM_DLL_BYPASS
          `SYS.enable_clock_checks;
          `SYS.enable_refresh_check;
        `endif
        `SYS.precharge_all(`ALL_RANKS);
        `SYS.refresh(`ALL_RANKS);
        `SYS.nops(`GRM.t_rfc);
      `endif //  `ifdef DWC_DDRPHY_EMUL_XILINX


    end
  endtask // power_up

  
  // PHY init bypass
  // ---------------
  task cfg_phy_init_byp;
    input                     bypass;
    reg [`REG_DATA_WIDTH-1:0] word;
    begin
      // take only bit pir[8:0]
      word     = {{16{1'b0}}, `GRM.pir[15:0]};
      word[31] = bypass;
      
      @(posedge `CFG.clk);
      `CFG.write_register(`PIR, word);
      //Functional coverage   
      `FCOV_REG.set_cov_registers_write(`PIR, word ,`VALUE_REGISTER_DATA);
    end
  endtask // cfg_phy_init_byp

  
  // PHY CAL bypass
  // --------------
  task cfg_phy_cal_byp;
    input                     bypass;
    reg [`REG_DATA_WIDTH-1:0] word;
    begin
      //`CFG.read_register_data(`PIR, word);
      word = `GRM.pir;
      word[29] = bypass;
      
      @(posedge `CFG.clk);
      `CFG.write_register(`PIR, word);
      `FCOV_REG.set_cov_registers_write(`PIR, word ,`VALUE_REGISTER_DATA);      
    end
  endtask // cfg_phy_cal_byp
  
 
  // PHY PLL bypass
  // --------------
  task cfg_phy_pll_byp;
    input                     bypass;
    reg [`REG_DATA_WIDTH-1:0] word;
    begin
      if (bypass) begin
        // Assert bypass randomly thru PLLCR or PIR
        if ($random) begin
          // bypass thru PLLCR
          `CFG.read_register_data(`PLLCR, word);
          `ifndef DWC_DDRPHY_EMUL_XILINX
            word[31] = bypass;
          `endif
        
          @(posedge `CFG.clk);
          `CFG.write_register(`PLLCR, word);
          `FCOV_REG.set_cov_registers_write(`PLLCR, word ,`VALUE_REGISTER_DATA);
        end
        else begin
          // or bypass thru pir.pllbyp
          `CFG.read_register_data(`PIR, word);
          word[17] = bypass;
        
          @(posedge `CFG.clk);
          `CFG.write_register(`PIR, word);
          `FCOV_REG.set_cov_registers_write(`PIR, word ,`VALUE_REGISTER_DATA);
        end
      end
      else begin
        // clear both PLLCR.byp and PIR.pllbyp
          `CFG.read_register_data(`PLLCR, word);
          word[31] = bypass;
        
          @(posedge `CFG.clk);
          `CFG.write_register(`PLLCR, word);
          `FCOV_REG.set_cov_registers_write(`PLLCR, word ,`VALUE_REGISTER_DATA);
        
          `CFG.read_register_data(`PIR, word);
          word[17] = bypass;
        
          @(posedge `CFG.clk);
          `CFG.write_register(`PIR, word);
          `FCOV_REG.set_cov_registers_write(`PIR, word ,`VALUE_REGISTER_DATA);
      end
    end
  endtask // cfg_phy_pll_byp

  
  // Clear status registers
  // ----------------------
  // clears (resets to zero) the PUB status registers
  task clear_status_registers;
    reg [`REG_DATA_WIDTH-1:0] word;
    begin
      word = `GRM.pir;
       word[27] = 1'b1;
       `CFG.write_register(`PIR, word);

       // wait for the command to take effect due to some internal synchronization
       // to the high speed clock domain
       `CFG.nops(4);
    end
  endtask // clear_status_registers

   
  // controller configuration
  // ------------------------
  // executes writes to the controller registers to set the controller and/or
  // SDRAM configuration
  task configure_controller;
    reg [`REG_DATA_WIDTH-1:0] word;
    integer                   i, j;
    reg [`tMRD_WIDTH-1:0]     tMRD;
    reg [`tRTP_WIDTH-1:0]     tRTP;
    reg [`tWTR_WIDTH-1:0]     tWTR;
    reg [`tRP_WIDTH-1:0]      tRP;
    reg [`tRCD_WIDTH-1:0]     tRCD;
    reg [`tRRD_WIDTH-1:0]     tRRD;
    reg [`tRC_WIDTH-1:0]      tRC;
    reg [`tFAW_WIDTH-1:0]     tFAW;
    reg [`tMOD_WIDTH-1:0]     tMOD;
    reg                       tRTODT;
    reg [`tRAS_WIDTH-1:0]     tRAS;
    reg [`tRFC_WIDTH-1:0]     tRFC_min;
    reg [`tRFPRD_WIDTH-1:0]   tRFC_max_reg;
    reg [`tXS_WIDTH-1:0]      tXS;
    reg [`tXP_WIDTH-1:0]      tXP;
    reg [`tCKE_WIDTH-1:0]     tCKE;
    reg [`tDLLK_WIDTH-1:0]    tDLLK;
    reg [`tDQSCK_WIDTH-1:0]   tDQSCK;
    reg [`tDQSCK_WIDTH-1:0]   tDQSCKMAX;
    reg [`tDQSCK_WIDTH-1:0]   tDQSCKVAR;
    reg [`tWLMRD_WIDTH-1:0]   tWLMRD;
    reg [`tWLO_WIDTH-1:0]     tWLO;
    reg [`tCCD_L_WIDTH-1:0]   tCCD_L;

    reg [`REG_DATA_WIDTH-1:0] reg_data;
    reg [`REG_ADDR_WIDTH-1:0] reg_addr;
    integer rank_id;
    
    
    begin
      powering_up = 1'b1;

      // set the SDRAM configuration
      word        = `DCR_DEFAULT;

`ifdef LPDDR3        
      if (lpddr3_term_type==`LPDDR3_TERM) begin
        word[2:0]   = `DDR_MODE;
        word[9:8]   = 2'b00;
      end
      else begin          
        word[2:0]   = `DDR_MODE;
      end
`elsif LPDDR2
        word[9:8]   = (`LPDDR2_SX == 2) ? 2'b01 : 2'b00;
      word[2:0]   = `DDR_MODE;

`else
      word[2:0]   = `DDR_MODE;
`endif  
      
`ifdef  DWC_DDRPHY_X4MODE 
      word[17:14] = 4'b1;  // allow upper nibble to be gate trained in x4 mode
`endif   

      // number of banks can be 4 or 8 for these sdram config
`ifdef DDR2_256Mbx8      
      word[3]     = $random%2;
`elsif DDR2_256Mbx16      
        word[3]     = $random%2;
`elsif DDR2_512Mbx8      
        word[3]     = $random%2;
`elsif DDR2_512Mbx16      
        word[3]     = $random%2;
`endif

      word[27]    = `DWC_NO_SRA;
      word[28]    = `DWC_2T_MODE;
      word[29]    = `DWC_UDIMM;
      
`ifdef DWC_UDIMM
      if (`DWC_UDIMM == 1 ) begin
  `ifdef SDRAMx16
        word[30]    = 1'b1; // ubg to indicate that BG[1] is unused
  `endif
      end
      else
        word[30]    = 1'b0; // ubg to indicate that BG[1] is used
`endif
      
`ifdef  DWC_DDRPHY_X4MODE 
      word[17:14] = 4'b1;  // allow upper nibble to be gate trained in x4 mode
`endif        
     
      if (word !== `DCR_DEFAULT) 
        `CFG.write_register(`DCR, word);

      // sample DCR
      `FCOV_REG.set_cov_registers_write(`DCR, word,`VALUE_REGISTER_DATA);           
      `FCOV_REG.set_cov_mpr_scenario;
      
      //Sreejith Made the update... Need to add logic to make sure that this meets specification.
      //Currently Writing 11 value so as to make it work in all the cases.
      //`ifdef LPDDR3
      //     word        = `DSGCR_DEFAULT;
      //     word[7:6]   =  2'b11;
      //     `CFG.write_register(`DSGCR, word); 
      //`endif
      //
      //`ifdef LPDDR2
      //     word        = `DSGCR_DEFAULT;
      //     word[7:6]   =  2'b10;
      //     `CFG.write_register(`DSGCR, word); 
      //`endif

      word        = `CDCR_DEFAULT;
      word[5:0]   = `SDRAM_CFG;
      word[8:6]   = `DWC_NO_OF_BYTES-1;
      word[11:10] = `DWC_NO_OF_RANKS-1;
      if (word !== `CDCR_DEFAULT) `GRM.write_controller_register(`CDCR, word);

      // set mode register MR0 (MR0)
      word       = `MR0_DEFAULT;
`ifdef DDR3
      word[1:0]  = `BURST_LEN;
      {word[6:4], word[2]} = `CAS_LAT;
`endif
`ifdef DDR4   // ????
      word[1:0]  = `BURST_LEN;
      {word[6:4], word[2]} = `CAS_LAT;
`endif
`ifdef DDR2
      word[2:0]  = `BURST_LEN;
      word[6:4]  = `CAS_LAT;
`endif
      word[11:9] = `tWR;
      if (word !== `MR0_DEFAULT)
        `CFG.write_register(`MR0_REG, word);

      // sample MR0
      `FCOV_REG.set_cov_registers_write(`MR0_REG,word,`VALUE_REGISTER_DATA);           
      
      // set mode register MR1 (MR1)
      word       = `MR1_DEFAULT;
      
`ifdef DWC_SDRAM_DLL_BYPASS
      if(dram_init_type==`PUB_DRAM_INIT) begin
  `ifdef DDR4_DBYP
        word[0]= 1'b0;
  `else
        word[0]= 1'b1;
  `endif
      end
`else 
  `ifdef DDR4
      word[0]    = 1'b1; // DLL enable is active high for DDR4
  `endif
`endif

          
`ifdef DDR3
      word[4:3]  = `ADD_LAT;
      {word[9], word[6], word[2]} = `ODT_RTT;

           
  `ifdef MICRON_DDR
      // Micron DDR3 only allows output drive strength setting of 2'b01
      {word[5], word[1]} = 2'b01;
          
  `endif
`endif
      
`ifdef DDR4
  `ifndef x16 //AL not supported on x16 devices
      word[4:3]  = `ADD_LAT;
  `endif
      word[10:8] = `ODT_RTT;
`endif
      
`ifdef DDR2
      word[5:3]  = `ADD_LAT;
      {word[6], word[2]} = `ODT_RTT;
`endif

`ifdef LPDDR2
      word[2:0] = `BURST_LEN;
      word[3]   = 1'b0; // BT
      word[4]   = 1'b0; // WC
      word[7:5] = `tWR;
`endif

`ifdef LPDDR3
      word[2:0] = `BURST_LEN;
      word[3]   = 1'b0; //Reserved  
      word[4]   = 1'b0; //Reserved
      word[7:5] = `tWR;
`endif
      
      if (word !== `MR1_DEFAULT) begin
        //`CFG.write_register(`MR1_REG, word);      
        write_rank_register(`MR1_REG, word, 0);
      end
      // sample MR1   
      `FCOV_REG.set_cov_registers_write(`MR1_REG,word,`VALUE_REGISTER_DATA);           
      
      // set mode register MR2 (EMR2)
      word       = `MR2_DEFAULT;
`ifdef DDR3
      word[5:3]  = `CAS_WLAT;
`endif
`ifdef DDR4
      word[12]   = `DWC_WRCRC;
      word[5:3]  = `CAS_WLAT;
`endif
`ifdef LPDDR2
      word[3:0]  = `CAS_LAT;
      word[7:4]  = 4'b0000;
`endif
`ifdef LPDDR3
      word[3:0]  = `CAS_LAT;
      word[5]    = 1'b0;
      word[7]    = 1'b0; //Wr Level disabled
      word[4]    = `nWRE; //nWRE
  `ifdef LPDDR3_SET_A_LAT
      word[6]    = 1'b0; 
  `elsif LPDDR3_SET_B_LAT
        word[6]    = 1'b1; 
  `endif
`endif

      if (word !== `MR2_DEFAULT)
        //`CFG.write_register(`MR2_REG, word); 
        write_rank_register(`MR2_REG, word, 0);
      // sample MR2
      `FCOV_REG.set_cov_registers_write(`MR2_REG,word,`VALUE_REGISTER_DATA);           
      
      // set mode register MR3 (EMR3)
      word       = `MR3_DEFAULT;
`ifdef LPDDR2
      word[3:0]  = 4'b0010; // 40 Ohm drive strength
      word[7:4]  = 4'b0000;
`endif
`ifdef LPDDR3
      word[3:0]  = 4'b0010; // 40 Ohm drive strength
      word[7:4]  = 4'b0000;
`endif
      if (word !== `MR3_DEFAULT)
        //  `CFG.write_register(`MR3_REG, word);
        write_rank_register(`MR3_REG, word, 0);

      // sample MR3      
      `FCOV_REG.set_cov_registers_write(`MR3_REG,word,`VALUE_REGISTER_DATA);           
 
`ifdef DDR4
      
      word = `MR6_DEFAULT;
      tCCD_L = `tCCD_L;
      word[12:10] = tCCD_L;

      if (word != `MR6_DEFAULT)
        //`CFG.write_register(`MR6_REG, word);
        write_rank_register(`MR6_REG, word, 0);

      `FCOV_REG.set_cov_registers_write(`MR6_REG, word, `VALUE_REGISTER_DATA);           

      word = `MR5_DEFAULT;

      word[2:0] = `DWC_CA_PARITY_MODE; // CA Parity
  `ifdef SDRAMx4
      word[10] = 1'b0;  // Data Mask disable; not supported in x4 
  `else
      word[10] = 1'b1;  // Data Mask enable, by default
  `endif

  `ifdef DWC_WDBI_DDR4
      word[10] = 1'b0;  // Data Mask disable, iff WDBI enabled
      word[11] = 1'b1;  // Write DBI enable
  `else
      word[11] = 1'b0;  // Write DBI disable
  `endif

  `ifdef DWC_RDBI_DDR4
      word[10] = 1'b0;  // Data Mask disable, iff RDBI enabled
      word[12] = 1'b1;  // Read DBI enable
  `else
      word[12] = 1'b0;  // Read DBI disable
  `endif
      if (word != `MR5_DEFAULT)
        //`CFG.write_register(`MR5_REG, word);
        write_rank_register(`MR5_REG, word, 0);

      `FCOV_REG.set_cov_registers_write(`MR5_REG, word, `VALUE_REGISTER_DATA);           
`endif

`ifdef DWC_WDBI_DDR4
      `GRM.pgcr3[25] = 1'b1; //Write Data Bus Inversion Enable
      `CFG.write_register(`PGCR3, `GRM.pgcr3);
`endif
`ifdef DWC_RDBI_DDR4
      `GRM.pgcr3[26] = 1'b1;//Read Data Bus Inversion Enable
      `CFG.write_register(`PGCR3, `GRM.pgcr3);
`endif

      // program the timing parameters
      // NOTE: minimum AL = tRCD-1
      tMRD      = `tMRD;
      tRTP      = `tRTP;
      tWTR      = `tWTR;
      tRP       = `tRP;
      tRCD      = (`ADD_LAT_VAL < `tRCD) ? `tRCD : `ADD_LAT_VAL + 1;
      tRRD      = `tRRD;
      tRC       = `tRC;
      tFAW      = `tFAW;
      tMOD      = `tMOD;
      tRTODT    = `tRTODT;
      tRAS      = `tRAS;
      tRFC_min  = `tRFC_min;
      tRFC_max_reg  = `tRFC_max;
      tXS       = `tXS;
      tXP       = `tXP;
      tCKE      = `tCKE;
      tDLLK     = `tDLLK;
      tWLMRD    = `tWLMRD;
      tDQSCK    = `tDQSCK;
      tDQSCKMAX = `tDQSCKMAX;
      tDQSCKVAR = `tDQSCKVAR;
      tWLO      = `tWLO;

      // set timing parameters in DTPR0
      word = 32'd0;
      word[3:0]   =  tRTP;
      word[12:8]  =  tRP;
      word[21:16] =  tRAS;
      word[27:24] =  tRRD;
      if (word !== `DTPR0_DEFAULT)
        `CFG.write_register(`DTPR0, word);
      // sample DTPR0
      `FCOV_REG.set_cov_registers_write(`DTPR0,word,`VALUE_REGISTER_DATA);           
      
      // set timing parameters in DTPR1
      word        = 0;
      word[4:0]   = tMRD;
      word[10:8]  = tMOD;
      word[21:16] = tFAW;
      word[29:24] = tWLMRD;
      if (word !== `DTPR1_DEFAULT)
        `CFG.write_register(`DTPR1, word);
      // sample DTPR1
      `FCOV_REG.set_cov_registers_write(`DTPR1,word,`VALUE_REGISTER_DATA);           

      
      // set parameters in PGCR0
      word     = `PGCR0_DEFAULT;
      word[31] = `DWC_ADDR_COPY;
      if (word !== `PGCR0_DEFAULT) `CFG.write_register(`PGCR0, word);

      // Default CA1byte0 and byte 1 is at 4 and 5,
      // change that to use 2 and 3 instead.
      // If `DWC_NO_OF_BYTES more than or equal 6, can use default.
      if (`DWC_ADDR_COPY==1 && `DWC_NO_OF_BYTES<6) begin
        `GRM.catr0[7:0] = 8'h32;  // ca1byte0 = 2 and ca0byte1 = 3
        `CFG.write_register(`CATR0, `GRM.catr0);
      end


`ifdef DWC_SERIAL_DDL_CAL         
      // reduce PGCR1 filter depth to be 2'b00 (depth of 2), long dl calib cause tRFC_max
      // violation  
      if (shorten_ddl_cal) begin
        `GRM.pgcr1[14:13] = 2'b00;
        `CFG.write_register(`PGCR1, `GRM.pgcr1);
      end
`endif
      
      // For LPDDRx protocols, do not divide down the tRFC_max as it may cause the PHY
      // to issue REFAB commands too frequently, thus violating tREFBW.
`ifndef LPDDR2
  `ifndef LPDDR3
      // Set timing parameters in PGCR2
      // NEW: add bias to tRFC_max to generate more frequent refresh; pick either tRFC_max
      //      as described above or with tRFC_max divide by 2, 4, 8, 16 only... tRFC_max - 600
      //      is still very tight in some speed grade.
      mod_factor = 3;

      j = {$random} % mod_factor;
      
      case (j)
        1: tRFC_max_reg = tRFC_max/4;
        2: tRFC_max_reg = tRFC_max/8;
        3: tRFC_max_reg = tRFC_max/16;
        4: tRFC_max_reg = tRFC_max/24;
        5: tRFC_max_reg = tRFC_max/32;
        //default: tRFC_max_reg = tRFC_max -600; 
        default: tRFC_max_reg = tRFC_max/2; 
      endcase // case(j)

      if (verbose > 9) $display("SYSTEM: j             = %0d", j);
      if (verbose > 9) $display("SYSTEM: tRFC_max_reg  = %0h", tRFC_max_reg);
  `endif
`endif
      
      word        = `PGCR2_DEFAULT;
      word[17:0]  = tRFC_max_reg;
      word[19]    = `DWC_FIXED_LAT;

      // disable pub's own refresh; snoops DFI bus for controller's request for refresh
      if (disable_pub_own_rfsh_mode)
        word[30:29] = 2'b01;
      
      if (word !== `PGCR2_DEFAULT)
        `CFG.write_register(`PGCR2, word);
      // sample PGCR2
      `FCOV_REG.set_cov_registers_write(`PGCR2,word,`VALUE_REGISTER_DATA);  

      // set parameters in PGCR3
      word = `PGCR3_DEFAULT;
      //`ifdef DWC_STATIC_RD_RESPP
      //word[4] = 1'b1;
      //`endif
`ifdef DDR4
  `ifdef DWC_RDBI_PHY
      word[26]  = 1'b1;
  `endif
  `ifdef DWC_WDBI_PHY
      word[25]  = 1'b1;
  `endif
`endif

`ifdef DWC_DFI_TRAINREQ
      word[27]  = 1'b1;
`endif
      if (word !== `PGCR3_DEFAULT) `CFG.write_register(`PGCR3, word);

      // set parameters in DXCCR
      word        = `GRM.dxccr;
      word[17:15] = `DWC_MSBYTE_NDQ;

`ifdef LPDDR2
      // enable the pull-down/pull-up resistors for LPDDR2
      word[8:5]  = 4'b0100;
      word[12:9] = 4'b1100;
`endif
      
`ifdef LPDDR3 //DDRG2MPHY: Is there anything different than LPDDR2
      // enable the pull-down/pull-up resistors for LPDDR3
      if (lpddr3_term_type==`LPDDR3_TERM) begin
        word[8:5]  = 4'b0000;
        word[12:9] = 4'b0000;
      end
      else begin
        word[8:5]  = 4'b0100;
        word[12:9] = 4'b1100;
      end
      
`endif

`ifdef DWC_DDRPHY_X4MODE
      word[31]   = 1'b1;
`endif

`ifdef DWC_DDRPHY_DMDQS_MUX
  `ifdef SDRAMx4
      word[30]   = 1'b0; // DM is not available in x4
  `else
      word[30]   = 1'b1; // DM muxed onto DQS for x8 and x16
 `endif
`else
      word[30]   = 1'b0; // DM is not muxed onto DQS
`endif

      if (word !== `GRM.dxccr) `CFG.write_register(`DXCCR, word);
      
      word     = `DSGCR_DEFAULT;
`ifndef DWC_DDRPHY_EMUL_XILINX   
      // Emulation models cannot widen the gate!
  `ifdef LPDDR2
      if (`CLK_PRD >= 2.5)    
        word[7:6]  = 2'b10; 
      else
        word[7:6]  = 2'b11; 
  `endif

  `ifdef LPDDR3
      if (lpddr3_term_type==`LPDDR3_TERM) begin
        word[7:6]  = 2'b00; 
      end
      else begin
        if (`CLK_PRD >= 2.5)    
          word[7:6]  = 2'b10; 
        else
          word[7:6]  = 2'b11;
      end
      
  `endif
`endif

      //`ifdef DDR2
      //    word[7:6]  = 2'b01;
      //`endif
      //
      //`ifdef DDR3
      //    word[7:6]  = 2'b01;
      //`endif


      word[20:19] = `DWC_DDRPHY_SDR_MODE;
`ifdef DWC_DDRPHY_RR_MODE
      word[18] = 1'b1;
      word[22] = 1'b1;
`else
      word[18] = 1'b0;
      word[22] = 1'b0;
`endif
      
      if (word !== `DSGCR_DEFAULT)begin
        `CFG.write_register(`DSGCR, word);
      end
      // sample DSGCR
      `FCOV_REG.set_cov_registers_write(`DSGCR,word,`VALUE_REGISTER_DATA);
      
      // set timing parameters in DTPR2
      word        = 0;
      word[9:0]   = tXS;
      word[19:16] = tCKE;
      word[24]    = tRTODT;
      word[28]    = 1'b0;
      if (word !== `DTPR2_DEFAULT)
        `CFG.write_register(`DTPR2, word);
      // sample DTPR2
      `FCOV_REG.set_cov_registers_write(`DTPR2,word,`VALUE_REGISTER_DATA);           

      // set timing parameters in DTPR3
      word        = 0;
      word[2:0]   = tDQSCK;
      word[10:8]  = tDQSCKMAX;
      word[25:16] = tDLLK;
      word[28:26] = 3'b0; 
      word[31:29] = 3'b0; 
      if (word !== `DTPR3_DEFAULT)
        `CFG.write_register(`DTPR3, word);
      // sample DTPR3
      `FCOV_REG.set_cov_registers_write(`DTPR3,word,`VALUE_REGISTER_DATA);           

      // set timing parameters in DTPR4
      word        = 0;
      word[4:0]   = tXP;
      word[11:8]  = tWLO;
      word[25:16] = tRFC_min;
      word[29:28] = 2'b00; 
      if (word !== `DTPR4_DEFAULT)
        `CFG.write_register(`DTPR4, word);
      // sample DTPR4
      `FCOV_REG.set_cov_registers_write(`DTPR4,word,`VALUE_REGISTER_DATA);           

      // set timing parameters in DTPR5
      word        = 0;
      word[4:0]   = tWTR;
      word[12:8]  = tRCD;
      word[22:16] = tRC;

      if (word !== `DTPR5_DEFAULT)
        `CFG.write_register(`DTPR5, word);
      // sample DTPR5
      `FCOV_REG.set_cov_registers_write(`DTPR5,word,`VALUE_REGISTER_DATA);           

      // set refresh timing parameters in DRR
      word       = `DRR_DEFAULT;
`ifdef DWC_DDRPHY_EMUL_XILINX
      word[17:0] = `tRFC_max - 200;
`else 
      word[17:0] = tRFC_max_reg - 200;
`endif
      if (word !== `DRR_DEFAULT) `GRM.write_controller_register(`DRR, word);

`ifdef DWC_DX_DM_USE
`else
      // Some systems may not have DM, disable the data mask bit training
      `GRM.dtcr0[12] = 1'b0;
`endif

`ifdef DWC_DDRPHY_DMDQS_MUX
      `GRM.dtcr0[12] = 1'b0;
`endif

`ifdef DDR4
  `ifdef SDRAMx4
      // DDR4 in x4 mode does not support DM, disable the data mask bit training
      // issue with write data eye training on dm
      `GRM.dtcr0[12] = 1'b0;
  `endif        
`endif      

      `GRM.dtcr0[31:28] = 4'h1; // limit the number of refresh per training , DDR4 has
      // check on refresh to make sure that there cant be
      // more than 9 refresh within tREFI
      `CFG.write_register(`DTCR0, `GRM.dtcr0);

`ifdef RDIMM_SINGLE_RANK
  `ifdef RDIMM_DUAL_RANK 
      // For RDIMM_SINGLE_RANK, there is only 1 rank per DIMM.
      // to setup for 1 rank  only, use runtc option ranks=2 and turn on RANKEN only for the even rank; one DIMM device
      // to setup for 2 ranks only, use runtc option ranks=4 and turn on RANKEN only for the even rank; two DIMM device
      for (i=0; i<`DWC_NO_OF_LRANKS; i=i+1) begin
        // disable the odd ones
        if (i%2)
          `GRM.dtcr1 [16+i] = 1'b0;
      end
      `CFG.write_register(`DTCR1, `GRM.dtcr1);
  `endif
`endif        

`ifdef RDIMM_DUAL_RANK 
      // if run dualcs in a rdimm_quad_rank (DWC_RCD_MODE==2 or 3)
      // only 2 ranks is available as there are 4 CS_N but 2 ODT and 2 CKE available per dimm
      // Hence, disable the upper two ranks in DTCR1
      if (`DWC_RCD_MODE >= 2) begin
        for (i=0; i<`DWC_NO_OF_LRANKS; i=i+1) begin
          if (i%4 >= 2)
            `GRM.dtcr1 [16+i] = 1'b0;
        end  
        `CFG.write_register(`DTCR1, `GRM.dtcr1);
      end
`endif
      
`ifdef DWC_DX_VREF_DAC_USE      
      if (`DWC_DX_VREF_DAC_USE == 9'h000) begin
        // allow sharing of VREF Rank value
        `GRM.vtcr1[10:8] = {2'b00, 1'b1};
        `CFG.write_register(`VTCR1, `GRM.vtcr1);
      end
`endif        
      
`ifdef LPDDR3
      // set ZQCR 
      if (lpddr3_term_type==`LPDDR3_TERM) begin
        word        = `ZQCR_DEFAULT;
        //word[24]    = 1'b1;
        //word[25]    = 1'b1;
        //word[26]    = 1'b0;
        `CFG.write_register(`ZQCR, word);

        // set ZQnPR
        for (i=0; i<`DWC_NO_OF_ZQ_SEG; i=i+1)
          begin
            // for ZQnPR, cannot have ZQDIV[7:4] and ZQDIV[3:0] both equal to zero, this will 
            // cause an error
            reg_data = `ZQNPR_DEFAULT;
            reg_data[28] = 1'b1;  //pu_odt_only
            reg_addr = (`ZQ0PR + 8'h4*i);

            // if ZQDIV[7:4] is 0, change to random value
            if (reg_data[7:4] == 4'b0)
              //reg_data[7:4] = 4'b1;
              reg_data[7:4] = {$random(`SYS.seed)};

            // if ZQDIV[3:0] is 0, change to random value
            if (reg_data[3:0] == 4'b0)
              //reg_data[3:0] = 4'b1;
              reg_data[3:0] = {$random(`SYS.seed)};
            
            `CFG.write_register(reg_addr, reg_data);
          end
      end

`endif        


`ifdef DWC_DDR_RDIMM
      // set RDIMM configurations
      word    = `RDIMMGCR0_DEFAULT;
      word[0] = `DWC_RDIMM;
      word[2] = stop_on_perr;
  `ifdef DWC_AC_PARITY_USE      
      word[16] = 1'b0;
  `endif
  `ifdef DWC_DDR_LRDIMM_EN
      word[18] = 1'b1;
  `endif       
  `ifndef DWC_AC_ALERTN_USE
      word[1] = 1'b1;
  `endif 
  `ifdef RDIMM_QUAD_RANK
      word[30] = 1'b1; // QuadCS enable
  `endif
      if (word !== `RDIMMGCR0_DEFAULT) `CFG.write_register(`RDIMMGCR0, word);

      // for systems that are more than 2 ranks, set ODTCR register such that
      // ODT[0] is enabled when accessing rank 0 or rank 2, and ODT[1] is
      // enabled when accessing rank 1 or rank 3, i.e. set WRODT2 to 4'b0101
      // and WRODT3 to 4'b1010 
      for(i=0;i<pNO_OF_PRANKS;i=i+1) begin
        word    = `ODTCR_DEFAULT;
        `GRM.rankidr[3:0] = i;
        `CFG.write_register(`RANKIDR, `GRM.rankidr);
        repeat (5) @(posedge `CFG.clk);

        // For write 
        for (rank_id = 0; rank_id < pNO_OF_PRANKS; rank_id = rank_id + 1) begin
          if (rank_id%2 == i%2)
            word[rank_id+16] = 1'b1;
          else
            word[rank_id+16] = 1'b0;
        end
        `CFG.write_register(`ODTCR, word);
      end
      

      //ROB-disable randomization      // randomly initialize either all registers (the default) or a few 
      //ROB-disable randomization      // randomly selected registers
      //ROB-disable randomization      if (rdimm_reg_randomize) begin
      //ROB-disable randomization        if ({$random} % 2) begin
      //ROB-disable randomization          `GRM.rdimmgcr1[31:16] = $random;
      //ROB-disable randomization          if (`GRM.rdimmgcr1 !== `RDIMMGCR1_DEFAULT) `CFG.write_register(`RDIMMGCR1, `GRM.rdimmgcr1);
      //ROB-disable randomization        end
      //ROB-disable randomization          
      //ROB-disable randomization        // randomly initialize a few buffer chip registers that show some effect
      //ROB-disable randomization        // RC1: enable/disable Y/Y#[3:1] - keep Y/Y#[0] running
      //ROB-disable randomization        if (`GRM.rdimmgcr1[17]) `GRM.rdimmcr0[1*4+1 +: 3] = $random;
      //ROB-disable randomization
      //ROB-disable randomization        // also randomize the data of the other RC registers that don't show any effect on
      //ROB-disable randomization        // digital functional; sometimes don't randomize - just use the defaults
      //ROB-disable randomization        if ({$random} % 2) begin
      //ROB-disable randomization          for (i=18; i<32; i=i+1) begin
      //ROB-disable randomization            if (`GRM.rdimmgcr1[i] && i<24) `GRM.rdimmcr0[(i-16)*4 +: 4] = $random;
      //ROB-disable randomization            if (`GRM.rdimmgcr1[i] && i>23) `GRM.rdimmcr1[(i-24)*4 +: 4] = $random;
      //ROB-disable randomization
      //ROB-disable randomization            // make sure these special bits are not set - will be tested in other testcases
      //ROB-disable randomization            `GRM.rdimmcr0[8] = 1'b0; // standard pre-launch
      //ROB-disable randomization            `GRM.rdimmcr0[9] = 1'b0; // 1T timing
      //ROB-disable randomization          end
      //ROB-disable randomization        end

      for(i=0;i<`DWC_NO_OF_DIMMS;i=i+1)
        begin   
  `ifdef DWC_RDIMM_DISABLE_INV 
          `GRM.rdimmcr0[i][0] = 1'b1;
  `endif
          
  `ifdef DDR4_1600J
          `GRM.rdimmcr1[i][11:8] = 4'h0;
  `elsif DDR4_1866L
            `GRM.rdimmcr1[i][11:8] = 4'h1;
  `elsif DDR4_2133N 
            `GRM.rdimmcr1[i][11:8] = 4'h2;
  `elsif DDR4_2400
            `GRM.rdimmcr1[i][11:8] = 4'h3;
  `elsif DDR4_DBYP
            `GRM.rdimmcr1[i][11:8] = 4'h6;
  `elsif DDR3_2133K   
            `GRM.rdimmcr1[i][11:8] = 4'h5;
  `elsif DDR3_1866J  
            `GRM.rdimmcr1[i][11:8] = 4'h4;
  `elsif DDR3_1600G
            `GRM.rdimmcr1[i][11:8] = 4'h3;
  `elsif DDR3_1333F 
            `GRM.rdimmcr1[i][11:8] = 4'h2;
  `elsif DDR3_1066E
            `GRM.rdimmcr1[i][11:8] = 4'h1;
  `elsif DDR3_800D   
            `GRM.rdimmcr1[i][11:8] = 4'h0;
  `elsif DDR3_667C 
            `GRM.rdimmcr1[i][11:8] = 4'h0;
  `endif                                   
          
  `ifdef DWC_RDIMM_MIRROR
          `GRM.rdimmcr1[i][23] = 1'b1;
  `else 
          `GRM.rdimmcr1[i][23] = 1'b0;
  `endif
          
          `GRM.rdimmcr1[i][22] = 1'b1; // RDIMM
          `GRM.rdimmcr1[i][24] = 1'b1;
          
  `ifdef RDIMM_QUAD_RANK
    `ifdef DDR4
      `ifdef RDIMM_EQUAD_RANK
          // enable encode quad CS mode   
          `GRM.rdimmcr1[i][21:20] = 2'b11;
      `else
          // enable direct quad CS mode   
          `GRM.rdimmcr1[i][21:20] = 2'b01;
      `endif
    `endif
  `endif
          
          // TODO -> Review the randomization of RC's with Michael to see what safe values can be
          // programmed.
          // `GRM.rdimmcr0 = 'h0;
          // `GRM.rdimmcr1 = 'h0;

          // write the PUB RC registers, if necessary
          // if (`GRM.rdimmcr0 !== `RDIMMCR0_DEFAULT) `CFG.write_register(`RDIMMCR0, `GRM.rdimmcr0);
          // if (`GRM.rdimmcr1 !== `RDIMMCR1_DEFAULT) `CFG.write_register(`RDIMMCR1, `GRM.rdimmcr1);
          if (`GRM.rdimmcr0[i] !== `RDIMMCR0_DEFAULT) write_rank_register(`RDIMMCR0, `GRM.rdimmcr0[i], i);
          if (`GRM.rdimmcr1[i] !== `RDIMMCR1_DEFAULT) write_rank_register(`RDIMMCR1, `GRM.rdimmcr1[i], i);
          //ROB-disable randomization      end
        end // !for(i=0;i<`DWC_NO_OF_DIMMS;i=i+1)

`else //  `else of DWC_DDR_RDIMM

      // randomize odtcr
      for(i=0;i<pNO_OF_PRANKS;i=i+1) begin
        word    = `ODTCR_DEFAULT;
        `GRM.rankidr[3:0] = i;
        `CFG.write_register(`RANKIDR, `GRM.rankidr);
        repeat (5) @(posedge `CFG.clk);

        for (rank_id = 0; rank_id < pNO_OF_PRANKS; rank_id = rank_id + 1) begin
          // if random is select randomly select on and off per ranks
          if (rand_odtcr==1'b1) begin
            // For read only enable rank if RTT is in 0 (limitation from DDR3 model)
            if ((`GRM.ddr3_mode && (`ODT_RTT == 0)) || (!`GRM.ddr3_mode))
              word[rank_id]      = $random%2;
            else
              word[rank_id]      = 1'b0; // disabled 

            word[rank_id+16]   = $random%2;
          end
          else begin
            // else only assign its own rank to be on
            if (rank_id == i) begin
              // For read only enable rank if RTT is in 0 (limitation from DDR3 model)
              if ((`GRM.ddr3_mode && (`ODT_RTT == 0)) || (!`GRM.ddr3_mode)) 
                word[rank_id]    = 1'b1;
              else
                word[rank_id]    = 1'b0;
              word[rank_id+16] = 1'b1;
            end
            else begin
              word[rank_id]    = 1'b0;
              word[rank_id+16] = 1'b0;
            end
          end
        end
        `CFG.write_register(`ODTCR, word);
      end
      
`endif //  `ifdef DWC_DDR_RDIMM
      
      // miscellaneous
`ifdef SDF_ANNOTATE
      // change the default system latency to 1/2 because of the extra I/O 
      // delays
  `ifdef SLOW_SDF
      `GRM.write_controller_register(`RSLR0, {11{3'b010}});
      `GRM.write_controller_register(`RDGR0, 32'hFFFFFFFF);
  `else
      `GRM.write_controller_register(`RSLR0, {11{3'b001}});
      `GRM.write_controller_register(`RDGR0, 32'h55555555);
  `endif
`endif

`ifdef DWC_DDRPHY_TB
      // wait so many NOPs after changing controller/SDRAM configuration
      `CFG.nops(`NOPS_AFTER_CFG);
`endif
      powering_up = 1'b0;
    end
  endtask // configure_controller

  
  // writes to the indirectly indexed rank registers
  task write_rank_register;
    input [31:0] reg_addr;
    input [31:0] reg_data;
    input [31:0] rank_id;
    begin
      `GRM.rankidr[3:0] = rank_id;
      `CFG.write_register(`RANKIDR, `GRM.rankidr);
      repeat (5) @(posedge `CFG.clk);
      `CFG.write_register(reg_addr, reg_data);
    end
  endtask // write_rank_register
  
  // reads to the indirectly indexed rank registers
  task read_rank_register;
    input  [31:0] reg_addr;
    output [31:0] reg_data;
    input  [31:0] rank_id;
    begin
      `GRM.rankidr[19:16] = rank_id;
      `CFG.write_register(`RANKIDR, `GRM.rankidr);
      repeat (5) @(posedge `CFG.clk);
      `CFG.read_register_data(reg_addr, reg_data);
    end
  endtask // read_rank_register

  
   //---------------------------------------------------------------------------
   // SDRAM Initialization
   //---------------------------------------------------------------------------
   // executes the SDRAM initialization sequence
   task initialize_sdram;
      begin
         case (dram_init_type)
           `PUB_DRAM_INIT: begin
              // triggering built in PUB SDRAM initialization
              `GRM.pir[0]  = 1'b1;                              // INIT

`ifndef DWC_DDRPHY_EMUL_XILINX
  `ifndef DWC_NO_CA_TRAIN
    `ifdef DWC_AC_CS_USE
              if(!rank_disconnected) begin
                // need at least two bytes to run CA TRAINING in lpddr3 mode
                if (`GRM.lpddr3_mode) begin
                  if (`DWC_NO_OF_BYTES >= 2) 
                    `GRM.pir[2]  = 1'b1       ;// CA TRAIN for LPDDR3 only
                  else begin
                    // manually write aclcdlr.acd with extra 1/4 clk delay instead of CA train
                    // since CA training requires at least two byte lanes.
                    `GRM.pir[2] = 1'b0;
                    
                    add_qtr_clk_aclcdlr = 1'b1;
                    `GRM.aclcdlr[8:0] = `GRM.cal_90deg_val;
                    `CFG.write_register(`ACLCDLR, `GRM.aclcdlr);
                  end
                end
                else begin
                  `GRM.pir[2] = 1'b0;
                end
              end
             
    `endif
  `endif
`endif
              `GRM.pir[7]  = ((`GRM.ddr4_mode) || (`GRM.ddr3_mode)) ? 1'b1 : 1'b0;    // DRAMRST
              `GRM.pir[8]  = 1'b1;                              // DRAMINIT
              `GRM.pir[18] = 1'b0;                              // CTLDINIT
              `GRM.pir[19] = (`GRM.rdimm)     ? 1'b1 : 1'b0;    // RDIMMINIT ***TBD: make it random
              `FCOV_REG.set_cov_registers_write(`PIR, `GRM.pir,`VALUE_REGISTER_DATA);
              `FCOV_REG.set_cov_init_trig_pll_dcal_phy_dram_scenario;
              `FCOV_REG.set_cov_init_trig_wl_dqsg_data_eye_train_scenario;
              `CFG.write_register(`PIR, `GRM.pir);
             
             // wait for (and report) SDRAM initialization to finish
`ifndef DWC_DDRPHY_EMUL_XILINX
              `CFG.poll_register(`PGSR0, 4, 4, 1'b1,  100, 3000000, "DRAM init done...");
`endif
              // wait for overall initialization to finish
              `CFG.poll_register(`PGSR0, 0, 0, 1'b1,  100, 3000000, "PUB initialization done...");
              init = 1'b1;
             
              `GRM.pgsr0[3:0] = {4{1'b1}}; // done status bits are set
`ifdef LPDDR3 
  `ifndef DWC_DDRPHY_EMUL_XILINX
              // status on CA train if run
              if (!rank_disconnected) begin            
                `GRM.pgsr0[12] = 1'b1; // done status bits are set
              end
  `endif
`endif
           end

           `CTL_DRAM_INIT: begin
              // controller is initializing the DRAM
              // write '1' to PIR[INIT] and '1' to PIR[CTLDINIT] with no other 
              // initialization selected to indicate external controller DRAM 
              // initialization
              `GRM.pir[0]  = 1'b1;                              // INIT
              `GRM.pir[18] = 1'b1;                              // CTLDINIT
              `FCOV_REG.set_cov_registers_write(`PIR, `GRM.pir,`VALUE_REGISTER_DATA);
              `FCOV_REG.set_cov_init_trig_pll_dcal_phy_dram_scenario;
              `FCOV_REG.set_cov_init_trig_wl_dqsg_data_eye_train_scenario;
              `CFG.write_register(`PIR, `GRM.pir);

              // Wait for SDRAM initialization to finish.  Wait for the rising edge
              // of init_done because the signal may take time to deassert before it
              // asseerts again depending on the cfg_clk rate.
              `CFG.poll_register(`PGSR0, 0, 0, 1'b1,  100, 3000000, "PUB initialization done...");
              init = 1'b1;

              // execute controller DRAM initialization
              `HOST.initialize_sdram;
              `ifdef DWC_SDRAM_DLL_BYPASS
                `ifdef DDR4_DBYP
                  `GRM.mr1[0][0]= 1'b0;
                `else
                  `GRM.mr1[0][0]= 1'b1;
                `endif
                `HOST.load_mode(`MR1_REG, `GRM.mr1[0] );
                `CFG.write_register(`MR1_REG, `GRM.mr1[0]); 
                `CFG.nops(30);
              `endif
           end

           `CFG_DRAM_INIT: begin
              // DRAM is initialized using the DCU through the configuration port
              // write '1' to PIR[INIT] with no initialization selected to 
              // indicate external DRAM initialization
              `GRM.pir[0]  = 1'b1;                              // INIT
              `FCOV_REG.set_cov_registers_write(`PIR, `GRM.pir,`VALUE_REGISTER_DATA);
              `FCOV_REG.set_cov_init_trig_pll_dcal_phy_dram_scenario;
              `FCOV_REG.set_cov_init_trig_wl_dqsg_data_eye_train_scenario;
              `CFG.write_register(`PIR, `GRM.pir);

              // wait for SDRAM initialization to finish
              `CFG.poll_register(`PGSR0, 0, 0, 1'b1,  100, 3000000, "PUB initialization done...");
               init = 1'b1;

              // execute DCU DRAM initialization
              // disable_clock_checks;
              `CFG.initialize_sdram;
              // enable_clock_checks; 
              `ifdef DWC_SDRAM_DLL_BYPASS
                `ifdef DDR4_DBYP
                  `GRM.mr1[0][0]= 1'b0;
                `else
                  `GRM.mr1[0][0]= 1'b1;
                `endif
                `HOST.load_mode(`MR1_REG, `GRM.mr1[0] );
                `CFG.write_register(`MR1_REG, `GRM.mr1[0]); 
                `CFG.nops(30);
              `endif
           end
         endcase // case (dram_init_type)

         // DRAM initialization is done
         message(`SYS_OP, `END_INIT, 0);
         -> e_sdram_init_done;
          `ifdef DWC_DDRPHY_EMUL_XILINX
         if(dqs_train_in_sdram_init)begin
            rpt_dqs_train_emul;
         end
          `endif
      end
   endtask // initialize_sdram

   
   // sets the DRAM initialization type
   task set_dram_initialization_type;
      input [1:0] init_type;
      begin
         dram_init_type = init_type;
      end
   endtask // set_dram_initialization_type
   

   // Parity errors
   // -------------
   // injects parity errors; errors can be injected using the parity input at
   // the buffer chip (constantly driving the par signal to 0) or injected at the 
   // controller by calculating the wrong parity on the dfi_parity_in signal
   task inject_parity_errors;
      input inject_point;
      begin
         parity_err_xpctd = 1'b1;
         if (inject_point == `PARERR_AT_BC)      parity_err = 1'b1;
         if (inject_point == `PARERR_AT_MC) `DFI.parity_err = 1'b1;

         // the paraity status register bit (PGSR1.PARERR) is expected to be set
         `GRM.pgsr1[31] = `DWC_RDIMM;
      end
   endtask // inject_parity_errors

   // reset parity error injection
   task dont_inject_parity_errors;
      begin
         parity_err_xpctd   = 1'b0;
         parity_err = 1'b0;
         `DFI.parity_err = 1'b0;
      end
   endtask // dont_inject_parity_errors


   // enable/disable stop on parity errors
   // suppress error messages because they are expected if the PUB
   // stops on parity errors
   task enable_stop_on_perr;
      begin
         stop_on_perr     = 1'b1;
         suppress_err_msg = 1'b1; // report errors as information
      end
   endtask // enable_stop_on_perr
   
   task disable_stop_on_perr;
      begin
         stop_on_perr     = 1'b0;
         suppress_err_msg = 1'b0; // report errors
      end
   endtask // disable_stop_on_perr
   
   
   // WL Delay training
   // -------------------
   task train_dx_lcdl_wl;
      input       reg_rand;
      input reg [`LCDL_DLY_WIDTH-1:0] pattern;
      
      integer                         i, rank_id;
      reg [`REG_ADDR_WIDTH:0]         reg_addr;
      reg [`REG_DATA_WIDTH:0]         reg_data0;
      reg [`REG_DATA_WIDTH:0]         reg_data1;
      begin
         // write a value to the DX WL LCDL register
         $display("SYSTEM: WRITE VALUE TO DXnLCDLR0 WL REGISTER!!");
         reg_data0 = {`REG_DATA_WIDTH{1'b0}};
         reg_data1 = {`REG_DATA_WIDTH{1'b0}};
         
         
         for (i=0; i<`DWC_NO_OF_BYTES; i=i+1)
           begin
              if (reg_rand) begin
                 reg_data0[0  +: `LCDL_DLY_WIDTH] = $random;
                 reg_data1[0  +: `LCDL_DLY_WIDTH] = $random;
                 if (`DWC_DX_NO_OF_DQS == 2 ) begin
                   reg_data0[16 +: `LCDL_DLY_WIDTH] = $random; 
                   reg_data1[16 +: `LCDL_DLY_WIDTH] = $random;
                 end
              end
              else begin
                 reg_data0[0  +: `LCDL_DLY_WIDTH] = pattern;
                 reg_data1[0  +: `LCDL_DLY_WIDTH] = pattern;
                 if (`DWC_DX_NO_OF_DQS == 2 ) begin
                   reg_data0[16 +: `LCDL_DLY_WIDTH] = pattern; 
                   reg_data1[16 +: `LCDL_DLY_WIDTH] = pattern;
                 end
              end
              for (rank_id=0; rank_id < pNO_OF_LRANKS; rank_id = rank_id + 1) begin
                 reg_addr = `RANKIDR;
                 `GRM.rankidr[0 +: 4] = rank_id;
                 @(posedge `CFG.clk);
                 `CFG.write_register(reg_addr, `GRM.rankidr);
                 repeat (5) @(posedge `CFG.clk);
                 `FCOV_REG.set_cov_registers_write(reg_addr, `GRM.rankidr,`VALUE_REGISTER_DATA);
                 reg_addr = `DX0LCDLR0 + (`DX_REG_RANGE * i);
                 @(posedge `CFG.clk);
                 `CFG.write_register(reg_addr, reg_data0);
                 `FCOV_REG.set_cov_registers_write(reg_addr, reg_data0,`VALUE_REGISTER_DATA);
              end // for (rank_id=0; rank_id < pNO_OF_LRANKS; rank_id = rank_id + 1)
              
           end // for (i=0; i<`DWC_NO_OF_BYTES; i=i+1)
      end
      
  endtask   


  // WDQS RDQS LCDL Delay training
  // -----------------------------
  task train_dx_lcdl_rdqs_wdqs;
    input       reg_rand;
    input [`LCDL_DLY_WIDTH-1:0] tmp1;
    input [`LCDL_DLY_WIDTH-1:0] tmp2;
    integer     i, rank_id;
    reg [`REG_ADDR_WIDTH:0] reg_addr;
    reg [`REG_DATA_WIDTH:0] reg_data0;
    reg [`REG_DATA_WIDTH:0] reg_data1;
    begin
      // write a value to the DX WL LCDL register
     $display("SYSTEM: TEMPORARY WRITE VALUE TO DXnLCDLR4-5 REGISTER... NEED TO DEVELOP TRAINING LATER!!");
     reg_data0 = {`REG_DATA_WIDTH{1'b0}};
     reg_data1 = {`REG_DATA_WIDTH{1'b0}};
      for (i=0; i<`DWC_NO_OF_BYTES; i=i+1)
        begin
          reg_data[31:24] = 16'h0;
          @(negedge `CFG.clk);
          if (reg_rand) begin
            reg_data0[0  +: `LCDL_DLY_WIDTH] = $random;
            reg_data1[0  +: `LCDL_DLY_WIDTH] = $random;
            if (`DWC_DX_NO_OF_DQS == 2 ) begin
              reg_data0[16 +: `LCDL_DLY_WIDTH] = $random; 
              reg_data1[16 +: `LCDL_DLY_WIDTH] = $random; 
            end
          end
          else begin
            reg_data0[0  +: `LCDL_DLY_WIDTH] = tmp1;
            reg_data1[0  +: `LCDL_DLY_WIDTH] = tmp2;
            if (`DWC_DX_NO_OF_DQS == 2 ) begin
              reg_data0[16 +: `LCDL_DLY_WIDTH] = tmp1; 
              reg_data1[16 +: `LCDL_DLY_WIDTH] = tmp2; 
            end
          end
           for(rank_id=0; rank_id < pNO_OF_LRANKS; rank_id = rank_id + 1) begin
              reg_addr = `RANKIDR;
              `GRM.rankidr[0 +: 4] = rank_id;
              @(posedge `CFG.clk);
              `CFG.write_register(reg_addr, `GRM.rankidr);
              repeat (5) @(posedge `CFG.clk);
              `FCOV_REG.set_cov_registers_write(reg_addr, `GRM.rankidr,`VALUE_REGISTER_DATA);
              reg_addr = `DX0LCDLR3 + (`DX_REG_RANGE * i);
              @(posedge `CFG.clk);
              `CFG.write_register(reg_addr, reg_data0);
              `FCOV_REG.set_cov_registers_write(reg_addr, reg_data0,`VALUE_REGISTER_DATA);

              reg_addr = `DX0LCDLR4 + (`DX_REG_RANGE * i);
              @(posedge `CFG.clk);
              `CFG.write_register(reg_addr, reg_data0);
              `FCOV_REG.set_cov_registers_write(reg_addr, reg_data0,`VALUE_REGISTER_DATA);

              reg_addr = `DX0LCDLR1 + (`DX_REG_RANGE * i);
              @(posedge `CFG.clk);
              `CFG.write_register(reg_addr, reg_data1);
              `FCOV_REG.set_cov_registers_write(reg_addr, reg_data1,`VALUE_REGISTER_DATA);
           end // for (rank_id=0; rank_id < pNO_OF_LRANKS; rank_id = rank_id + 1)
           
        end // for (i=0; i<`DWC_NO_OF_BYTES; i=i+1)
       
    end
  endtask   
  
  
  // DQS gating training
  // -------------------
  task train_dqs_gate;
    input       reg_rand;
    integer     i,j, rank_id;
    reg [`REG_ADDR_WIDTH:0] reg_addr;
    reg [`REG_DATA_WIDTH:0] reg_data0;
    reg [`REG_DATA_WIDTH:0] reg_data1;
    integer ddr_clk_period;
    integer r0_delay_ps;
    integer r1_delay_ps;
    integer r2_delay_ps;
    integer r3_delay_ps;
    integer delay_ps [pNO_OF_LRANKS-1:0];
    integer r0_delay_taps;
    integer r1_delay_taps;
    integer r2_delay_taps;
    integer r3_delay_taps;
    integer delay_taps [pNO_OF_LRANKS-1:0];
    integer r0_delay_rsl;
    integer r1_delay_rsl;
    integer r2_delay_rsl;
    integer r3_delay_rsl;
    integer delay_rsl [pNO_OF_LRANKS-1:0];
    integer rsl;
    begin
      // write a value to the DQS gating register so that it is correctly
      // shifted; this will have to be trained later
      reg_data0 = {`REG_DATA_WIDTH{1'b0}};
      reg_data1 = {`REG_DATA_WIDTH{1'b0}};
      $display("SYSTEM: TEMPORARY WRITE VALUE TO DXnLCDLR2 REGISTER... NEED TO DEVELOP TRAINING LATER!!");
      ddr_clk_period = (`SDRAM_CK_PRD*(1000.0/2.0));
      for (i=0; i<`DWC_NO_OF_BYTES; i=i+1)
        begin
          @(negedge `CFG.clk);
          if (!reg_rand) begin

            // convert the gdqs tap setting from the dictionary to a delay value in ps
            // assumption is that the default step size is 5ps
            
            for (rank_id=0; rank_id < pNO_OF_LRANKS ; rank_id = rank_id + 1) begin
                delay_ps[rank_id] = `GDQS_DLY_DFLT * 1000.0 * 0.005; 

            // if bubbles are enabled add the read dqs board delay
`ifdef DWC_BUBBLES
                delay_ps[rank_id] = delay_ps[rank_id] + read_dqs_brd_dly[rank_id][i]; 
            
`endif
            // compute the rsl value
                delay_rsl[rank_id] = delay_ps[rank_id]/ddr_clk_period;

            // compute the ddl delay value required
                delay_ps[rank_id] = delay_ps[rank_id] % ddr_clk_period;

            // convert the ddl delay value (in ps) to taps
                delay_taps[rank_id] = delay_ps[rank_id] / (1000.0 * `PHYSYS.ddl_step_size);
                @(posedge `CFG.clk);

                reg_data0 = {`REG_DATA_WIDTH{1'b0}};
                reg_data0[0  +: `RANKID_WR_WIDTH] = rank_id;
                reg_addr = `RANKIDR; 
                `CFG.write_register(reg_addr, reg_data0);
                repeat (5) @(posedge `CFG.clk);
                `FCOV_REG.set_cov_registers_write(reg_addr, reg_data0,`VALUE_REGISTER_DATA);

                reg_data0 = {`REG_DATA_WIDTH{1'b0}};
                reg_data0[0  +: `LCDL_DLY_WIDTH] = delay_taps[rank_id];
                if (`DWC_DX_NO_OF_DQS == 2'd2) begin
                  reg_data0[16 +: `LCDL_DLY_WIDTH] = delay_taps[rank_id];
                end
                reg_addr = `DX0LCDLR2 + (i*`DX_REG_RANGE);
                `CFG.write_register(reg_addr, reg_data0);
                `FCOV_REG.set_cov_registers_write(reg_addr, reg_data0,`VALUE_REGISTER_DATA);
            end 
          end // if (!reg_rand)
          else begin 
            for (rank_id=0; rank_id < pNO_OF_LRANKS ; rank_id = rank_id + 1) begin
                delay_ps[rank_id] = `GDQS_DLY_DFLT * 1000.0 * 0.005; 

            // if bubbles are enabled add the read dqs board delay
`ifdef DWC_BUBBLES
                delay_ps[rank_id] = delay_ps[rank_id] + read_dqs_brd_dly[rank_id][i]; 
            
`endif
            // compute the rsl value
                delay_rsl[rank_id] = delay_ps[rank_id]/ddr_clk_period;

                @(posedge `CFG.clk);

                reg_data0 = {`REG_DATA_WIDTH{1'b0}};
                reg_data0[0  +: `RANKID_WR_WIDTH] = rank_id;
                reg_addr = `RANKIDR; 
                `CFG.write_register(reg_addr, reg_data0);
                repeat (5) @(posedge `CFG.clk);
                `FCOV_REG.set_cov_registers_write(reg_addr, reg_data0,`VALUE_REGISTER_DATA);

                reg_data0 = {`REG_DATA_WIDTH{1'b0}};
        //    reg_data1[16 +: `LCDL_DLY_WIDTH] = $random;
        //    reg_data1[0  +: `LCDL_DLY_WIDTH] = $random;
                if (`DWC_DX_NO_OF_DQS == 2) begin
                    reg_data0[16 +: `LCDL_DLY_WIDTH] = $random;
                end
                reg_data0[0  +: `LCDL_DLY_WIDTH] = $random;
                reg_addr = `DX0LCDLR2 + (i*`DX_REG_RANGE);
                 `CFG.write_register(reg_addr, reg_data0);
                `FCOV_REG.set_cov_registers_write(reg_addr, reg_data0,`VALUE_REGISTER_DATA);
            end
                
          end 
           for (rank_id = 0; rank_id < pNO_OF_LRANKS; rank_id = rank_id + 1) begin
               `GRM.dxngtr0[rank_id][i][ 4: 0] = delay_rsl[rank_id];
             // for DDR3 RDIMM, the address is registered through the register chip while the 
             // data is not - push out the data using the write leveling system latency;
             // similarly adjust read latency
             // for DDR4, this extra latency is almost 2.5tCK for the RCD chip used here
  `ifdef DDR3
               if (`DWC_RDIMM) begin
                 `GRM.dxngtr0[rank_id][i][19:16] = `GRM.dxngtr0[rank_id][i][19:16] + 2 ;
                 `GRM.dxngtr0[rank_id][i][ 4:0]  = `GRM.dxngtr0[rank_id][i][4:0] + 2;
               end
  `endif
  `ifdef DDR4
               if (`DWC_RDIMM) begin
                 `GRM.dxngtr0[rank_id][i][19:16] = `GRM.dxngtr0[rank_id][i][19:16] + 3 ;
                 `GRM.dxngtr0[rank_id][i][ 4:0]  = `GRM.dxngtr0[rank_id][i][4:0] + 3;
               end
  `endif
         	   if (`DWC_DX_NO_OF_DQS == 2'd2) begin
                  `GRM.dxngtr0[rank_id][i][ 12:8] = delay_rsl[rank_id];
  `ifdef DDR3
                  if (`DWC_RDIMM) begin
                    `GRM.dxngtr0[rank_id][i][23:20] = `GRM.dxngtr0[rank_id][i][23:20] + 2 ;
                    `GRM.dxngtr0[rank_id][i][12:8]  = `GRM.dxngtr0[rank_id][i][12:8] + 2;
                  end
  `endif
  `ifdef DDR4
                  if (`DWC_RDIMM) begin
                    `GRM.dxngtr0[rank_id][i][23:20] = `GRM.dxngtr0[rank_id][i][23:20] + 3 ;
                    `GRM.dxngtr0[rank_id][i][12:8]  = `GRM.dxngtr0[rank_id][i][12:8] + 3;
                  end
  `endif
               end
                reg_addr = `RANKIDR; 
                reg_data0 = {`REG_DATA_WIDTH{1'b0}};
                reg_data0[0  +: `RANKID_WR_WIDTH] = rank_id;
                `CFG.write_register(reg_addr, reg_data0);
                `FCOV_REG.set_cov_registers_write(reg_addr, reg_data0,`VALUE_REGISTER_DATA);
                repeat (5) @(posedge `CFG.clk);

             
               reg_addr = `DX0GTR0 + (i*`DX_REG_RANGE);
               `CFG.write_register(reg_addr, `GRM.dxngtr0[rank_id][i]);
               `FCOV_REG.set_cov_registers_write(reg_addr, `GRM.dxngtr0[rank_id][i],`VALUE_REGISTER_DATA);
         end
         // reset rankid register
                reg_addr = `RANKIDR; 
                reg_data0 = `RANKIDR_DEFAULT;
                `CFG.write_register(reg_addr, reg_data0);
                `FCOV_REG.set_cov_registers_write(reg_addr, reg_data0,`VALUE_REGISTER_DATA);
                repeat (5) @(posedge `CFG.clk);
        end
      need_data_train   = 1'b0;
    end
  endtask // train_dqs_gate


  task train_dqs_gate_local;
    input             reg_rand;
    input reg [7:0]   pattern;
    reg [`REG_ADDR_WIDTH:0] reg_addr;
    reg [`REG_DATA_WIDTH:0] reg_data0;
    integer           i, rank_id;
    
    begin
      reg_data0 = {`REG_DATA_WIDTH{1'b0}};
      if (!reg_rand) begin
        train_dqs_gate(reg_rand);
      end else begin
        reg_addr = `DX0LCDLR2;
        for (i=0; i<`DWC_NO_OF_BYTES; i=i+1)
          begin
            for (rank_id = 0; rank_id < pNO_OF_LRANKS; rank_id = rank_id + 1) begin
                reg_addr = `RANKIDR; 
                reg_data0[0  +: `RANKID_WR_WIDTH] = rank_id;
                @(posedge `CFG.clk);
                `CFG.write_register(reg_addr, reg_data0);
                `FCOV_REG.set_cov_registers_write(reg_addr, reg_data0,`VALUE_REGISTER_DATA);
                repeat (5) @(posedge `CFG.clk);


                @(negedge `CFG.clk);
                reg_data0[0  +: `LCDL_DLY_WIDTH] = pattern;
                if (`DWC_DX_NO_OF_DQS == 2) begin
                   reg_data0[16 +: `LCDL_DLY_WIDTH] = pattern; 
                end
                repeat (5) @(posedge `CFG.clk);
                reg_addr = `DX0LCDLR2 + (i*`DX_REG_RANGE);
                `CFG.write_register(reg_addr, reg_data0);
                `FCOV_REG.set_cov_registers_write(reg_addr, reg_data0,`VALUE_REGISTER_DATA);
            end
          end
      end
      if (!reg_rand) begin
        need_data_train   = 1'b0;
      end
    end
  endtask // train_dqs_gate_local
    

  // adjust loopback DQS gating
  // -------------------------
  // in loopback mode, the DQS will have shifted back by 90 degrees because
  // the read DQS LCDL 90 degrees shift is removed, subtract this from the
  // default gdqs_dly (or set to 0 if already less that 90 degrees)
  task adjust_loopback_dqs_gate;
    reg [`REG_ADDR_WIDTH:0] reg_addr;
    reg [`REG_DATA_WIDTH:0] reg_data0;
    reg [`REG_DATA_WIDTH:0] reg_data1;
    reg [`DWC_DX_NO_OF_DQS*`LCDL_DLY_WIDTH-1:0] gdqs_dly;

    reg [`DWC_DX_NO_OF_DQS*`LCDL_DLY_WIDTH-1:0] gdqs_data ;
    integer i, j, rank_id;
    begin
      reg_data0 = {`REG_DATA_WIDTH{1'b0}};
      reg_data1 = {`REG_DATA_WIDTH{1'b0}};
      for (i=0; i<`DWC_NO_OF_BYTES; i=i+1) begin
            for (rank_id = 0; rank_id < pNO_OF_LRANKS; rank_id = rank_id + 1) begin
                reg_addr = `RANKIDR; 
                reg_data0[16  +: `RANKID_RD_WIDTH] = rank_id;
                @(posedge `CFG.clk);
                `CFG.write_register(reg_addr, reg_data0);
                `FCOV_REG.set_cov_registers_write(reg_addr, reg_data0,`VALUE_REGISTER_DATA);

                 reg_data0 = {`REG_DATA_WIDTH{1'b0}};
                repeat (5) @(posedge `CFG.clk);
                 // read and adjust the current byte gating values
                `CFG.read_register_data(`DX0LCDLR2 + (i*`DX_REG_RANGE), reg_data0);
                 gdqs_data[0 +: `LCDL_DLY_WIDTH] = reg_data0[0 +: `LCDL_DLY_WIDTH];
                 if (`DWC_DX_NO_OF_DQS) begin
                    gdqs_data[(`DWC_DX_NO_OF_DQS-1)*`LCDL_DLY_WIDTH +: `LCDL_DLY_WIDTH] = reg_data0[16 +: `LCDL_DLY_WIDTH];
                 end
                 gdqs_dly = gdqs_data;
                 gdqs_dly[0 +: `LCDL_DLY_WIDTH] = gdqs_dly[0 +: `LCDL_DLY_WIDTH] - (`CAL_DDR_PRD/2);
                 if (`DWC_DX_NO_OF_DQS == 2) begin
                    gdqs_dly[(`DWC_DX_NO_OF_DQS-1)*`LCDL_DLY_WIDTH +: `LCDL_DLY_WIDTH] = gdqs_dly[(`DWC_DX_NO_OF_DQS-1)*`LCDL_DLY_WIDTH  +: `LCDL_DLY_WIDTH] - (`CAL_DDR_PRD/2);
                 end
                 if (gdqs_dly[0 +: `LCDL_DLY_WIDTH] < 0) gdqs_dly = 0;
                 if (gdqs_dly[(`DWC_DX_NO_OF_DQS-1)*`LCDL_DLY_WIDTH +: `LCDL_DLY_WIDTH] < 0) gdqs_dly = 0;

                reg_addr = `RANKIDR; 
                reg_data0[0  +: `RANKID_WR_WIDTH] = rank_id;
                @(posedge `CFG.clk);
                `CFG.write_register(reg_addr, reg_data0);
                `FCOV_REG.set_cov_registers_write(reg_addr, reg_data0,`VALUE_REGISTER_DATA);

                 reg_data0 = {`REG_DATA_WIDTH{1'b0}};
                 {reg_data0[16 +: `LCDL_DLY_WIDTH],
                  reg_data0[0 +: `LCDL_DLY_WIDTH] } = gdqs_dly;

                repeat (5) @(posedge `CFG.clk);
                // write the adjusted values
                reg_addr = `DX0LCDLR2 + (i*`DX_REG_RANGE);
                `CFG.write_register(reg_addr, reg_data0);
                `FCOV_REG.set_cov_registers_write(reg_addr, reg_data0,`VALUE_REGISTER_DATA);
            end    
	 
      end // for (i=0; i<`DWC_NO_OF_BYTES; i=i+1)
       
    end
  endtask // adjust_loopback_dqs_gate

  // count the number of chips
  generate
    for (dwc_dim=0; dwc_dim<`DWC_NO_OF_DIMMS; dwc_dim=dwc_dim+1) begin:chip_cnt_ddr_dimm
      for (dwc_rnk=0; dwc_rnk<`DWC_RANKS_PER_DIMM; dwc_rnk=dwc_rnk+1) begin:chip_cnt_ddr_rank
        initial begin
          #(0.01 + ((dwc_dim*`DWC_RANKS_PER_DIMM + dwc_rnk)*0.01));
          no_of_chips = no_of_chips + `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[dwc_rnk].sdram_rank.get_number_of_chips(`DWC_NO_OF_BYTES);
        end
      end
    end
  endgenerate
      
          
  // Auto DQS gating training
  // ------------------------
  task auto_train_dqs_gate;
    reg [`BURST_DATA_WIDTH-1:0] d;
    integer                   pattern;
    integer                   no_of_ptn;
    integer                   byte_i;
    integer                   dimm_no;
    integer                   rank_no;
    integer                   chip_no;
    integer                   no_of_chips;
    integer                   ranks_per_dimm;

    reg [`HOST_ADDR_WIDTH-1:0] addr0;
    reg [7:0]                 tmp_byte;
    reg [`DATA_WIDTH-1:0]     tmp_word0;
    reg [`DATA_WIDTH-1:0]     tmp_word1;
    reg [`DATA_WIDTH-1:0]     tmp_word2;
    reg [`DATA_WIDTH-1:0]     tmp_word3;
    
    begin
/* -----\/----- EXCLUDED -----\/-----

      `ifdef RDIMM_DUAL_RANK 
        no_of_chips = `RANK0.get_number_of_chips(`DWC_NO_OF_BYTES) + 
		      `RANK1.get_number_of_chips(`DWC_NO_OF_BYTES) ;
		      //`RANK2.get_number_of_chips(`DWC_NO_OF_BYTES) +
		      //`RANK3.get_number_of_chips(`DWC_NO_OF_BYTES);      
      `else
        no_of_chips = `RANK0.get_number_of_chips(`DWC_NO_OF_BYTES);
      `endif
 -----/\----- EXCLUDED -----/\----- */

      // Indicate that initialization is done so that the ddr_mctl can start 
      // handling refreshes as required
      init_done = 1'b1;

      // disable HOST read counter and trigger dqs_training_compare
      `HOST.read_cnt_en = 1'b0;
      rdqs_training    = 1'b1;

`ifdef DWC_USE_SHARED_AC_TB
      `HOST1.read_cnt_en = 1'b0;
      force `HOST_MNT1.rd_burst_cnt = 0;
`endif

      // make sure there is waited enough from previous refresh
      `SYS.nops(`GRM.t_rfc);

      // Loop for each RANK
      for (rank_no=0; rank_no <pNO_OF_LRANKS; rank_no=rank_no+1) begin

        // pick a pattern and write to sdram at address 0
        no_of_ptn     = 5;
        //pattern       = $random % no_of_ptn;
        pattern       = 4;
                       
        // setup for loop to Read address 0 with delay setting 
        // on both gdqs_pipe and lcdl value. Increment thru the range and
        // record the index when first read pass was located and stop when
        // the second fail was met.
        dqs_pipe_i = 0;
        lcdl_i     = 0;
        
        // Use number of lanes (pNUM_LANES) instead of number of bytes (DWC_NO_OF_BYTES)to adjust for X4X2

`ifdef DWC_USE_SHARED_AC_TB
        // when in shared ac dual channel mode, auto training will train one channel at a time
        // hence ignore the other half by assigning lane_done and lane_pass status.
        if (rank_no%2 ==0) begin
          lane_done = {{`DWC_NO_OF_BYTES-pCHN0_DX8_NUM{1'b1}}, {pCHN0_DX8_NUM{1'b0}}};
          lane_pass = {{`DWC_NO_OF_BYTES-pCHN0_DX8_NUM{1'b1}}, {pCHN0_DX8_NUM{1'b0}}};
        end
        else begin
          lane_done = {{pCHN1_DX8_NUM{1'b0}}, {`DWC_NO_OF_BYTES-pCHN1_DX8_NUM{1'b1}}};
          lane_pass = {{pCHN1_DX8_NUM{1'b0}}, {`DWC_NO_OF_BYTES-pCHN1_DX8_NUM{1'b1}}};
        end      
`else        
        lane_done = {pNUM_LANES{1'b0}};
        lane_pass = {pNUM_LANES{1'b0}};
`endif

        addr0     = {rank_no[1:0], 
                     {`SDRAM_BANK_WIDTH{1'b0}},
                     {`SDRAM_ROW_WIDTH{1'b0}},
                     {`SDRAM_COL_WIDTH{1'b0}}};
        
        // initialize all index
        for (byte_i=0; byte_i<pNUM_LANES; byte_i= byte_i+1) begin
          first_pass   [byte_i] = {32{1'bx}};
          fail_aft_pass[byte_i] = {32{1'bx}};
        end


        while ((dqs_pipe_i < 4) && (lane_done != {pNUM_LANES{1'b1}})) begin
          while ((lcdl_i < MAX_LCDL_VALUE) && (lane_done != {pNUM_LANES{1'b1}})) begin

            if (verbose > 7) begin
              $display("\n");
              $display("-> %0t: ---------------------------------------------",$time);
              $display("-> %0t: ==> rank_no    =   %0d",$time, rank_no);
              $display("-> %0t: ==> dqs_pipe_i =   %0d",$time, dqs_pipe_i);
              $display("-> %0t: ==> lcdl_i     = 'h%0h",$time, lcdl_i);
              $display("-> %0t: ---------------------------------------------",$time);
              $display("\n");
            end
            
            
            // set dqs_pipe and lcdl values
            for (chip_no=0; chip_no<no_of_chips; chip_no=chip_no+1) 
              `GRM.set_dqs_gate_pipeline(rank_no, chip_no, dqs_pipe_i);

             // MIKE, need to update this for share ac mode..
             for (byte_i=0; byte_i<pNUM_LANES; byte_i= byte_i+1) begin
                if (`DWC_DX_NO_OF_DQS == 2'd1)
                  begin
                     `GRM.dxnlcdlr2[rank_no][byte_i][0  +: `LCDL_DLY_WIDTH] = lcdl_i;
                     
                     `CFG.write_register(`DX0LCDLR2+(`DX_REG_RANGE*byte_i), `GRM.dxnlcdlr2[rank_no][byte_i]);
                     `FCOV_REG.set_cov_registers_write(`DX0LCDLR2+(`DX_REG_RANGE*byte_i), `GRM.dxnlcdlr2[rank_no][byte_i],`VALUE_REGISTER_DATA);
                  end
                else 
                  begin
                     if ( byte_i%2 == 0) // even lanes are nibble0
                       begin
                          `GRM.dxnlcdlr2[rank_no][byte_i/2][0  +: `LCDL_DLY_WIDTH] = lcdl_i;
                          `CFG.write_register(`DX0LCDLR2+(`DX_REG_RANGE*(byte_i/2)), `GRM.dxnlcdlr2[rank_no][byte_i/2]);
                          `FCOV_REG.set_cov_registers_write(`DX0LCDLR2+(`DX_REG_RANGE*byte_i), `GRM.dxnlcdlr2[rank_no][byte_i/2],`VALUE_REGISTER_DATA);
                       end
                     else  // odd lanes are nibble1
                       begin
                          `GRM.dxnlcdlr2[rank_no][(byte_i-1)/2][0  +: `LCDL_DLY_WIDTH] = lcdl_i;
                          `CFG.write_register(`DX0LCDLR2+(`DX_REG_RANGE*((byte_i-1)/2)), `GRM.dxnlcdlr2[rank_no][((byte_i-1)/2)]);
                          `FCOV_REG.set_cov_registers_write(`DX0LCDLR2+(`DX_REG_RANGE*((byte_i-1)/2)), `GRM.dxnlcdlr2[rank_no][((byte_i-1)/2)],`VALUE_REGISTER_DATA);
                       end
                  end // else: !if(`DWC_DX_NO_OF_DQS == 2'd1)
             end // for (byte_i=0; byte_i<pNUM_LANES; byte_i= byte_i+1)
	     
	     

            tmp_word0      = {{$random}, {$random},
                              {$random}, {$random},
                              {$random}, {$random},
                              {$random}, {$random},
                              {$random}, {$random},
                              {$random}, {$random},
                              {$random}, {$random},
                              {$random}, {$random},
                              {$random}, {$random}};

            tmp_word1      = {{$random}, {$random},
                              {$random}, {$random},
                              {$random}, {$random},
                              {$random}, {$random},
                              {$random}, {$random},
                              {$random}, {$random},
                              {$random}, {$random},
                              {$random}, {$random},
                              {$random}, {$random}};
            
            tmp_word2      = {{$random}, {$random},
                              {$random}, {$random},
                              {$random}, {$random},
                              {$random}, {$random},
                              {$random}, {$random},
                              {$random}, {$random},
                              {$random}, {$random},
                              {$random}, {$random},
                              {$random}, {$random}};

            tmp_word3      = {{$random}, {$random},
                              {$random}, {$random},
                              {$random}, {$random},
                              {$random}, {$random},
                              {$random}, {$random},
                              {$random}, {$random},
                              {$random}, {$random},
                              {$random}, {$random},
                              {$random}, {$random}};

            case (pattern)
              0:     d = {4*4*`DWC_NO_OF_BYTES{8'h00}};
              1:     d = {4*4*`DWC_NO_OF_BYTES{8'hFF}};
              2:     d = {4*4*`DWC_NO_OF_BYTES{8'hAA}};
              3:     d = {4*4*`DWC_NO_OF_BYTES{8'h55}};
              default:  d = (`DWC_MSBYTE_NDQ > 0) ?
                            {8{{`DWC_NO_OF_BYTES{8'hFF}}, {`DWC_NO_OF_BYTES{8'h00}}}} :
                            {tmp_word3, tmp_word2, tmp_word1, tmp_word0};  // random
            endcase // case(pattern)

            
            // set all tmp_pass to 0
            for (byte_i=0; byte_i<`DWC_NO_OF_BYTES; byte_i= byte_i+1)
              tmp_pass[byte_i] = 1'b0;
              
            // write address 0 with pattern d
            flip_word = 0;
            `HOST.write_data(addr0, d);

            // read address 0 with pattern d
            `HOST.read(addr0);
            cfg_nops(30);

            // push the read pointer ahead for the next word, as the qvld might not be
            // available. Clean the previous fifo location as well.   
            `GRM.ch0_fifo_rdptr                  = `GRM.ch0_fifo_wrptr;
            `GRM.ch0_fifo[`GRM.ch0_fifo_wrptr-1] = {`GRM.FIFO_WIDTH{1'b0}};
            `GRM.ch0_fifo[`GRM.ch0_fifo_wrptr-2] = {`GRM.FIFO_WIDTH{1'b0}};

            `GRM.ch1_fifo_rdptr                  = `GRM.ch1_fifo_wrptr;
            `GRM.ch1_fifo[`GRM.ch1_fifo_wrptr-1] = {`GRM.FIFO_WIDTH{1'b0}};
            `GRM.ch1_fifo[`GRM.ch1_fifo_wrptr-2] = {`GRM.FIFO_WIDTH{1'b0}};

            // write address 0 with pattern ~d
            flip_word = 1;
            `HOST.write_data(addr0, ~d);

            // read address 0 with pattern ~d
            `HOST.read(addr0);
            cfg_nops(30);

            // push the read pointer ahead for the next word, as the qvld might not be
            // available. Clean the previous fifo location as well.   
            `GRM.ch0_fifo_rdptr                  = `GRM.ch0_fifo_wrptr;
            `GRM.ch0_fifo[`GRM.ch0_fifo_wrptr-1] = {`GRM.FIFO_WIDTH{1'b0}};
            `GRM.ch0_fifo[`GRM.ch0_fifo_wrptr-2] = {`GRM.FIFO_WIDTH{1'b0}};
            
            `GRM.ch1_fifo_rdptr                  = `GRM.ch1_fifo_wrptr;
            `GRM.ch1_fifo[`GRM.ch1_fifo_wrptr-1] = {`GRM.FIFO_WIDTH{1'b0}};
            `GRM.ch1_fifo[`GRM.ch1_fifo_wrptr-2] = {`GRM.FIFO_WIDTH{1'b0}};
            
            lcdl_i = lcdl_i + LCDL_INC;
          end // while ((lcdl_i < MAX_LCDL_VALUE) && (lane_done != {pNUM_LANES{1'b1}}))
	   
          if (lane_done != {pNUM_LANES{1'b1}}) begin
            lcdl_i = 0; 
            dqs_pipe_i = dqs_pipe_i + 1;
          end
        end
        
        if (verbose > 7) t_print_train_dqs_info;

        // when all lane has located the second fail or end of the range, stop
        // and calculate the middle of that pass range which will be the desire value
        // of the read dqs gating value. Write that onto GRM and the DDRPHY registers
        // DXnLCDLR2

        // check whether all lanes are done
        if ((&lane_done) === 1'b0) begin
          `SYS.error;
          $display("-> %0t: ==> ERROR: auto train_dqs_gate runs into error", $time);
          $display("-> %0t: ==> ERROR: lane_done = %0h", $time, lane_done);
        end
        else begin
          $display("-> %0t: ==> auto train_dqs_gate SUCCESSFUL for rank %0d....", $time, rank_no);
          
        end
        
        // set dqs_pipe and lcdl values
        for (byte_i=0; byte_i<pNUM_LANES; byte_i=byte_i+1) begin

        // MIKE, need to update this for Share ac mode          
          dqs_pipe_i = ((fail_aft_pass[byte_i] + first_pass[byte_i])/2) / 256;

          for (chip_no=0; chip_no<no_of_chips; chip_no=chip_no+1) 
            `GRM.set_dqs_gate_pipeline(rank_no, chip_no, dqs_pipe_i);
           if (`DWC_DX_NO_OF_DQS == 1'd1)
             begin
                `GRM.dxnlcdlr2[rank_no][byte_i][ 7: 0] = (fail_aft_pass[byte_i] + first_pass[byte_i])/2;
                `CFG.write_register(`DX0LCDLR2+(`DX_REG_RANGE*byte_i), `GRM.dxnlcdlr2[rank_no][byte_i]);
                `FCOV_REG.set_cov_registers_write(`DX0LCDLR2+(`DX_REG_RANGE*byte_i), `GRM.dxnlcdlr2[rank_no][byte_i],`VALUE_REGISTER_DATA);
             end // if (`DWC_DX_NO_OF_DQS == 1'd1)
           else
             begin
                if (byte_i%2 == 0) // even numbers are nibble0
                  begin
                     `GRM.dxnlcdlr2[rank_no][byte_i/2][ 7: 0] = (fail_aft_pass[byte_i/2] + first_pass[byte_i/2])/2;
                     `CFG.write_register(`DX0LCDLR2+(`DX_REG_RANGE*(byte_i/2)), `GRM.dxnlcdlr2[rank_no][byte_i/2]);
                     `FCOV_REG.set_cov_registers_write(`DX0LCDLR2+(`DX_REG_RANGE*(byte_i)), `GRM.dxnlcdlr2[rank_no][byte_i/2],`VALUE_REGISTER_DATA);
                  end
                else //odd numbers are nibble1
                  begin
                     `GRM.dxnlcdlr2[rank_no][((byte_i-1)/2)][ 7: 0] = (fail_aft_pass[((byte_i-1)/2)] + first_pass[((byte_i-1)/2)])/2;
                     `CFG.write_register(`DX0LCDLR2+(`DX_REG_RANGE*((byte_i-1)/2)), `GRM.dxnlcdlr2[rank_no][((byte_i-1)/2)]);
                     `FCOV_REG.set_cov_registers_write(`DX0LCDLR2+(`DX_REG_RANGE*((byte_i-1)/2)), `GRM.dxnlcdlr2[rank_no][((byte_i-1)/2)],`VALUE_REGISTER_DATA);
                  end
             end 
        end

        `GRM.ch0_fifo_wrptr     = 0;
        `GRM.ch0_fifo_rdptr     = 0;
        `GRM.ch1_fifo_wrptr     = 0;
        `GRM.ch1_fifo_rdptr     = 0;
        `GRM.host_reads_txd = 0;
        `GRM.bl4_reads_txd  = 0; 

        // send refreshes at the end of each iteration
        `SYS.precharge_all(`ALL_RANKS);
        `SYS.refresh(`ALL_RANKS);
        `SYS.nops(`GRM.t_rfc);

      end // for (rank_no=0; rank_no <`DWC_NO_OF_RANKS; rank_no=rank_no+1)
      
      // Re enable the read counter
      `HOST.read_cnt_en = 1'b1;
      release `HOST_MNT.rd_burst_cnt;

`ifdef DWC_USE_SHARED_AC_TB
      `HOST1.read_cnt_en = 1'b1;
      release `HOST_MNT1.rd_burst_cnt;
`endif
       rdqs_training    = 1'b0;
      need_data_train   = 1'b0;

      // reset the RD FIFO's inside the PHY
      phy_fifo_reset;
      
    end
  endtask // auto_train_dqs_gate

  // MIKE, need to update this for share ac mode
  // compares the results (read data and tag or write tag) with the data in 
  // the GRM
/*
  always @(posedge clk or negedge rst_b) 
    begin: dqs_training_compare
      integer                    byte_i;
      integer                    word_i;
      integer                    cur_index;
      
      reg [`DATA_WIDTH-1:0]      grm_q;
      reg                        grm_ddr3_bl4;
      reg [`DATA_WIDTH-1:0]      tmp_grm_q;
      reg [`DATA_WIDTH-1:0]      tmp_q;

      reg [31:0]                 tmp_q_word;
      reg [31:0]                 tmp_grm_q_word;
      
      // compare the read data  with the values in GRM
      if (`HOST.qvld === 1'b1 && `SYS.scan_ms === 1'b0 && rdqs_training === 1'b1)
        begin
          cur_index = dqs_pipe_i*MAX_LCDL_VALUE + lcdl_i;
          
          `GRM.get_read_data(grm_q, grm_ddr3_bl4);
          tmp_grm_q = grm_q;
          tmp_q     = `HOST.q;
          if (verbose > 7) $display("-> %0t: ==>   grm_q = %0h",$time, grm_q);
          if (verbose > 7) $display("-> %0t: ==> `HOST.q = %0h",$time, `HOST.q);
          
          // compare read data output with expected value
          for (byte_i=0; byte_i<pNUM_LANES; byte_i= byte_i+1) begin

            tmp_q_word     = 32'h0;
            tmp_grm_q_word = 32'h0;

            for (word_i=0; word_i<4; word_i=word_i+1) begin
              tmp_q_word[31:24]     = tmp_q     >> (`DWC_NO_OF_BYTES*8*word_i) + (byte_i*8);
              tmp_grm_q_word[31:24] = tmp_grm_q >> (`DWC_NO_OF_BYTES*8*word_i) + (byte_i*8);

              if (word_i != 3) begin
                tmp_q_word     = tmp_q_word >> 8;
                tmp_grm_q_word = tmp_grm_q_word >> 8;
              end
            end
            
            if (lane_done[byte_i] == 1'b0) begin
              
              if ((tmp_q_word[31:0] === tmp_grm_q_word[31:0]) &&
                  (first_pass[byte_i] === {32{1'bx}})) begin
                // check to see if when flip_word is 0 that tmp_pass is PASSING,
                // if not, do not assign tmp_pass
                if ((flip_word == 1) && (tmp_pass[byte_i] == 1'b0))
                  tmp_pass[byte_i] = 1'b0;
                else    
                  tmp_pass[byte_i] = 1'b1;
                if (verbose > 7) $display("-> %0t: ==> tmp_pass[%0d] = %0b",$time, byte_i, tmp_pass[byte_i]);
              end
              else begin
                tmp_pass[byte_i] = 1'b0;
                if ((tmp_q_word[31:0] !== tmp_grm_q_word[31:0]) &&
                    (first_pass[byte_i] !== {32{1'bx}} )) begin

                  // first_pass might be in PASS state for three LCDL increments or more
                  // or else it will revert back to 32'bx
                  if (cur_index - first_pass[byte_i] < 3 *  LCDL_INC)
                    first_pass[byte_i] = {32{1'bx}};
                  else begin
                    // if first_pass is clean, then register the failure after the PASS
                    fail_aft_pass[byte_i] = dqs_pipe_i*MAX_LCDL_VALUE + lcdl_i;
                    lane_done [byte_i]  = 1'b1;
                    if (verbose > 7) $display("-> %0t: ==> fail_aft_pass[%0d] = %0h",$time, byte_i, fail_aft_pass[byte_i]);
                    if (verbose > 7) $display("-> %0t: ==> lane_done[%0d] = %0h",$time, byte_i, lane_done[byte_i]);
                  end
                end
                // either still looking for the first pass location or
                // looking for the failure after first pass 
                else begin
                  if (verbose > 7) begin
                    $display("-> %0t: ==> keep increment....",$time);
                    $display("-> %0t: ==> tmp_q_word     = %0h",$time, tmp_q_word);
                    $display("-> %0t: ==> tmp_grm_q_word = %0h",$time, tmp_grm_q_word);
                    $display("-> %0t: ==> byte_i         = %0d",$time, byte_i);
                    $display("-> %0t: ==> first_pass[%0d]    = %0h",$time, byte_i, first_pass[byte_i]);
                    $display("-> %0t: ==> fail_aft_pass[%0d] = %0h",$time, byte_i, fail_aft_pass[byte_i]);
                    $display("-> %0t: ==> lane_done[%0d]     = %0h",$time, byte_i, lane_done[byte_i]);
                  end
                end
              end
            end  // if (lane_done[byte_i] == 1'b0)
            
          end // for (byte_i=0; byte_i<pNUM_LANES; byte_i= byte_i+1)
           

          // now check to see if a burst length of 8 is expected, if so,
          // wait for the next clock and then verified q
          if ((`GRM.ddr3_blotf && (grm_ddr3_bl4 == 0)) || 
              (~`GRM.ddr3_blotf && (`GRM.ctrl_burst_len == 2))) begin
            if (verbose > 7) $display("-> %0t: ==> Burst length of 8 expected, continue....",$time);
            
            @(negedge clk);
            @(posedge clk);
            `GRM.get_read_data(grm_q, grm_ddr3_bl4);
            tmp_grm_q = grm_q;
            tmp_q     = `HOST.q;
            if (verbose > 7) $display("-> %0t: ==>   grm_q = %0h",$time, grm_q);
            if (verbose > 7) $display("-> %0t: ==> `HOST.q = %0h",$time, `HOST.q);
            
            // compare read data output with expected value
            for (byte_i=0; byte_i<pNUM_LANES; byte_i= byte_i+1) begin

              tmp_q_word     = 32'h0;
              tmp_grm_q_word = 32'h0;

              for (word_i=0; word_i<4; word_i=word_i+1) begin
                tmp_q_word[31:24]     = tmp_q     >> (`DWC_NO_OF_BYTES*8*word_i) + (byte_i*8);
                tmp_grm_q_word[31:24] = tmp_grm_q >> (`DWC_NO_OF_BYTES*8*word_i) + (byte_i*8);

                if (word_i != 3) begin
                  tmp_q_word     = tmp_q_word >> 8;
                  tmp_grm_q_word = tmp_grm_q_word >> 8;
                end
              end
              
              if (lane_done[byte_i] == 1'b0) begin
                
                if ((tmp_q_word[31:0] === tmp_grm_q_word[31:0]) &&
                    (first_pass[byte_i] === {32{1'bx}} )) begin
                  if ((tmp_pass[byte_i] === 1'b1) &&
                      (flip_word == 1)) begin
                    first_pass[byte_i] = dqs_pipe_i*MAX_LCDL_VALUE + lcdl_i;
                    lane_pass[byte_i]  = 1'b1;
                  end
                  if (verbose > 7) $display("-> %0t: ==> first_pass[%0d] = %0h",$time, byte_i, first_pass[byte_i]);
                end
                else begin
                  tmp_pass[byte_i] = 1'b0;
                  
                  if ((tmp_q_word[31:0] !== tmp_grm_q_word[31:0]) &&
                      (first_pass[byte_i] !== {32{1'bx}})) begin

                    // first_pass might be in PASS state for three LCDL increments or more
                    // or else it will revert back to 32'bx
                    if (cur_index - first_pass[byte_i] < 3 *  LCDL_INC) begin
                      first_pass[byte_i] = {32{1'bx}};
                      $display("-> %0t: ==> revert back to unknown first pass....",$time);
                      $display("-> %0t: ==> tmp_q_word     = %0h",$time, tmp_q_word);
                      $display("-> %0t: ==> tmp_grm_q_word = %0h",$time, tmp_grm_q_word);
                      $display("-> %0t: ==> byte_i         = %0d",$time, byte_i);
                      $display("-> %0t: ==> first_pass[%0d]    = %0h",$time, byte_i, first_pass[byte_i]);
                      $display("-> %0t: ==> fail_aft_pass[%0d] = %0h",$time, byte_i, fail_aft_pass[byte_i]);
                      $display("-> %0t: ==> lane_done[%0d]     = %0h",$time, byte_i, lane_done[byte_i]);
                    end  
                    else begin
                      // if first_pass is clean, then register the failure after the PASS
                      fail_aft_pass[byte_i] = dqs_pipe_i*MAX_LCDL_VALUE + lcdl_i;
                      lane_done [byte_i]  = 1'b1;
                      if (verbose > 7) $display("-> %0t: ==> fail_aft_pass[%0d] = %0h",$time, byte_i, fail_aft_pass[byte_i]);
                      if (verbose > 7) $display("-> %0t: ==> lane_done[%0d] = %0h",$time, byte_i, lane_done[byte_i]);
                    end
                  end
                  // either still looking for the first pass location or
                  // looking for the failure after first pass 
                  else begin
                    if (verbose > 7) begin
                      $display("-> %0t: ==> keep increment....",$time);
                      $display("-> %0t: ==> tmp_q_word     = %0h",$time, tmp_q_word);
                      $display("-> %0t: ==> tmp_grm_q_word = %0h",$time, tmp_grm_q_word);
                      $display("-> %0t: ==> byte_i         = %0d",$time, byte_i);
                      $display("-> %0t: ==> first_pass[%0d]    = %0h",$time, byte_i, first_pass[byte_i]);
                      $display("-> %0t: ==> fail_aft_pass[%0d] = %0h",$time, byte_i, fail_aft_pass[byte_i]);
                      $display("-> %0t: ==> lane_done[%0d]     = %0h",$time, byte_i, lane_done[byte_i]);
                    end
                  end
                end
              end  // if (lane_done[byte_i] == 1'b0)
              
            end // for (byte_i=0; byte_i<pNUM_LANES; byte_i= byte_i+1)
             
          end
          else begin
            // if (grm_ddr3_bl4 != 0)
            for (byte_i=0; byte_i<pNUM_LANES; byte_i= byte_i+1) begin
              if ((tmp_pass[byte_i] === 1'b1) && (flip_word == 1)) begin
                first_pass[byte_i] = dqs_pipe_i*MAX_LCDL_VALUE + lcdl_i;
                lane_pass[byte_i]  = 1'b1;
              end
            end
          end // else: !if(grm_ddr3_bl4 == 0)

        end // if (`HOST.qvld === 1'b1 && `SYS.scan_ms === 1'b0 && rdqs_training === 1'b1)
      
    end // block: dqs_training_compare
*/
`ifdef DWC_USE_SHARED_AC_TB
  // For Channel 0 compare
  // compares the results (read data and tag or write tag) with the data in 
  // the GRM
  always @(posedge clk or negedge rst_b) 
    begin: dqs_training_compare_chn0
      integer                    byte_i;
      integer                    word_i;
      integer                    cur_index;
      
      reg [`DATA_WIDTH-1:0]      grm_q;
      reg                        grm_ddr3_bl4;
      reg [`DATA_WIDTH-1:0]      tmp_grm_q;
      reg [`DATA_WIDTH-1:0]      tmp_q;

      reg [`DATA_WIDTH-1:0]      q_edata_word;
      reg [`DATA_WIDTH-1:0]      grm_q_edata_word;

      reg [31:0]                 tmp_q_word;
      reg [31:0]                 tmp_grm_q_word;
      
      integer                    i,j;

      // compare the read data for Channel 0 only  with the values in GRM
      if (`HOST.qvld === 1'b1 && `SYS.scan_ms === 1'b0 && rdqs_training === 1'b1)
        begin
          cur_index = dqs_pipe_i*MAX_LCDL_VALUE + lcdl_i;
          // treat the read data for channel 0 only
          `GRM.get_read_data(`SHARED_AC_CHN_0, grm_q, grm_ddr3_bl4);
          tmp_grm_q = grm_q;
          tmp_q     = `HOST.q;
          if (verbose > 7) $display("-> %0t: ==>   grm_q = %0h",$time, grm_q);
          if (verbose > 7) $display("-> %0t: ==> `HOST.q = %0h",$time, `HOST.q);
          
          q_edata_word     = {`DATA_WIDTH{1'h0}};
          grm_q_edata_word = {`DATA_WIDTH{1'h0}};
          tmp_q_word       = 32'h0;
          tmp_grm_q_word   = 32'h0;

          // screen the EDATA width on CH1 and temporary assign them
          for (j=0; j<`HOST_NX; j=j+1) begin
            for (i=0; i<`CH0_DWC_EDATA_WIDTH; i=i+1) begin
              q_edata_word    [j*`CH0_DWC_EDATA_WIDTH + i] = tmp_q    [j*`CH0_DATA_WIDTH + i];
              grm_q_edata_word[j*`CH0_DWC_EDATA_WIDTH + i] = tmp_grm_q[j*`CH0_DATA_WIDTH + i];
            end
          end          
          
          // compare read data output with expected value
          for (byte_i=0; byte_i<pCHN0_DX8_NUM; byte_i= byte_i+1) begin

            tmp_q_word     = 32'h0;
            tmp_grm_q_word = 32'h0;

            for (word_i=0; word_i<4; word_i=word_i+1) begin
              tmp_q_word[31:24]     = q_edata_word     >> (pCHN0_DX8_NUM*8*word_i) + (byte_i*8);
              tmp_grm_q_word[31:24] = grm_q_edata_word >> (pCHN0_DX8_NUM*8*word_i) + (byte_i*8);
            
              if (word_i != 3) begin
                tmp_q_word     = tmp_q_word >> 8;
                tmp_grm_q_word = tmp_grm_q_word >> 8;
              end
            end
  
            if (lane_done[byte_i] == 1'b0) begin
              
              if ((tmp_q_word[31:0] === tmp_grm_q_word[31:0]) &&
                  (first_pass[byte_i] === {32{1'bx}})) begin
                // check to see if when flip_word is 0 that tmp_pass is PASSING,
                // if not, do not assign tmp_pass
                if ((flip_word == 1) && (tmp_pass[byte_i] == 1'b0))
                  tmp_pass[byte_i] = 1'b0;
                else    
                  tmp_pass[byte_i] = 1'b1;
                if (verbose > 7) $display("-> %0t: ==> tmp_pass[%0d] = %0b",$time, byte_i, tmp_pass[byte_i]);
              end
              else begin
                tmp_pass[byte_i] = 1'b0;
                if ((tmp_q_word[31:0] !== tmp_grm_q_word[31:0]) &&
                    (first_pass[byte_i] !== {32{1'bx}} )) begin

                  // first_pass might be in PASS state for min of pMIN_LCDL_CNT LCDL increments or more
                  // or else it will revert back to 32'bx
                  if (cur_index - first_pass[byte_i] < pMIN_LCDL_CNT * LCDL_INC)
                    first_pass[byte_i] = {32{1'bx}};
                  else begin
                    // if first_pass is clean, then register the failure after the PASS
                    fail_aft_pass[byte_i] = dqs_pipe_i*MAX_LCDL_VALUE + lcdl_i;
                    lane_done [byte_i]  = 1'b1;
                    if (verbose > 7) $display("-> %0t: ==> fail_aft_pass[%0d] = %0h",$time, byte_i, fail_aft_pass[byte_i]);
                    if (verbose > 7) $display("-> %0t: ==> lane_done[%0d] = %0h",$time, byte_i, lane_done[byte_i]);
                  end
                end
                // either still looking for the first pass location or
                // looking for the failure after first pass 
                else begin
                  if (verbose > 7) begin
                    $display("-> %0t: ==> keep increment....",$time);
                    $display("-> %0t: ==> tmp_q_word     = %0h",$time, tmp_q_word);
                    $display("-> %0t: ==> tmp_grm_q_word = %0h",$time, tmp_grm_q_word);
                    $display("-> %0t: ==> byte_i         = %0d",$time, byte_i);
                    $display("-> %0t: ==> first_pass[%0d]    = %0h",$time, byte_i, first_pass[byte_i]);
                    $display("-> %0t: ==> fail_aft_pass[%0d] = %0h",$time, byte_i, fail_aft_pass[byte_i]);
                    $display("-> %0t: ==> lane_done[%0d]     = %0h",$time, byte_i, lane_done[byte_i]);
                  end
                end
              end
            end  // if (lane_done[byte_i] == 1'b0)
            
          end // for (byte_i=0; byte_i<pCHN0_DX8_NUM; byte_i= byte_i+1)

          // now check to see if a burst length of 8 is expected, if so,
          // wait for the next clock and then verified q
          if ((`GRM.ddr3_blotf && (grm_ddr3_bl4 == 0)) || 
              (~`GRM.ddr3_blotf && (`GRM.ctrl_burst_len == 2))) begin
            if (verbose > 7) $display("-> %0t: ==> Burst length of 8 expected, continue....",$time);
            
            @(negedge clk);
            @(posedge clk);
            // treat the read data for channel 0 only
            `GRM.get_read_data(`SHARED_AC_CHN_0, grm_q, grm_ddr3_bl4);

            tmp_grm_q = grm_q;
            tmp_q     = `HOST.q;
            if (verbose > 7) $display("-> %0t: ==>   grm_q = %0h",$time, grm_q);
            if (verbose > 7) $display("-> %0t: ==> `HOST.q = %0h",$time, `HOST.q);

            q_edata_word     = {`DATA_WIDTH{1'h0}};
            grm_q_edata_word = {`DATA_WIDTH{1'h0}};
            tmp_q_word       = 32'h0;
            tmp_grm_q_word   = 32'h0;

            // screen the EDATA width on CH1 and temporary assign them
            for (j=0; j<`HOST_NX; j=j+1) begin
              for (i=0; i<`CH0_DWC_EDATA_WIDTH; i=i+1) begin
                q_edata_word    [j*`CH0_DWC_EDATA_WIDTH + i] = tmp_q    [j*`CH0_DATA_WIDTH + i];
                grm_q_edata_word[j*`CH0_DWC_EDATA_WIDTH + i] = tmp_grm_q[j*`CH0_DATA_WIDTH + i];
              end
            end          
                        
            // compare read data output with expected value
            for (byte_i=0; byte_i<pCHN0_DX8_NUM; byte_i= byte_i+1) begin

              tmp_q_word     = 32'h0;
              tmp_grm_q_word = 32'h0;

              for (word_i=0; word_i<4; word_i=word_i+1) begin
                tmp_q_word[31:24]     = q_edata_word     >> (pCHN0_DX8_NUM*8*word_i) + (byte_i*8);
                tmp_grm_q_word[31:24] = grm_q_edata_word >> (pCHN0_DX8_NUM*8*word_i) + (byte_i*8);

                if (word_i != 3) begin
                  tmp_q_word     = tmp_q_word >> 8;
                  tmp_grm_q_word = tmp_grm_q_word >> 8;
                end
              end
              
              if (lane_done[byte_i] == 1'b0) begin
                
                if ((tmp_q_word[31:0] === tmp_grm_q_word[31:0]) &&
                    (first_pass[byte_i] === {32{1'bx}} )) begin
                  if ((tmp_pass[byte_i] === 1'b1) &&
                      (flip_word == 1)) begin
                    first_pass[byte_i] = dqs_pipe_i*MAX_LCDL_VALUE + lcdl_i;
                    lane_pass[byte_i]  = 1'b1;
                  end
                  if (verbose > 7) $display("-> %0t: ==> first_pass[%0d] = %0h",$time, byte_i, first_pass[byte_i]);
                end
                else begin
                  tmp_pass[byte_i] = 1'b0;
                  
                  if ((tmp_q_word[31:0] !== tmp_grm_q_word[31:0]) &&
                      (first_pass[byte_i] !== {32{1'bx}})) begin

                    // first_pass might be in PASS state for min of pMIN_LCDL_CNT LCDL increments or more
                    // or else it will revert back to 32'bx
                    if (cur_index - first_pass[byte_i] < pMIN_LCDL_CNT * LCDL_INC) begin
                      first_pass[byte_i] = {32{1'bx}};
                      $display("-> %0t: ==> revert back to unknown first pass....",$time);
                      $display("-> %0t: ==> tmp_q_word     = %0h",$time, tmp_q_word);
                      $display("-> %0t: ==> tmp_grm_q_word = %0h",$time, tmp_grm_q_word);
                      $display("-> %0t: ==> byte_i         = %0d",$time, byte_i);
                      $display("-> %0t: ==> first_pass[%0d]    = %0h",$time, byte_i, first_pass[byte_i]);
                      $display("-> %0t: ==> fail_aft_pass[%0d] = %0h",$time, byte_i, fail_aft_pass[byte_i]);
                      $display("-> %0t: ==> lane_done[%0d]     = %0h",$time, byte_i, lane_done[byte_i]);
                    end  
                    else begin
                      // if first_pass is clean, then register the failure after the PASS
                      fail_aft_pass[byte_i] = dqs_pipe_i*MAX_LCDL_VALUE + lcdl_i;
                      lane_done [byte_i]  = 1'b1;
                      if (verbose > 7) $display("-> %0t: ==> fail_aft_pass[%0d] = %0h",$time, byte_i, fail_aft_pass[byte_i]);
                      if (verbose > 7) $display("-> %0t: ==> lane_done[%0d] = %0h",$time, byte_i, lane_done[byte_i]);
                    end
                  end
                  // either still looking for the first pass location or
                  // looking for the failure after first pass 
                  else begin
                    if (verbose > 7) begin
                      $display("-> %0t: ==> keep increment....",$time);
                      $display("-> %0t: ==> tmp_q_word     = %0h",$time, tmp_q_word);
                      $display("-> %0t: ==> tmp_grm_q_word = %0h",$time, tmp_grm_q_word);
                      $display("-> %0t: ==> byte_i         = %0d",$time, byte_i);
                      $display("-> %0t: ==> first_pass[%0d]    = %0h",$time, byte_i, first_pass[byte_i]);
                      $display("-> %0t: ==> fail_aft_pass[%0d] = %0h",$time, byte_i, fail_aft_pass[byte_i]);
                      $display("-> %0t: ==> lane_done[%0d]     = %0h",$time, byte_i, lane_done[byte_i]);
                    end
                  end
                end
              end  // if (lane_done[byte_i] == 1'b0)
              
            end // for (byte_i=0; byte_i<pCHN0_DX8_NUM; byte_i= byte_i+1)
          end
          else begin
            // if (grm_ddr3_bl4 != 0)
            for (byte_i=0; byte_i<`DWC_NO_OF_BYTES; byte_i= byte_i+1) begin
              if ((tmp_pass[byte_i] === 1'b1) && (flip_word == 1)) begin
                first_pass[byte_i] = dqs_pipe_i*MAX_LCDL_VALUE + lcdl_i;
                lane_pass[byte_i]  = 1'b1;
              end
            end
          end // else: !if(grm_ddr3_bl4 == 0)

        end // if (`HOST.qvld === 1'b1 && `SYS.scan_ms === 1'b0 && rdqs_training === 1'b1)
      
    end // block: dqs_training_compare_chn0

  // For Channel 1 Compare
  // compares the results (read data and tag or write tag) with the data in 
  // the GRM
  always @(posedge clk or negedge rst_b) 
    begin: dqs_training_compare_chn1
      integer                    byte_i;
      integer                    word_i;
      integer                    cur_index;
      
      reg [`DATA_WIDTH-1:0]      grm_q;
      reg                        grm_ddr3_bl4;
      reg [`DATA_WIDTH-1:0]      tmp_grm_q;
      reg [`DATA_WIDTH-1:0]      tmp_q;

      reg [`DATA_WIDTH-1:0]      q_edata_word;
      reg [`DATA_WIDTH-1:0]      grm_q_edata_word;

      reg [31:0]                 tmp_q_word;
      reg [31:0]                 tmp_grm_q_word;

      integer                    i,j;
      
      // compare the read data for Channel 0 only  with the values in GRM
      if (`HOST1.qvld === 1'b1 && `SYS.scan_ms === 1'b0 && rdqs_training === 1'b1)
        begin
          cur_index = dqs_pipe_i*MAX_LCDL_VALUE + lcdl_i;
          // treat the read data for channel 1 only
          `GRM.get_read_data(`SHARED_AC_CHN_1, grm_q, grm_ddr3_bl4);
          tmp_grm_q = grm_q;
          tmp_q     = `HOST1.q;
          if (verbose > 7) $display("-> %0t: ==>   grm_q = %0h",$time, grm_q);
          if (verbose > 7) $display("-> %0t: ==> `HOST1.q = %0h",$time, `HOST1.q);

          q_edata_word     = {`DATA_WIDTH{1'h0}};
          grm_q_edata_word = {`DATA_WIDTH{1'h0}};
          tmp_q_word       = 32'h0;
          tmp_grm_q_word   = 32'h0;

          // screen the EDATA width on CH1 and temporary assign them
          for (j=0; j<`HOST_NX; j=j+1) begin
            for (i=0; i<`CH1_DWC_EDATA_WIDTH; i=i+1) begin
              q_edata_word    [j*`CH1_DWC_EDATA_WIDTH + i] = tmp_q    [j*`CH1_DATA_WIDTH + i];
              grm_q_edata_word[j*`CH1_DWC_EDATA_WIDTH + i] = tmp_grm_q[j*`CH1_DATA_WIDTH + i];
            end
          end          

          // compare read data output with expected value
          for (byte_i=0; byte_i<pCHN1_DX8_NUM; byte_i= byte_i+1) begin

            tmp_q_word     = 32'h0;
            tmp_grm_q_word = 32'h0;

            for (word_i=0; word_i<4; word_i=word_i+1) begin
              tmp_q_word[31:24]     = q_edata_word     >> (pCHN1_DX8_NUM*8*word_i) + (byte_i*8);
              tmp_grm_q_word[31:24] = grm_q_edata_word >> (pCHN1_DX8_NUM*8*word_i) + (byte_i*8);
            
              if (word_i != 3) begin
                tmp_q_word     = tmp_q_word >> 8;
                tmp_grm_q_word = tmp_grm_q_word >> 8;
              end
            end
            
            // the actual lane_done is the upper half of the byte width
            if (lane_done[byte_i+pCHN0_DX8_NUM] == 1'b0) begin
              
              if ((tmp_q_word[31:0] === tmp_grm_q_word[31:0]) &&
                  (first_pass[byte_i] === {32{1'bx}})) begin
                // check to see if when flip_word is 0 that tmp_pass is PASSING,
                // if not, do not assign tmp_pass
                if ((flip_word == 1) && (tmp_pass[byte_i] == 1'b0))
                  tmp_pass[byte_i] = 1'b0;
                else    
                  tmp_pass[byte_i] = 1'b1;
                if (verbose > 7) $display("-> %0t: ==> tmp_pass[%0d] = %0b",$time, byte_i, tmp_pass[byte_i]);
              end
              else begin
                tmp_pass[byte_i] = 1'b0;
                if ((tmp_q_word[31:0] !== tmp_grm_q_word[31:0]) &&
                    (first_pass[byte_i] !== {32{1'bx}} )) begin

                  // first_pass might be in PASS state for min of pMIN_LCDL_CNT LCDL increments or more
                  // or else it will revert back to 32'bx
                  if (cur_index - first_pass[byte_i] < pMIN_LCDL_CNT * LCDL_INC)
                    first_pass[byte_i] = {32{1'bx}};
                  else begin
                    // if first_pass is clean, then register the failure after the PASS
                    fail_aft_pass[byte_i] = dqs_pipe_i*MAX_LCDL_VALUE + lcdl_i;
                    lane_done [byte_i+pCHN0_DX8_NUM]  = 1'b1;
                    if (verbose > 7) $display("-> %0t: ==> fail_aft_pass[%0d] = %0h",$time, byte_i, fail_aft_pass[byte_i]);
                    if (verbose > 7) $display("-> %0t: ==> lane_done[%0d] = %0h",$time, byte_i, lane_done[byte_i+pCHN0_DX8_NUM]);
                  end
                end
                // either still looking for the first pass location or
                // looking for the failure after first pass 
                else begin
                  if (verbose > 7) begin
                    $display("-> %0t: ==> keep increment....",$time);
                    $display("-> %0t: ==> tmp_q_word     = %0h",$time, tmp_q_word);
                    $display("-> %0t: ==> tmp_grm_q_word = %0h",$time, tmp_grm_q_word);
                    $display("-> %0t: ==> byte_i         = %0d",$time, byte_i);
                    $display("-> %0t: ==> first_pass[%0d]    = %0h",$time, byte_i, first_pass[byte_i]);
                    $display("-> %0t: ==> fail_aft_pass[%0d] = %0h",$time, byte_i, fail_aft_pass[byte_i]);
                    $display("-> %0t: ==> lane_done[%0d]     = %0h",$time, byte_i, lane_done[byte_i+pCHN0_DX8_NUM]);
                  end
                end
              end
            end  // if (lane_done[byte_i+pCHN0_DX8_NUM] == 1'b0)
            
          end // for (byte_i=0; byte_i<pCHN1_DX8_NUM; byte_i= byte_i+1)

          // now check to see if a burst length of 8 is expected, if so,
          // wait for the next clock and then verified q
          if ((`GRM.ddr3_blotf && (grm_ddr3_bl4 == 0)) || 
              (~`GRM.ddr3_blotf && (`GRM.ctrl_burst_len == 2))) begin
            if (verbose > 7) $display("-> %0t: ==> Burst length of 8 expected, continue....",$time);
            
            @(negedge clk);
            @(posedge clk);
            // treat the read data for channel 1 only
            `GRM.get_read_data(`SHARED_AC_CHN_1, grm_q, grm_ddr3_bl4);

            tmp_grm_q = grm_q;
            tmp_q     = `HOST1.q;
            if (verbose > 7) $display("-> %0t: ==>   grm_q = %0h",$time, grm_q);
            if (verbose > 7) $display("-> %0t: ==> `HOST1.q = %0h",$time, `HOST1.q);

            q_edata_word     = {`DATA_WIDTH{1'h0}};
            grm_q_edata_word = {`DATA_WIDTH{1'h0}};
            tmp_q_word       = 32'h0;
            tmp_grm_q_word   = 32'h0;
            
            // screen the EDATA width on CH1 and temporary assign them
            for (j=0; j<`HOST_NX; j=j+1) begin
              for (i=0; i<`CH1_DWC_EDATA_WIDTH; i=i+1) begin
                q_edata_word    [j*`CH1_DWC_EDATA_WIDTH + i] = tmp_q    [j*`CH1_DATA_WIDTH + i];
                grm_q_edata_word[j*`CH1_DWC_EDATA_WIDTH + i] = tmp_grm_q[j*`CH1_DATA_WIDTH + i];
              end
            end 
            
            // compare read data output with expected value
            for (byte_i=0; byte_i<pCHN1_DX8_NUM; byte_i= byte_i+1) begin

              tmp_q_word     = 32'h0;
              tmp_grm_q_word = 32'h0;

              for (word_i=0; word_i<4; word_i=word_i+1) begin
                tmp_q_word[31:24]     = q_edata_word     >> (pCHN1_DX8_NUM*8*word_i) + (byte_i*8);
                tmp_grm_q_word[31:24] = grm_q_edata_word >> (pCHN1_DX8_NUM*8*word_i) + (byte_i*8);

                if (word_i != 3) begin
                  tmp_q_word     = tmp_q_word >> 8;
                  tmp_grm_q_word = tmp_grm_q_word >> 8;
                end
              end
              
              if (lane_done[byte_i+pCHN0_DX8_NUM] == 1'b0) begin
                
                if ((tmp_q_word[31:0] === tmp_grm_q_word[31:0]) &&
                    (first_pass[byte_i] === {32{1'bx}} )) begin
                  if ((tmp_pass[byte_i] === 1'b1) &&
                      (flip_word == 1)) begin
                    first_pass[byte_i] = dqs_pipe_i*MAX_LCDL_VALUE + lcdl_i;
                    lane_pass[byte_i+pCHN0_DX8_NUM]  = 1'b1;
                  end
                  if (verbose > 7) $display("-> %0t: ==> first_pass[%0d] = %0h",$time, byte_i, first_pass[byte_i]);
                end
                else begin
                  tmp_pass[byte_i] = 1'b0;
                  
                  if ((tmp_q_word[31:0] !== tmp_grm_q_word[31:0]) &&
                      (first_pass[byte_i] !== {32{1'bx}})) begin

                    // first_pass might be in PASS state for min of pMIN_LCDL_CNT LCDL increments or more
                    // or else it will revert back to 32'bx
                    if (cur_index - first_pass[byte_i] < pMIN_LCDL_CNT * LCDL_INC) begin
                      first_pass[byte_i] = {32{1'bx}};
                      $display("-> %0t: ==> revert back to unknown first pass....",$time);
                      $display("-> %0t: ==> tmp_q_word     = %0h",$time, tmp_q_word);
                      $display("-> %0t: ==> tmp_grm_q_word = %0h",$time, tmp_grm_q_word);
                      $display("-> %0t: ==> byte_i         = %0d",$time, byte_i);
                      $display("-> %0t: ==> first_pass[%0d]    = %0h",$time, byte_i, first_pass[byte_i]);
                      $display("-> %0t: ==> fail_aft_pass[%0d] = %0h",$time, byte_i, fail_aft_pass[byte_i]);
                      $display("-> %0t: ==> lane_done[%0d]     = %0h",$time, byte_i, lane_done[byte_i+pCHN0_DX8_NUM]);
                    end  
                    else begin
                      // if first_pass is clean, then register the failure after the PASS
                      fail_aft_pass[byte_i] = dqs_pipe_i*MAX_LCDL_VALUE + lcdl_i;
                      lane_done [byte_i+pCHN0_DX8_NUM]  = 1'b1;
                      if (verbose > 7) $display("-> %0t: ==> fail_aft_pass[%0d] = %0h",$time, byte_i, fail_aft_pass[byte_i]);
                      if (verbose > 7) $display("-> %0t: ==> lane_done[%0d] = %0h",$time, byte_i, lane_done[byte_i+pCHN0_DX8_NUM]);
                    end
                  end
                  // either still looking for the first pass location or
                  // looking for the failure after first pass 
                  else begin
                    if (verbose > 7) begin
                      $display("-> %0t: ==> keep increment....",$time);
                      $display("-> %0t: ==> tmp_q_word     = %0h",$time, tmp_q_word);
                      $display("-> %0t: ==> tmp_grm_q_word = %0h",$time, tmp_grm_q_word);
                      $display("-> %0t: ==> byte_i         = %0d",$time, byte_i);
                      $display("-> %0t: ==> first_pass[%0d]    = %0h",$time, byte_i, first_pass[byte_i]);
                      $display("-> %0t: ==> fail_aft_pass[%0d] = %0h",$time, byte_i, fail_aft_pass[byte_i]);
                      $display("-> %0t: ==> lane_done[%0d]     = %0h",$time, byte_i, lane_done[byte_i+pCHN0_DX8_NUM]);
                    end
                  end
                end
              end  // if (lane_done[byte_i+pCHN0_DX8_NUM] == 1'b0)
              
            end // for (byte_i=0; byte_i<pCHN1_DX8_NUM; byte_i= byte_i+1)
          end
          else begin
            // if (grm_ddr3_bl4 != 0)
            for (byte_i=0; byte_i<`DWC_NO_OF_BYTES; byte_i= byte_i+1) begin
              if ((tmp_pass[byte_i] === 1'b1) && (flip_word == 1)) begin
                first_pass[byte_i] = dqs_pipe_i*MAX_LCDL_VALUE + lcdl_i;
                lane_pass[byte_i+pCHN0_DX8_NUM]  = 1'b1;
              end
            end
          end // else: !if(grm_ddr3_bl4 == 0)

        end // if (`HOST1.qvld === 1'b1 && `SYS.scan_ms === 1'b0 && rdqs_training === 1'b1)
      
    end // block: dqs_training_compare_chn1
`else
  // compares the results (read data and tag or write tag) with the data in 
  // the GRM
  always @(posedge clk or negedge rst_b) 
    begin: dqs_training_compare_chn0_non_shared_AC
      integer                    byte_i;
      integer                    word_i;
      integer                    cur_index;
      
      reg [`DATA_WIDTH-1:0]      grm_q;
      reg                        grm_ddr3_bl4;
      reg [`DATA_WIDTH-1:0]      tmp_grm_q;
      reg [`DATA_WIDTH-1:0]      tmp_q;

      reg [`DATA_WIDTH-1:0]      q_edata_word;
      reg [`DATA_WIDTH-1:0]      grm_q_edata_word;

      reg [31:0]                 tmp_q_word;
      reg [31:0]                 tmp_grm_q_word;

      integer                    i,j;
      
      // compare the read data  with the values in GRM
      if (`HOST.qvld === 1'b1 && `SYS.scan_ms === 1'b0 && rdqs_training === 1'b1)
        begin
          cur_index = dqs_pipe_i*MAX_LCDL_VALUE + lcdl_i;
          
          // treat the read data as if it were non-shared AC and compare the whole data width
          `GRM.get_read_data(`NON_SHARED_AC, grm_q, grm_ddr3_bl4);
          tmp_grm_q = grm_q;
          tmp_q     = `HOST.q;
          if (verbose > 7) $display("-> %0t: ==>   grm_q = %0h",$time, grm_q);
          if (verbose > 7) $display("-> %0t: ==> `HOST.q = %0h",$time, `HOST.q);
          

          q_edata_word     = {`DATA_WIDTH{1'h0}};
          grm_q_edata_word = {`DATA_WIDTH{1'h0}};
          tmp_q_word       = 32'h0;
          tmp_grm_q_word   = 32'h0;

          // screen the EDATA width on CH1 and temporary assign them
          for (j=0; j<`HOST_NX; j=j+1) begin
            for (i=0; i<`CH0_DWC_EDATA_WIDTH; i=i+1) begin
              q_edata_word    [j*`CH0_DWC_EDATA_WIDTH + i] = tmp_q    [j*`CH0_DATA_WIDTH + i];
              grm_q_edata_word[j*`CH0_DWC_EDATA_WIDTH + i] = tmp_grm_q[j*`CH0_DATA_WIDTH + i];
            end
          end          

          // compare read data output with expected value
          for (byte_i=0; byte_i<`DWC_NO_OF_BYTES; byte_i= byte_i+1) begin

            tmp_q_word     = 32'h0;
            tmp_grm_q_word = 32'h0;

            for (word_i=0; word_i<4; word_i=word_i+1) begin
              tmp_q_word[31:24]     = q_edata_word     >> (`DWC_NO_OF_BYTES*8*word_i) + (byte_i*8);
              tmp_grm_q_word[31:24] = grm_q_edata_word >> (`DWC_NO_OF_BYTES*8*word_i) + (byte_i*8);

              if (word_i != 3) begin
                tmp_q_word     = tmp_q_word >> 8;
                tmp_grm_q_word = tmp_grm_q_word >> 8;
              end
            end
            
            if (lane_done[byte_i] == 1'b0) begin
              
              if ((tmp_q_word[31:0] === tmp_grm_q_word[31:0]) &&
                  (first_pass[byte_i] === {32{1'bx}})) begin
                // check to see if when flip_word is 0 that tmp_pass is PASSING,
                // if not, do not assign tmp_pass
                if ((flip_word == 1) && (tmp_pass[byte_i] == 1'b0))
                  tmp_pass[byte_i] = 1'b0;
                else    
                  tmp_pass[byte_i] = 1'b1;
                if (verbose > 7) $display("-> %0t: ==> tmp_pass[%0d] = %0b",$time, byte_i, tmp_pass[byte_i]);
              end
              else begin
                tmp_pass[byte_i] = 1'b0;
                if ((tmp_q_word[31:0] !== tmp_grm_q_word[31:0]) &&
                    (first_pass[byte_i] !== {32{1'bx}} )) begin

                  // first_pass might be in PASS state for three LCDL increments or more
                  // or else it will revert back to 32'bx
                  if (cur_index - first_pass[byte_i] < 3 *  LCDL_INC)
                    first_pass[byte_i] = {32{1'bx}};
                  else begin
                    // if first_pass is clean, then register the failure after the PASS
                    fail_aft_pass[byte_i] = dqs_pipe_i*MAX_LCDL_VALUE + lcdl_i;
                    lane_done [byte_i]  = 1'b1;
                    if (verbose > 7) $display("-> %0t: ==> fail_aft_pass[%0d] = %0h",$time, byte_i, fail_aft_pass[byte_i]);
                    if (verbose > 7) $display("-> %0t: ==> lane_done[%0d] = %0h",$time, byte_i, lane_done[byte_i]);
                  end
                end
                // either still looking for the first pass location or
                // looking for the failure after first pass 
                else begin
                  if (verbose > 7) begin
                    $display("-> %0t: ==> keep increment....",$time);
                    $display("-> %0t: ==> tmp_q_word     = %0h",$time, tmp_q_word);
                    $display("-> %0t: ==> tmp_grm_q_word = %0h",$time, tmp_grm_q_word);
                    $display("-> %0t: ==> byte_i         = %0d",$time, byte_i);
                    $display("-> %0t: ==> first_pass[%0d]    = %0h",$time, byte_i, first_pass[byte_i]);
                    $display("-> %0t: ==> fail_aft_pass[%0d] = %0h",$time, byte_i, fail_aft_pass[byte_i]);
                    $display("-> %0t: ==> lane_done[%0d]     = %0h",$time, byte_i, lane_done[byte_i]);
                  end
                end
              end
            end  // if (lane_done[byte_i] == 1'b0)
            
          end // for (byte_i=0; byte_i<`DWC_NO_OF_BYTES; byte_i= byte_i+1)

          // now check to see if a burst length of 8 is expected, if so,
          // wait for the next clock and then verified q
          if ((`GRM.ddr3_blotf && (grm_ddr3_bl4 == 0)) || 
              (~`GRM.ddr3_blotf && (`GRM.ctrl_burst_len == 2))) begin
            if (verbose > 7) $display("-> %0t: ==> Burst length of 8 expected, continue....",$time);
            
            @(negedge clk);
            @(posedge clk);
            // treat the read data as if it were non-shared AC and compare the whole data width
            `GRM.get_read_data(`NON_SHARED_AC, grm_q, grm_ddr3_bl4);
            tmp_grm_q = grm_q;
            tmp_q     = `HOST.q;
            if (verbose > 7) $display("-> %0t: ==>   grm_q = %0h",$time, grm_q);
            if (verbose > 7) $display("-> %0t: ==> `HOST.q = %0h",$time, `HOST.q);

            q_edata_word     = {`DATA_WIDTH{1'h0}};
            grm_q_edata_word = {`DATA_WIDTH{1'h0}};
            tmp_q_word       = 32'h0;
            tmp_grm_q_word   = 32'h0;

            // screen the EDATA width on CH1 and temporary assign them
            for (j=0; j<`HOST_NX; j=j+1) begin
              for (i=0; i<`CH0_DWC_EDATA_WIDTH; i=i+1) begin
                q_edata_word    [j*`CH0_DWC_EDATA_WIDTH + i] = tmp_q    [j*`CH0_DATA_WIDTH + i];
                grm_q_edata_word[j*`CH0_DWC_EDATA_WIDTH + i] = tmp_grm_q[j*`CH0_DATA_WIDTH + i];
              end
            end          

            // compare read data output with expected value
            for (byte_i=0; byte_i<`DWC_NO_OF_BYTES; byte_i= byte_i+1) begin

              tmp_q_word     = 32'h0;
              tmp_grm_q_word = 32'h0;

              for (word_i=0; word_i<4; word_i=word_i+1) begin
                tmp_q_word[31:24]     = q_edata_word     >> (`DWC_NO_OF_BYTES*8*word_i) + (byte_i*8);
                tmp_grm_q_word[31:24] = grm_q_edata_word >> (`DWC_NO_OF_BYTES*8*word_i) + (byte_i*8);

                if (word_i != 3) begin
                  tmp_q_word     = tmp_q_word >> 8;
                  tmp_grm_q_word = tmp_grm_q_word >> 8;
                end
              end
              
              if (lane_done[byte_i] == 1'b0) begin
                
                if ((tmp_q_word[31:0] === tmp_grm_q_word[31:0]) &&
                    (first_pass[byte_i] === {32{1'bx}} )) begin
                  if ((tmp_pass[byte_i] === 1'b1) &&
                      (flip_word == 1)) begin
                    first_pass[byte_i] = dqs_pipe_i*MAX_LCDL_VALUE + lcdl_i;
                    lane_pass[byte_i]  = 1'b1;
                  end
                  if (verbose > 7) $display("-> %0t: ==> first_pass[%0d] = %0h",$time, byte_i, first_pass[byte_i]);
                end
                else begin
                  tmp_pass[byte_i] = 1'b0;
                  
                  if ((tmp_q_word[31:0] !== tmp_grm_q_word[31:0]) &&
                      (first_pass[byte_i] !== {32{1'bx}})) begin

                    // first_pass might be in PASS state for three LCDL increments or more
                    // or else it will revert back to 32'bx
                    if (cur_index - first_pass[byte_i] < 3 *  LCDL_INC) begin
                      first_pass[byte_i] = {32{1'bx}};
                      $display("-> %0t: ==> revert back to unknown first pass....",$time);
                      $display("-> %0t: ==> tmp_q_word     = %0h",$time, tmp_q_word);
                      $display("-> %0t: ==> tmp_grm_q_word = %0h",$time, tmp_grm_q_word);
                      $display("-> %0t: ==> byte_i         = %0d",$time, byte_i);
                      $display("-> %0t: ==> first_pass[%0d]    = %0h",$time, byte_i, first_pass[byte_i]);
                      $display("-> %0t: ==> fail_aft_pass[%0d] = %0h",$time, byte_i, fail_aft_pass[byte_i]);
                      $display("-> %0t: ==> lane_done[%0d]     = %0h",$time, byte_i, lane_done[byte_i]);
                    end  
                    else begin
                      // if first_pass is clean, then register the failure after the PASS
                      fail_aft_pass[byte_i] = dqs_pipe_i*MAX_LCDL_VALUE + lcdl_i;
                      lane_done [byte_i]  = 1'b1;
                      if (verbose > 7) $display("-> %0t: ==> fail_aft_pass[%0d] = %0h",$time, byte_i, fail_aft_pass[byte_i]);
                      if (verbose > 7) $display("-> %0t: ==> lane_done[%0d] = %0h",$time, byte_i, lane_done[byte_i]);
                    end
                  end
                  // either still looking for the first pass location or
                  // looking for the failure after first pass 
                  else begin
                    if (verbose > 7) begin
                      $display("-> %0t: ==> keep increment....",$time);
                      $display("-> %0t: ==> tmp_q_word     = %0h",$time, tmp_q_word);
                      $display("-> %0t: ==> tmp_grm_q_word = %0h",$time, tmp_grm_q_word);
                      $display("-> %0t: ==> byte_i         = %0d",$time, byte_i);
                      $display("-> %0t: ==> first_pass[%0d]    = %0h",$time, byte_i, first_pass[byte_i]);
                      $display("-> %0t: ==> fail_aft_pass[%0d] = %0h",$time, byte_i, fail_aft_pass[byte_i]);
                      $display("-> %0t: ==> lane_done[%0d]     = %0h",$time, byte_i, lane_done[byte_i]);
                    end
                  end
                end
              end  // if (lane_done[byte_i] == 1'b0)
              
            end // for (byte_i=0; byte_i<`DWC_NO_OF_BYTES; byte_i= byte_i+1)
          end
          else begin
            // if (grm_ddr3_bl4 != 0)
            for (byte_i=0; byte_i<`DWC_NO_OF_BYTES; byte_i= byte_i+1) begin
              if ((tmp_pass[byte_i] === 1'b1) && (flip_word == 1)) begin
                first_pass[byte_i] = dqs_pipe_i*MAX_LCDL_VALUE + lcdl_i;
                lane_pass[byte_i]  = 1'b1;
              end
            end
          end // else: !if(grm_ddr3_bl4 == 0)

        end // if (`HOST.qvld === 1'b1 && `SYS.scan_ms === 1'b0 && rdqs_training === 1'b1)
      
    end // block: dqs_training_compare_chn0_non_shared_AC
`endif
  

  task t_print_train_dqs_info;
    integer  i;
    begin
      for (i=0;i<`DWC_NO_OF_BYTES;i=i+1)
        $display("-> %0t: ==> first_pass[%0d] = %0h",$time, i, first_pass[i]);

      for (i=0;i<`DWC_NO_OF_BYTES;i=i+1)
        $display("-> %0t: ==> fail_aft_pass[%0d] = %0h",$time, i, fail_aft_pass[i]);

      for (i=0;i<`DWC_NO_OF_BYTES;i=i+1)
        $display("-> %0t: ==> lane_done[%0d] = %0h",$time, i, lane_done[i]);

    end
  endtask // t_print_train_dqs_info

  
  //  inserting BDL Delay
  // --------------------
  task train_ac_bdl_reg;
  input           reg_rand;
  input reg [`BDL_DLY_WIDTH-1:0] pattern;
  input reg [`BDL_DLY_WIDTH-1:0] mask;
  
  integer     i, jreg;
  reg [`REG_ADDR_WIDTH:0] reg_addr;
  reg [`REG_DATA_WIDTH:0] reg_data;
  begin
    // write a value to the AC BDL registers
    $display("SYSTEM: INSERTING RANDOM VALUE TO ACBDLR REGISTER");

    // Start from ACBDL1 instead of ACBDL0. ACBDLR0 is for CK BDL's.
    // For Gen2MPHY, the usage model is to never program CK BDL's to
    // non zero values.
    reg_addr = `ACBDLR1;

    reg_data[31:0] = 32'h0;

    for(i=0;i<10;i=i+1)
    begin
      @(negedge `CFG.clk);
      if (reg_rand) begin
        reg_data[24 +: `BDL_DLY_WIDTH-1] = $random & {`BDL_DLY_WIDTH{1'b1}} & mask;
        reg_data[16 +: `BDL_DLY_WIDTH-1] = $random & {`BDL_DLY_WIDTH{1'b1}} & mask;
        reg_data[ 8 +: `BDL_DLY_WIDTH-1] = $random & {`BDL_DLY_WIDTH{1'b1}} & mask;
        reg_data[ 0 +: `BDL_DLY_WIDTH-1] = $random & {`BDL_DLY_WIDTH{1'b1}} & mask;
      end
      else begin
        reg_data[24 +: `BDL_DLY_WIDTH-1] = pattern & {`BDL_DLY_WIDTH{1'b1}};
        reg_data[16 +: `BDL_DLY_WIDTH-1] = pattern & {`BDL_DLY_WIDTH{1'b1}};
        reg_data[ 8 +: `BDL_DLY_WIDTH-1] = pattern & {`BDL_DLY_WIDTH{1'b1}};
        reg_data[ 0 +: `BDL_DLY_WIDTH-1] = pattern & {`BDL_DLY_WIDTH{1'b1}};
      end

      @(posedge `CFG.clk);
      `CFG.write_register((reg_addr+i), reg_data);
      `FCOV_REG.set_cov_registers_write(reg_addr, reg_data,`VALUE_REGISTER_DATA);
    end 
  end
  
  endtask // train_ac_bdl_reg
      

  task train_dx_bdl_reg;
    input       reg_rand;
    input reg [`BDL_DLY_WIDTH-1:0] pattern;
    
    integer     i, jreg;
    reg [`REG_ADDR_WIDTH:0] reg_addr;
    reg [`REG_DATA_WIDTH:0] reg_data;
    begin
      // write a value to the DX BDL registers
      $display("SYSTEM: INSERTING RANDOM VALUE TO DXnBDLR REGISTERs");
      for (jreg=0;jreg<12;jreg=jreg+1) begin
        // address for dxnbdlr3 and dxnbldr6 has gaps
        if (jreg==3 || jreg==7)
         jreg = jreg + 1;
        
        reg_addr = `DX0BDLR0 + jreg;
         
        for (i=0; i<`DWC_NO_OF_BYTES; i=i+1)
          begin
            reg_data[31:0] = 32'h0;
            @(negedge `CFG.clk);
            if (reg_rand) begin
              reg_data[24 +: `BDL_DLY_WIDTH-1] = $random & {`BDL_DLY_WIDTH{1'b1}};
              reg_data[16 +: `BDL_DLY_WIDTH-1] = $random & {`BDL_DLY_WIDTH{1'b1}};
              reg_data[ 8 +: `BDL_DLY_WIDTH-1] = $random & {`BDL_DLY_WIDTH{1'b1}};
              reg_data[ 0 +: `BDL_DLY_WIDTH-1] = $random & {`BDL_DLY_WIDTH{1'b1}};
            end
            else begin
              reg_data[24 +: `BDL_DLY_WIDTH-1] = pattern & {`BDL_DLY_WIDTH{1'b1}};
              reg_data[16 +: `BDL_DLY_WIDTH-1] = pattern & {`BDL_DLY_WIDTH{1'b1}};
              reg_data[ 8 +: `BDL_DLY_WIDTH-1] = pattern & {`BDL_DLY_WIDTH{1'b1}};
              reg_data[ 0 +: `BDL_DLY_WIDTH-1] = pattern & {`BDL_DLY_WIDTH{1'b1}};
            end
            
            @(posedge `CFG.clk);
            `CFG.write_register(reg_addr, reg_data);
            `FCOV_REG.set_cov_registers_write(reg_addr, reg_data,`VALUE_REGISTER_DATA);
            reg_addr = reg_addr + `DX_REG_RANGE;
          end
      end
      
    end
  endtask   

  // write leveling
  // --------------
  // triggers write leveling and waits for it to finish
  task write_level;
    input [31:0]              no_of_ranks;
    reg [pNO_OF_LRANKS -1:0]  rank_en;
    begin
      rank_en = (2**no_of_ranks) - 1;
      write_level_selected_ranks(rank_en);
    end
  endtask // write_level

  // write level selected ranks - any rank can be selected
  task write_level_selected_ranks;
    input [pNO_OF_LRANKS -1:0] rank_en;

    reg [`REG_ADDR_WIDTH  -1:0] reg_addr;
    reg [`REG_DATA_WIDTH  -1:0] reg_data;
    reg [pNO_OF_LRANKS -1:0]    wlrken;
    reg [pNO_OF_LRANKS -1:0]    wlrken_chn;
    integer byte_no, rank_no;
    integer k, i;
    real    tmp_0, tmp_1;
    
    begin
      
`ifdef DDR2
      // no write leveling for DDR2
`elsif LPDDR2
      // no write leveling for LPDDR2
`else

      // configure rank for write leveling
      
      `GRM.dtcr1[31:16] = rank_en;

      // disable a rank if it is not available for train for RDIMM_SINGLE_RANK or run dualcs in a rdimm_quad_rank scenario
`ifdef RDIMM_SINGLE_RANK
  `ifdef RDIMM_DUAL_RANK 
      // For RDIMM_SINGLE_RANK, there is only 1 rank per DIMM.
      // to setup for 1 rank  only, use runtc option ranks=2 and turn on RANKEN only for the even rank; one DIMM device
      // to setup for 2 ranks only, use runtc option ranks=4 and turn on RANKEN only for the even rank; two DIMM device
      for (i=0; i<`DWC_NO_OF_LRANKS; i=i+1) begin
        // disable the odd ones
        if (i%2)
          `GRM.dtcr1 [16+i] = 1'b0;
      end
  `endif
`endif      

`ifdef RDIMM_DUAL_RANK 
      // if run dualcs in a rdimm_quad_rank (DWC_RCD_MODE==2 or 3)
      // only 2 ranks is available as there are 4 CS_N but 2 ODT and 2 CKE available per dimm
      // Hence, disable the upper two ranks in DTCR1
      if (`DWC_RCD_MODE >= 2) begin
        for (i=0; i<`DWC_NO_OF_LRANKS; i=i+1) begin

`ifdef DWC_NO_OF_3DS_STACKS
          //case (`DWC_NO_OF_3DS_STACKS)
          //  2: if ( (i/2) %4 >= 2) `GRM.dtcr1 [16+i] = 1'b0;
          //  4: if ( (i/4) %4 >= 2) `GRM.dtcr1 [16+i] = 1'b0;
          //  8: if ( (i/8) %4 >= 2) `GRM.dtcr1 [16+i] = 1'b0;
          //  //default: // all lranks can be used
          //endcase // case(`DWC_NO_OF_3DS_STACKS)
`else
          // no stack, disable upper two ranks
          if (i%4 >= 2)
            `GRM.dtcr1 [16+i] = 1'b0;          
`endif          
        end  
      end
`endif
      
      `CFG.write_register(`DTCR1, `GRM.dtcr1);
      `FCOV_REG.set_cov_registers_write(`DTCR1 ,`GRM.dtcr1,`VALUE_REGISTER_DATA);
      `FCOV_REG.set_cov_write_level_cfg_scenario;
      write_levelling = 1'b1;
          `HOST.nops(50); 

      // trigger write leveling
      `GRM.pir[0] = 1'b1;
      `GRM.pir[9] = 1'b1;
      `FCOV_REG.set_cov_registers_write(`PIR ,`GRM.pir,`VALUE_REGISTER_DATA);
      `FCOV_REG.set_cov_init_trig_wl_dqsg_data_eye_train_scenario;
      `CFG.write_register(`PIR, `GRM.pir);

      `CFG.poll_register(`PGSR0, 0, 0, 1'b1, 100, 200000, "init done...");
      `CFG.poll_register(`PGSR0, 5, 5, 1'b1, 100, 1000,   "Write level training done...");
      init = 1'b1;

      write_levelling = 1'b0;
      message(`SYS_OP, `SYS_WLDONE, 0);

      // check to see if error is expected
      // check DXnGSR0[5] WLDONE= 1'b1  bit [6]  WLERR= exp_write_level_err
      // check PGSR0[5]   WLDONE= 1'b1  bit [21] WLERR= exp_write_level_err
       if (chk_write_level_done) begin
          $display("-> %0t: [SYS] INFO: Checking PGSR0 DXnGSR0 after write level done and err if any... ", $time);
          `CFG.disable_read_compare;
          if (exp_write_level_err === `FALSE) begin
             for (k=0;k<pNUM_LANES;k=k+1) begin

               // In dual-channel mode, the lower half of byte-lanes are write-leveld against
               // the even ranks, while the upper half of the byte-lanes are write-leveled
               // against the odd ranks
               wlrken = `GRM.dtcr1[16 +: pNO_OF_LRANKS];

               if (`DWC_DX_NO_OF_DQS == 2'd1)
                  begin

                    if (pSHARED_AC == 1) begin
                      if (k < pCHN0_DX8_NUM) wlrken_chn = wlrken & {pCHN_NO_OF_RANKS{2'b01}};
                      else                   wlrken_chn = wlrken & {pCHN_NO_OF_RANKS{2'b10}};
                    end
                    else begin
                      wlrken_chn = wlrken;
                    end

                    `CFG.read_register_data(`DX0GSR0 + `DX_REG_RANGE*k, tmp);

                    if (|wlrken_chn) begin
                      if (tmp[6:5] != {exp_write_level_err,`TRUE})
                        begin
                          `SYS.error;
                          $display("-> %0t: [SYSTEM] ERROR: Expect DX%0dGSR0 [6:5] = %0h got %0h", $time, k, {exp_write_level_err,`TRUE}, tmp[6:5]);
                        end
                    end else begin
                      if (tmp[6:5] != 2'b00)
                        begin
                          `SYS.error;
                          $display("-> %0t: [SYSTEM] ERROR: Expect DX%0dGSR0 [6:5] = %0h got %0h", $time, k, {exp_write_level_err,`TRUE}, tmp[6:5]);
                        end
                    end                      
                  end
                else
                  begin
                     if (k%2 == 0)
                       begin
                         i = k/2;

                         if (pSHARED_AC == 1) begin
                           if (i < pCHN0_DX8_NUM) wlrken_chn = {pCHN_NO_OF_RANKS{2'b01}};
                           else                   wlrken_chn = {pCHN_NO_OF_RANKS{2'b10}};
                         end
                         else begin
                           wlrken_chn = wlrken;
                         end

                         `CFG.read_register_data(`DX0GSR0 + `DX_REG_RANGE*i, tmp);
                         if (|wlrken_chn) begin
                           if (tmp[6:5] != {exp_write_level_err,`TRUE})
                             begin
                               `SYS.error;
                               $display("-> %0t: [SYSTEM] ERROR: Expect DX%0dGSR0 [6:5] = %0h got %0h", $time, i, {exp_write_level_err,`TRUE}, tmp[6:5]);
                             end
                         end else begin
                           if (tmp[6:5] != 2'b00)
                             begin
                               `SYS.error;
                               $display("-> %0t: [SYSTEM] ERROR: Expect DX%0dGSR0 [6:5] = %0h got %0h", $time, i, {exp_write_level_err,`TRUE}, tmp[6:5]);
                             end
                         end
                       end // if (pNUM_LANES %2 == 0)
                     else
                       begin
                         i = (k-1)/2;
                         if (pSHARED_AC == 1) begin
                           if (i < pCHN0_DX8_NUM) wlrken_chn = wlrken & {pCHN_NO_OF_RANKS{2'b01}};
                           else                   wlrken_chn = wlrken & {pCHN_NO_OF_RANKS{2'b10}};
                         end
                         else begin
                           wlrken_chn = wlrken;
                         end
                         
                         `CFG.read_register_data(`DX0GSR4 + `DX_REG_RANGE*i, tmp);

                         if (|wlrken_chn) begin
`ifdef DWC_DDRPHY_X4MODE
                           // compares only when in X4 mode, otherwise dont care
                           if (tmp[6:5] != {exp_write_level_err,`TRUE})
                             begin
                               `SYS.error;
                               $display("-> %0t: [SYSTEM] ERROR: Expect DX%0dGSR4 [6:5] = %0h got %0h", $time, i, {exp_write_level_err,`TRUE}, tmp[6:5]);
                             end
`endif
                         end else begin
                           if (tmp[6:5] != 2'b00)
                             begin
                               `SYS.error;
                               $display("-> %0t: [SYSTEM] ERROR: Expect DX%0dGSR4 [6:5] = %0h got %0h", $time, i, {exp_write_level_err,`TRUE}, tmp[6:5]);
                             end
                         end
                       end // else: !if(pNUM_LANES %2 == 0)
                  end // else: !if(`DWC_DX_NO_OF_DQS == 2'd1)
             end // for (k=0;k<pNUM_LANES;k=k+1)
          end // if (exp_write_level_err === `FALSE)
          else
            $display("-> %0t: [SYSTEM] : Need to find out in testcase which lane has err!!", $time);
          

          `CFG.read_register_data(`PGSR0, tmp);

          if ({tmp[21], tmp[5]} != {exp_write_level_err,`TRUE})  
            begin
               `SYS.error;
               $display("-> %0t: [SYSTEM] ERROR: Expect PGSR0 [21,5] = %0h got %0h", $time, {exp_write_level_err,`TRUE}, {tmp[21], tmp[5]});
            end
          
          repeat (10) @(posedge `CFG.clk);
          `CFG.enable_read_compare;
          repeat (10) @(posedge `CFG.clk);
       end // if (chk_write_level_done)
       

      // read the values of the write-leveling LCDL and populate the GRM
      if (populate_wl_to_grm) begin
        `CFG.disable_read_compare;
        for (byte_no=0; byte_no<pNUM_LANES; byte_no=byte_no+1) begin
          for (rank_no=0; rank_no < pNO_OF_LRANKS; rank_no = rank_no + 1) begin
            if (`DWC_DX_NO_OF_DQS == 2'd1)
              begin
                reg_addr = `RANKIDR;
                `GRM.rankidr[16 +: 4] = rank_no;  // set read rank ID in GRM
                `CFG.write_register(reg_addr, `GRM.rankidr); // set rank ID register
                repeat (5) @(posedge `CFG.clk);
                reg_addr = `DX0LCDLR0 + (`DX_REG_RANGE*byte_no);
                `CFG.read_register_data(reg_addr, reg_data);
                `GRM.dxnlcdlr0[rank_no][byte_no] = reg_data;
              end
            else
              begin
                if (byte_no%2 == 0) // even lanes are nibble0
                  begin
                    reg_addr = `RANKIDR;
                    `GRM.rankidr[16 +: 4] = rank_no;  // set read rank ID in GRM
                    `CFG.write_register(reg_addr, `GRM.rankidr); // set rank ID register
                    repeat (5) @(posedge `CFG.clk);
                    reg_addr = `DX0LCDLR0 + (`DX_REG_RANGE*(byte_no/2));
                    `CFG.read_register_data(reg_addr, reg_data);
                    `GRM.dxnlcdlr0[rank_no][byte_no/2][0 +: `LCDL_DLY_WIDTH] = reg_data[0 +: `LCDL_DLY_WIDTH];
                  end
                else  //odd lanes are nibble1
                  begin
                    reg_addr = `RANKIDR;
                    `GRM.rankidr[16 +: 4] = rank_no;  // set read rank ID in GRM
                    `CFG.write_register(reg_addr, `GRM.rankidr); // set rank ID register
                    repeat (5) @(posedge `CFG.clk);
                    reg_addr = `DX0LCDLR0 + (`DX_REG_RANGE*((byte_no-1)/2));
                    `CFG.read_register_data(reg_addr, reg_data);
                    `GRM.dxnlcdlr0[rank_no][(byte_no-1)/2][16 +: `LCDL_DLY_WIDTH] = reg_data[16 +: `LCDL_DLY_WIDTH];
                  end // else: !if(byte_no%2 == 0)
              end // else: !if(`DWC_DX_NO_OF_DQS == 2'd1)
          end
        end // for (byte_no=0; byte_no<pNUM_LANES; byte_no=byte_no+1)
      end
      else begin
        `CFG.disable_read_compare;
        $display("-> %0t: [SYS] INFO: Checking DXnLCDLR0 WLD after write level train... ", $time);

        // check to see if dxnlcdlr0 matches
        for (byte_no=0; byte_no<`DWC_NO_OF_BYTES; byte_no=byte_no+1) begin
          for (rank_no=0; rank_no < NO_OF_TRANKS; rank_no = rank_no + 1) begin
           if ((rank_en[rank_no*(`DWC_NO_OF_LRANKS/NO_OF_TRANKS)] == 1'b1)&& (`GRM.dxngcr0[byte_no][0] == 1'b1)) begin
              $display ("rank_en[%d]=%d",rank_no*(`DWC_NO_OF_LRANKS/NO_OF_TRANKS),rank_en[rank_no*(`DWC_NO_OF_LRANKS/NO_OF_TRANKS)]);
            reg_addr = `RANKIDR;
            `GRM.rankidr[16 +: 4] = rank_no;  // set read rank ID in GRM
            `CFG.write_register(reg_addr, `GRM.rankidr); // set rank ID register
            repeat (5) @(posedge `CFG.clk);
            reg_addr = `DX0LCDLR0 + (`DX_REG_RANGE*byte_no);
            `CFG.read_register_data(reg_addr, reg_data);

            // there might be a + or - 1 difference between the calculated values with the
            // DXnLCDLR0-5 delays
            tmp_0 = `SYS.abs(reg_data[8:0]   - `GRM.dxnlcdlr0[rank_no][byte_no][8:0]);
            tmp_1 = `SYS.abs(reg_data[24:16] - `GRM.dxnlcdlr0[rank_no][byte_no][24:16]);

            if ((tmp_0 > 2) || (tmp_1 > 2)) begin
              // check also if tmp_0 or tmp_1 is close to tPRD_ps/2)
              if ((tmp_0 > 2) && (`SYS.abs(tmp_0 - (`SYS.tPRD_ps/(2*`PHYSYS.ddl_step_size*1000))) > 2)) begin
                `SYS.error;
                $display("-> %0t: [SYS] ERROR:    DX[%0d]LCDLR0 delays", $time, byte_no);
                $display("-> %0t: [SYS] Expecting DX[%0d]LCDLR0.WLD  [8:0]   = 'h%0h got 'h%0h", $time, byte_no, `GRM.dxnlcdlr0[rank_no][byte_no][8:0],   reg_data[8:0]);
              end
              else begin
                // show value
                if (verbose > 7) begin
                  $display("-> %0t: [SYS]       DX[%0d]LCDLR0.WLD  [8:0]       = 'h%0h ", $time, byte_no,  reg_data[8:0]);
                  $display("-> %0t: [SYS]  `GRM.DX[%0d]LCDLR0.WLD  [8:0]       = 'h%0h ", $time, byte_no, `GRM.dxnlcdlr0[rank_no][byte_no][8:0]);
                end               
              end
`ifdef DWC_DDRPHY_X4MODE              
              if ((tmp_1 > 2) && (`SYS.abs(tmp_1 - (`SYS.tPRD_ps/(2*`PHYSYS.ddl_step_size*1000))) > 2)) begin
                `SYS.error;
                $display("-> %0t: [SYS] ERROR:    DX[%0d]LCDLR0 delays", $time, byte_no);
                $display("-> %0t: [SYS] Expecting DX[%0d]LCDLR0.X4WLD[24:16] = 'h%0h got 'h%0h", $time, byte_no, `GRM.dxnlcdlr0[rank_no][byte_no][24:16], reg_data[24:16]);
              end
              else begin
                // show value
                if (verbose > 7) begin
                  $display("-> %0t: [SYS]       DX[%0d]LCDLR0.X4WLD  [24:16]   = 'h%0h ", $time, byte_no,  reg_data[24:16]);
                  $display("-> %0t: [SYS]  `GRM.DX[%0d]LCDLR0.X4WLD  [24:16]   = 'h%0h ", $time, byte_no, `GRM.dxnlcdlr0[rank_no][byte_no][24:16]);
                end               
              end
`endif                       
            end
          end
         end
        end // for (byte_no=0; byte_no<pNUM_LANES; byte_no=byte_no+1)        
      end
      
      
      repeat (2) @(posedge `CFG.clk);      
      `CFG.enable_read_compare;

      // training issues a precharge all - close all banks for the external 
      // controller
      close_mctl_banks;
`endif
    end
  endtask // write_level_selected_ranks
  
  // DQS gate train
  // --------------
  // triggers DQS gate training and waits for it to finish
  task dqs_gate_train;
    input [31:0] no_of_ranks;
    input        wl2_required; // indicates if there are WL-1/WL+1 violations
   
    reg [pNO_OF_LRANKS -1:0]  rank_en;
    begin
      rank_en = (2**no_of_ranks) - 1;
      dqs_gate_train_selected_ranks(rank_en, wl2_required);
    end
  endtask // dqs_gate_train


  task dqs_gate_train_selected_ranks; 
    input [pNO_OF_LRANKS -1:0] rank_en;
    input        wl2_required; // indicates if there are WL-1/WL+1 violations 

    reg use_mpr;
    reg [`REG_ADDR_WIDTH-1:0] reg_addr;
    reg [`REG_DATA_WIDTH-1:0] reg_data;
    reg [8              -1:0] mask_sel;
    reg [8              -1:0] dcr_bytemask;
    reg [8              -1:0] msbyte_udq_bytemask;
    reg                       upd_dtcr;
    reg [pNO_OF_LRANKS -1:0]  rank_en;
    integer byte_no, rank_no;
    integer dx_idx;
    integer bit_idx;
    real    tmp_0, tmp_1;
    real    tmp_0_lcdlr2, tmp_1_lcdlr2;
    real    tmp_0_dly, tmp_1_dly;
    real    tmp_0_exp_dly, tmp_1_exp_dly;

    begin

`ifndef DWC_DDRPHY_EMUL_XILINX
      if(`GRM.lpddr2_mode==1'b0) begin
`endif
        upd_dtcr = 0;

`ifndef DWC_DDRPHY_EMUL_XILINX
  `ifdef SDF_ANNOTATE
        // disable timing checks of some flops during calibration and/or training
        ->force_notifiers;
  `endif

        // for DDR4/3, DQS gating is done either using MPR or read/write accesses;
        // this is randomly selected unless WL2 training is required, i.e. WL-1
        // and/or WL+1 violations are expected - in which case DQS gating must
        // be done with MPR
  `ifdef DDR4
        use_mpr = (wl2_required) ? 1'b1 : $random;
  `else
    `ifdef DDR3
        use_mpr = (wl2_required) ? 1'b1 : $random;
    `else
      `ifdef LPDDR3
        use_mpr = 1'b1; // In LPDDR3 use the MRR pattern A (from register address 32)
      `else
        use_mpr = 1'b0; // DDR2 doesn't have MPR
      `endif
    `endif
  `endif

        // configure DQS gate training
        if (`GRM.dtcr0[6] != use_mpr) begin
          `GRM.dtcr0[6] = use_mpr;
          upd_dtcr = 1;
        end
        else begin
          // extra sample on DTCR0 if functional coverage is turned on for MPR scenario
  `ifdef FUNCOV      
          `FCOV_REG.set_cov_registers_write(`DTCR0 , `GRM.dtcr0,`VALUE_REGISTER_DATA);
          `FCOV_REG.set_cov_data_eye_train_cfg_scenario;
          `FCOV_REG.set_cov_data_eye_train_debug_scenario;
  `endif
        end

        // Enables refreshes by default through setting refresh repeat value
        if (`GRM.dtcr0[31:28] == 0) begin
          `GRM.dtcr0[31:28] = 1;  // Ensure it's never 0 to avoid tRFC timing violations
          upd_dtcr = 1;
        end
`endif  // DWC_DDRPHY_EMUL_XILINX

`ifdef DWC_BUBBLES
        // When jitter is enabled, multiple reads are required for stable results
        if (`GRM.dtcr0[3:0] < 6) begin  // Pick 6 reads - this should work in all cases...
          `GRM.dtcr0[3:0] = 6;
          upd_dtcr = 1;
        end
`endif

        // Write out the DTCR0 register, iff it has been updated
        if (upd_dtcr) begin
          `CFG.write_register(`DTCR0, `GRM.dtcr0);
          `FCOV_REG.set_cov_registers_write(`DTCR0 , `GRM.dtcr0,`VALUE_REGISTER_DATA);
          `FCOV_REG.set_cov_data_eye_train_cfg_scenario;
          `FCOV_REG.set_cov_data_eye_train_debug_scenario;
          `HOST.nops(550); 
        end

        // Build mask of unused bits in most significant byte-lane
        msbyte_udq_bytemask = 8'd0;
        for (bit_idx = 0; bit_idx < (8 - `GRM.msbyte_udq); bit_idx = bit_idx + 1)
          msbyte_udq_bytemask[bit_idx] = 1'b1;

        // Set data byte comparison mask
        if (use_mpr == 0) begin  // When not using MPR mode, we can play with the mask
          dcr_bytemask = 8'd0;
          while (!(|dcr_bytemask)) begin
            mask_sel = {$random} % 24;
            if (mask_sel > 15) begin
              dcr_bytemask = mask_sel;       // 1/3rd of the time, mask is random (multi-bit comparison)
            end
            else if (mask_sel < 8) begin
              dcr_bytemask[mask_sel] = 1'b1; // 1/3rd of the time, select a single DQ bit to compare
            end
            else begin
              // 1/3rd of the time, retain default mask setting
            end

            dcr_bytemask = dcr_bytemask & msbyte_udq_bytemask;
          end

          `CFG.write_register(`DCR, `GRM.dcr);
          `FCOV_REG.set_cov_registers_write(`DCR , `GRM.dcr,`VALUE_REGISTER_DATA);
          `FCOV_REG.set_cov_mpr_scenario;
        end

        // Sample for MPR scenario after DCR and DTCR0 are both sampled
        `FCOV_REG.set_cov_mpr_scenario;

        dqs_gate_training = 1'b1;
`ifdef DWC_DDRPHY_EMUL_XILINX
        init_done = 1'b0;
`endif

        // trigger DQS gate training
        `GRM.pir[0]  = 1'b1;
        `GRM.pir[10] = 1'b1;
        `FCOV_REG.set_cov_registers_write(`PIR , `GRM.pir,`VALUE_REGISTER_DATA);
        `FCOV_REG.set_cov_init_trig_wl_dqsg_data_eye_train_scenario;

        `CFG.write_register(`PIR, `GRM.pir);

        `CFG.poll_register(`PGSR0, 0, 0, 1'b1, 100, 270000, "Init done...");
        `CFG.poll_register(`PGSR0, 6, 6, 1'b1, 100, 1000,   "Read DQS gate training done...");
        init = 1'b1;

        message(`SYS_OP, `SYS_TRAIN_DONE, 0);
        

        if (!rank_disconnected) begin            
          `GRM.pgsr0[6] = 1'b1; // done status bits are set
        end

        dqs_gate_training = 1'b0;

        // training issues a precharge all - close all banks for the external 
        // controller
        close_mctl_banks;

`ifdef DWC_DDRPHY_EMUL_XILINX
        // Indicate that initialization is done so that the ddr_mctl can start 
        // handling refreshes as required
        init_done = 1'b1;
        rpt_dqs_train_emul;
        need_data_train = 1'b0;
`else
        // check to see if error is expected
        // check DXnRSR0[3:0] QSGERR= 4'h0 (when no error), otherwise check in testcase
        // check PGSR0[6]   QSGDONE= 1'b1  bit [22] QSGERR= exp_dqs_gate_train_err
          
        `CFG.disable_read_compare;
        $display("-> %0t: [SYS] INFO: Checking DXnRSR0 for DQS gate train done and err if any... ", $time);
        if (exp_dqs_gate_train_err === `FALSE) begin
          for (byte_no=0; byte_no<`DWC_NO_OF_BYTES; byte_no=byte_no+1) begin
            `CFG.read_register_data(`DX0RSR0 + (`DX_REG_RANGE * byte_no), tmp);
            if (tmp[3:0] != 4'b0) begin
              `SYS.error;
              $display("-> %0t: [SYSTEM] ERROR: Expect DX%0dRSR0 [3:0] = %0h got %0h", $time, byte_no, 4'h0, tmp[3:0]);
            end
  `ifdef DWC_DDRPHY_X4MODE
            if (tmp[19:16] != 4'b0) begin
              `SYS.error;
              $display("-> %0t: [SYSTEM] ERROR: Expect DX%0dRSR0 [19:16] = %0h got %0h", $time, byte_no, 4'h0, tmp[19:16]);
            end
  `endif
          end
        end // if (exp_dqs_gate_train_err === `FALSE)
        else 
          $display("-> %0t: [SYSTEM] : Need to find out in testcase which rank and lane has err!!", $time);


        // check PGSR0 
        `CFG.read_register_data(`PGSR0, tmp);
        if ({tmp[22], tmp[6]} != {exp_dqs_gate_train_err,`TRUE})  
          begin
            `SYS.error;
            $display("-> %0t: [SYSTEM] ERROR: Expect PGSR0 [22,6] = %0h got %0h", $time, {exp_dqs_gate_train_err,`TRUE}, {tmp[22], tmp[6]});
          end


        if (chk_dqs_gate_train_done) begin
          // check to see if dxnlcdlr2 matches
          $display("-> %0t: [SYS] INFO: Checking DXnLCDLR2 DQSGD and DXnGTR0 DGSL after Read DQS Gate train... ", $time);
          $display("-> %0t: [SYS] INFO: Using lcdlr2_dqs_gate_tolerence = %d", $time, lcdlr2_dqs_gate_tolerence);
          for (byte_no=0; byte_no<`DWC_NO_OF_BYTES; byte_no=byte_no+1) begin
            for (rank_no=0; rank_no < NO_OF_TRANKS; rank_no = rank_no + 1) begin
             if (rank_en[rank_no*(`DWC_NO_OF_LRANKS/NO_OF_TRANKS)] == 1'b1) begin 
              $display ("rank_en[%d]=%d",rank_no*(`DWC_NO_OF_LRANKS/NO_OF_TRANKS),rank_en[rank_no*(`DWC_NO_OF_LRANKS/NO_OF_TRANKS)]);
              reg_addr = `RANKIDR;
              `GRM.rankidr[16 +: 4] = rank_no;  // set read rank ID in GRM
              `CFG.write_register(reg_addr, `GRM.rankidr); // set rank ID register
              repeat (5) @(posedge `CFG.clk);

              // DXnLCDLR2 check wld
              //
              reg_addr = `DX0LCDLR2 + (`DX_REG_RANGE*byte_no);
              `CFG.read_register_data(reg_addr, reg_data);
              // there might be a + or - 1 difference between the calculated values with the
              // DXnLCDLR2
              tmp_0 = `SYS.abs(reg_data[8:0]   - `GRM.dxnlcdlr2[rank_no][byte_no][8:0]);
              tmp_1 = `SYS.abs(reg_data[24:16] - `GRM.dxnlcdlr2[rank_no][byte_no][24:16]);
              tmp_0_lcdlr2 = reg_data[8:0];
              tmp_1_lcdlr2 = reg_data[24:16];

              if ((tmp_0 > lcdlr2_dqs_gate_tolerence) || (tmp_1 > lcdlr2_dqs_gate_tolerence)) begin
                // check also if tmp_0 or tmp_1 is close to tPRD_ps/2)
                if ((tmp_0 > lcdlr2_dqs_gate_tolerence) && (`SYS.abs(tmp_0 - (`SYS.tPRD_ps/(2*`PHYSYS.ddl_step_size*1000))) > lcdlr2_dqs_gate_tolerence)) begin
                  `SYS.error;
                  $display("-> %0t: [SYS] ERROR:    RANK = %0d  DX[%0d]LCDLR2 delays", $time, rank_no, byte_no);
                  $display("-> %0t: [SYS] Expecting RANK = %0d  DX[%0d]LCDLR2.DQSGD  [8:0]   = 'h%0h got 'h%0h", $time, rank_no, byte_no, `GRM.dxnlcdlr2[rank_no][byte_no][8:0],   reg_data[8:0]);
                end
                else begin
                  // show value
                  if (verbose > 7) begin
                    $display("-> %0t: [SYS]       DX[%0d]LCDLR2.DQSGD  [8:0]       = 'h%0h ", $time, byte_no,  reg_data[8:0]);
                    $display("-> %0t: [SYS]  `GRM.DX[%0d]LCDLR2.DQSGD  [8:0]       = 'h%0h ", $time, byte_no, `GRM.dxnlcdlr2[rank_no][byte_no][8:0]);
                  end               
                end
                
  `ifdef DWC_DDRPHY_X4MODE
                if ((tmp_1 > lcdlr2_dqs_gate_tolerence) && (`SYS.abs(tmp_1 - (`SYS.tPRD_ps/(2*`PHYSYS.ddl_step_size*1000))) > lcdlr2_dqs_gate_tolerence)) begin
                  `SYS.error;
                  $display("-> %0t: [SYS] ERROR:    RANK = %0d  DX[%0d]LCDLR2 delays", $time, rank_no, byte_no);
                  $display("-> %0t: [SYS] Expecting RANK = %0d  DX[%0d]LCDLR2.X4DQSGD[24:16] = 'h%0h got 'h%0h", $time, rank_no, byte_no, `GRM.dxnlcdlr2[rank_no][byte_no][24:16], reg_data[24:16]);
                end
                else begin
                  // show value
                  if (verbose > 7) begin
                    $display("-> %0t: [SYS]       DX[%0d]LCDLR2.X4DQSGD  [24:16]   = 'h%0h ", $time, byte_no,  reg_data[24:16]);
                    $display("-> %0t: [SYS]  `GRM.DX[%0d]LCDLR2.X4DQSGD  [24:16]   = 'h%0h ", $time, byte_no, `GRM.dxnlcdlr2[rank_no][byte_no][24:16]);
                  end               
                end
  `endif
              end

              // DXnGTR0 check DGSL
              reg_addr = `DX0GTR0 + (`DX_REG_RANGE*byte_no);
              `CFG.read_register_data(reg_addr, reg_data);
              tmp_0_dly      =                       (reg_data[4:0]) * (`SYS.tPRD_ps/(2 * `PHYSYS.ddl_step_size*1000)) + tmp_0_lcdlr2;
              tmp_0_exp_dly  = (`GRM.dxngtr0[rank_no][byte_no][4:0]) * (`SYS.tPRD_ps/(2 * `PHYSYS.ddl_step_size*1000)) + `GRM.dxnlcdlr2[rank_no][byte_no][8:0];
              
              tmp_1_dly      =                       (reg_data[12:8]) * (`SYS.tPRD_ps/(2 * `PHYSYS.ddl_step_size*1000)) + tmp_1_lcdlr2;
              tmp_1_exp_dly  = (`GRM.dxngtr0[rank_no][byte_no][12:8]) * (`SYS.tPRD_ps/(2 * `PHYSYS.ddl_step_size*1000)) + `GRM.dxnlcdlr2[rank_no][byte_no][24:16];
              
              if (reg_data[4:0] !== `GRM.dxngtr0[rank_no][byte_no][4:0]) begin
                // check to see if wl_pipe + wl_dly is within 1 step size; if greater than 1 step size than flag error
                if (`SYS.abs(tmp_0_dly - tmp_0_exp_dly) > lcdlr2_dqs_gate_tolerence) begin
                  `SYS.error;
                  $display("-> %0t: [SYS] ERROR:    RANK = %0d  DX[%0d]GTR0 DGSL", $time, rank_no, byte_no);
                  $display("-> %0t: [SYS] Expecting RANK = %0d  DX[%0d]GTR0.DGSL  [4:0]   = 'h%0h got 'h%0h", $time, rank_no, byte_no, `GRM.dxngtr0[rank_no][byte_no][4:0],   reg_data[4:0]);
                  $display("-> %0t: [SYS]                                    tmp_0_dly      = 'h%0h ", $time, tmp_0_dly);
                  $display("-> %0t: [SYS]                                    tmp_0_exp_dly  = 'h%0h ", $time, tmp_0_exp_dly);
                end
              end
  `ifdef DWC_DDRPHY_X4MODE
              if (reg_data[12:8] !== `GRM.dxngtr0[rank_no][byte_no][12:8]) begin
                // check to see if wl_pipe + wl_dly is within 1 step size; if greater than 1 step size than flag error
                if (`SYS.abs(tmp_1_dly - tmp_1_exp_dly) > lcdlr2_dqs_gate_tolerence) begin
                  `SYS.error;
                  $display("-> %0t: [SYS] ERROR:    RANK = %0d  DX[%0d]GTR0 X4DGSL", $time, rank_no, byte_no);
                  $display("-> %0t: [SYS] Expecting RANK = %0d  DX[%0d]GTR0.X4DGSL  [12:8]   = 'h%0h got 'h%0h", $time, rank_no, byte_no, `GRM.dxngtr0[rank_no][byte_no][12:8],   reg_data[12:8]);
                  $display("-> %0t: [SYS]                                    tmp_1_dly      = 'h%0h ", $time, tmp_1_dly);
                  $display("-> %0t: [SYS]                                    tmp_1_exp_dly  = 'h%0h ", $time, tmp_1_exp_dly);
                end
              end

  `endif            
             end
            end
          end // for (byte_no=0; byte_no<pNUM_LANES; byte_no=byte_no+1)        
        end  
        else begin
          $display("-> %0t: [SYS] INFO: Skip check for DXnLCDLR2 DQSGD and DXnGTR0 DGSL after Read DQS Gate train... ", $time);
        end // else: !if(chk_dqs_gate_train_done)

        repeat (10) @(posedge `CFG.clk);
        `CFG.enable_read_compare;
        repeat (10) @(posedge `CFG.clk);

`endif //DWC_DDRPHY_EMUL_XILINX

`ifdef SDF_ANNOTATE
        // re-enable timing checks of some flops disbaled during calibration and/or training
        ->release_calib_notifiers;
        ->release_train_notifiers;
`endif
        need_data_train   = 1'b0;
`ifndef DWC_DDRPHY_EMUL_XILINX
      end // if (lpddr2_mode==1'b0)
`endif
    end
  endtask // dqs_gate_train_selected_ranks

  task rdimm_training;
    begin
         
      $display("\n\n=> Triggering Write Leveling training ...\n");
      `SYS.write_level(`DWC_NO_OF_RANKS);
      $display("\n\n=> Triggering DQS gate training ...\n");
      `SYS.dqs_gate_train(`DWC_NO_OF_RANKS, 1);
      $display("\n\n=> Triggering Write Leveling Adjust training ...\n");
      `SYS.write_level_adjust(`DWC_NO_OF_RANKS);
    
    end
  endtask
  
  // read eye train
  // --------------
  // triggers read bit deskew and read eye centering and waits for it to finish
  task read_eye_train;

    reg [`REG_ADDR_WIDTH-1:0] reg_addr;
    reg [`REG_DATA_WIDTH-1:0] reg_data;
    reg [8              -1:0] mask_sel;
    reg                       upd_dtcr;
    integer byte_no;
    integer k;

    begin

      upd_dtcr = 0;

`ifdef SDF_ANNOTATE
      // disable timing checks of some flops during calibration and/or training
      ->force_notifiers;
`endif
      
      // Enables refreshes by default through setting refresh repeat value
      if (`GRM.dtcr0[31:28] == 0) begin
        `GRM.dtcr0[31:28] = 1;  // Ensure it's never 0 to avoid tRFC timing violations
        upd_dtcr = 1;
      end

`ifdef DWC_BUBBLES
      // When jitter is enabled, multiple reads are required for stable results
      if (`GRM.dtcr0[3:0] < 6) begin  // Pick 6 reads - this should work in all cases...
        `GRM.dtcr0[3:0] = 6;
        upd_dtcr = 1;
      end
`endif

      // Write out the DTCR0 register, if it has been updated
      if (upd_dtcr) begin
        `CFG.write_register(`DTCR0, `GRM.dtcr0);
        `FCOV_REG.set_cov_registers_write(`DTCR0 , `GRM.dtcr0,`VALUE_REGISTER_DATA);
        `FCOV_REG.set_cov_data_eye_train_cfg_scenario;
        `FCOV_REG.set_cov_data_eye_train_debug_scenario;
      end
      
      data_eye_training = 1'b1;
      
      // trigger read eye training
      `GRM.pir[0]  = 1'b1;
      `GRM.pir[12] = 1'b1;
      `GRM.pir[14] = 1'b1;
      `FCOV_REG.set_cov_registers_write(`PIR , `GRM.pir,`VALUE_REGISTER_DATA);
      `FCOV_REG.set_cov_init_trig_wl_dqsg_data_eye_train_scenario;

      `CFG.write_register(`PIR, `GRM.pir);

      // Wait for training to finish
      `CFG.poll_register(`PGSR0, 0, 0, 1'b1, 100, 50000, "Read eye training done...");
      message(`SYS_OP, `SYS_TRAIN_DONE, 0);

      data_eye_training = 1'b0;

      // training issues a precharge all - close all banks for the external 
      // controller
      close_mctl_banks;

      // check to see if error is expected
      // check DXnGSR0[27:24] QSGERR= 4'h0 (when no error), otherwise check in testcase
      // check PGSR0[6]   QSGDONE= 1'b1  bit [22] QSGERR= exp_dqs_gate_train_err
      `CFG.disable_read_compare;
       for (k=0;k<pNUM_LANES;k=k+1) begin
          if (`DWC_DX_NO_OF_DQS == 1)
            begin
               `CFG.read_register_data(`DX0GSR2 + `DX_REG_RANGE*k, tmp);
               if (tmp[0] != 1'b0) begin
                  `SYS.error;
                  $display("-> %0t: [SYSTEM] ERROR: Expect DX%0dGSR2 [0] = %0h got %0h", $time, k, 1'h0, tmp[0]);
               end
               if (tmp[1] != 1'b0) begin
                  `SYS.error;
                  $display("-> %0t: [SYSTEM] ERROR: Expect DX%0dGSR2 [1] = %0h got %0h", $time, k, 1'h0, tmp[1]);
               end
               if (tmp[4] != 1'b0) begin
                  `SYS.error;
                  $display("-> %0t: [SYSTEM] ERROR: Expect DX%0dGSR2 [4] = %0h got %0h", $time, k, 1'h0, tmp[4]);
               end
               if (tmp[5] != 1'b0) begin
                  `SYS.error;
                  $display("-> %0t: [SYSTEM] ERROR: Expect DX%0dGSR2 [5] = %0h got %0h", $time, k, 1'h0, tmp[5]);
               end
            end // if (`DWC_DX_NO_OF_DQS == 1)
          else
            begin
               if (k%2 == 0) // even lanes are nibble0
                 begin
                    `CFG.read_register_data(`DX0GSR2 + `DX_REG_RANGE*(k/2), tmp);
                    if (tmp[0] != 1'b0) begin
                       `SYS.error;
                       $display("-> %0t: [SYSTEM] ERROR: Expect DX%0dGSR2 [0] = %0h got %0h", $time, k/2, 1'h0, tmp[0]);
                    end
                    if (tmp[1] != 1'b0) begin
                       `SYS.error;
                       $display("-> %0t: [SYSTEM] ERROR: Expect DX%0dGSR2 [1] = %0h got %0h", $time, k/2, 1'h0, tmp[1]);
                    end
                    if (tmp[4] != 1'b0) begin
                       `SYS.error;
                       $display("-> %0t: [SYSTEM] ERROR: Expect DX%0dGSR2 [4] = %0h got %0h", $time, k/2, 1'h0, tmp[4]);
                    end
                    if (tmp[5] != 1'b0) begin
                       `SYS.error;
                       $display("-> %0t: [SYSTEM] ERROR: Expect DX%0dGSR2 [5] = %0h got %0h", $time, k/2, 1'h0, tmp[5]);
                    end
                 end // if (k%2 == 0)
               else
                 begin
                    
                    `CFG.read_register_data(`DX0GSR5 + `DX_REG_RANGE*((k-1)/2), tmp);
                    if (tmp[0] != 1'b0) begin
                       `SYS.error;
                       $display("-> %0t: [SYSTEM] ERROR: Expect DX%0dGSR5 [0] = %0h got %0h", $time, (k-1)/2, 1'h0, tmp[0]);
                    end
                    if (tmp[1] != 1'b0) begin
                       `SYS.error;
                       $display("-> %0t: [SYSTEM] ERROR: Expect DX%0dGSR5 [1] = %0h got %0h", $time, (k-1)/2, 1'h0, tmp[1]);
                    end
                    if (tmp[4] != 1'b0) begin
                       `SYS.error;
                       $display("-> %0t: [SYSTEM] ERROR: Expect DX%0dGSR5 [4] = %0h got %0h", $time, (k-1)/2, 1'h0, tmp[4]);
                    end
                    if (tmp[5] != 1'b0) begin
                       `SYS.error;
                       $display("-> %0t: [SYSTEM] ERROR: Expect DX%0dGSR5 [5] = %0h got %0h", $time, (k-1)/2, 1'h0, tmp[5]);
                    end
                 end // else: !if(k%2 == 0)
            end // else: !if(`DWC_DX_NO_OF_DQS == 1)
       end // for (k=0;k<pNUM_LANES;k=k+1)
       

      `CFG.read_register_data(`PGSR0, tmp);

      if ({tmp[24], tmp[8]} != {`FALSE,`TRUE})  
        begin
          `SYS.error;
          $display("-> %0t: [SYSTEM] ERROR: Expect PGSR0 [24,8] = %0h got %0h", $time, {`FALSE,`TRUE}, {tmp[24], tmp[8]});
        end
      if ({tmp[26], tmp[10]} != {`FALSE,`TRUE})  
        begin
          `SYS.error;
          $display("-> %0t: [SYSTEM] ERROR: Expect PGSR0 [26,10] = %0h got %0h", $time, {`FALSE,`TRUE}, {tmp[26], tmp[10]});
        end
      
      repeat (10) @(posedge `CFG.clk);
      `CFG.enable_read_compare;
      repeat (10) @(posedge `CFG.clk);

`ifdef SDF_ANNOTATE
      // re-enable timing checks of some flops disbaled during calibration and/or training
      ->release_calib_notifiers;
      ->release_train_notifiers;
`endif
      need_data_train   = 1'b0;
    end
  endtask // read_eye_train

  // write leveling adjustment
  // -------------------------
  // triggers write levling adjustment to correct for write latency
 task write_level_adjust;
    input [31:0]              no_of_ranks;
    reg [pNO_OF_LRANKS -1:0]  rank_en;
    begin
      rank_en = (2**no_of_ranks) - 1;
      write_level_adjust_to_selected_ranks(rank_en);
    end
  endtask //  write_level_adjust

  task write_level_adjust_to_selected_ranks;
    input [31:0] rank_en;

    reg [`REG_ADDR_WIDTH-1:0] reg_addr;
    reg [`REG_DATA_WIDTH-1:0] reg_data;
    reg [pNO_OF_LRANKS -1:0]  rank_en;
    integer byte_no, rank_no;
    real    tmp_0, tmp_1;
    real    tmp_0_lcdlr0, tmp_1_lcdlr0;
    real    tmp_0_dly, tmp_1_dly;
    real    tmp_0_exp_dly, tmp_1_exp_dly;
  
  begin

`ifdef DDR2
      // no write leveling for DDR2
`elsif LPDDR2
      // no write leveling for LPDDR2
`else
      // If the 7 DQ bits of the most significant byte are not used, the default
      // data training data is not good enough because there is only one valid bit;
      // load in a special pattern that can be used with 1 DQ bit
      if (`GRM.msbyte_udq == 7) begin
        `CFG.write_register(`DTDR0, 32'h00000000);
        `CFG.write_register(`DTDR1, 32'hFFFFFFFF);
      end
      
      write_levelling_2 = 1'b1;

      // trigger write leveling
      `GRM.pir[0]  = 1'b1;
      `GRM.pir[11] = 1'b1;
      `FCOV_REG.set_cov_registers_write(`PIR , `GRM.pir,`VALUE_REGISTER_DATA);
      `FCOV_REG.set_cov_init_trig_wl_dqsg_data_eye_train_scenario;
      `CFG.write_register(`PIR, `GRM.pir);

      // wait for write leveling to finish
      `CFG.poll_register(`PGSR0, 0, 0, 1'b1, 100, 200000, "init done...");
      `CFG.poll_register(`PGSR0, 7, 7, 1'b1, 100, 1000,   "Write level adjust training done...");
      message(`SYS_OP, `SYS_TRAIN_DONE, 0);

      write_levelling_2 = 1'b0;

      // check to see if error is expected
      // check PGSR0[7]   WLADONE= 1'b1  bit [23] WLAERR= exp_write_level_adj_err
      $display("-> %0t: [SYS] INFO: Checking PGSR0 for write level adjust done and err if any... ", $time);
      `CFG.disable_read_compare;

      if (exp_write_level_adj_err === `FALSE) begin
        `CFG.read_register_data(`PGSR0, tmp);

        if ({tmp[23], tmp[7]} != {exp_write_level_adj_err,`TRUE})  
          begin
            `SYS.error;
            $display("-> %0t: [SYSTEM] ERROR: Expect PGSR0 [23,7] = %0h got %0h", $time, {exp_write_level_adj_err,`TRUE}, {tmp[23], tmp[7]});
          end
      end

      if (chk_write_level_adj_done) begin
        // check to see if dxnlcdlr0 matches
        $display("-> %0t: [SYS] INFO: Checking DXnLCDLR0 WLD and DXnGTR0 WLSL after write level adjust train... ", $time);
        for (byte_no=0; byte_no<`DWC_NO_OF_BYTES; byte_no=byte_no+1) begin
          for (rank_no=0; rank_no < NO_OF_TRANKS; rank_no = rank_no + 1) begin
           if(rank_en[rank_no*(`DWC_NO_OF_LRANKS/NO_OF_TRANKS)] == 1'b1) begin
            reg_addr = `RANKIDR;
            `GRM.rankidr[16 +: 4] = rank_no;  // set read rank ID in GRM
            `CFG.write_register(reg_addr, `GRM.rankidr); // set rank ID register
            repeat (5) @(posedge `CFG.clk);

            // DXnLCDLR0 check wld
            //
            reg_addr = `DX0LCDLR0 + (`DX_REG_RANGE*byte_no);
            `CFG.read_register_data(reg_addr, reg_data);
            // there might be a + or - 1 difference between the calculated values with the
            // DXnLCDLR0 delays
            tmp_0 = `SYS.abs(reg_data[8:0]   - `GRM.dxnlcdlr0[rank_no][byte_no][8:0]);
            tmp_1 = `SYS.abs(reg_data[24:16] - `GRM.dxnlcdlr0[rank_no][byte_no][24:16]);
            tmp_0_lcdlr0 = reg_data[8:0];
            tmp_1_lcdlr0 = reg_data[24:16];

            if ((tmp_0 > 2) || (tmp_1 > 2)) begin
              // check also if tmp_0 or tmp_1 is close to tPRD_ps/2)
              if ((tmp_0 > 2) && (`SYS.abs(tmp_0 - (`SYS.tPRD_ps/(2*`PHYSYS.ddl_step_size*1000))) > 2)) begin
                `SYS.error;
                $display("-> %0t: [SYS] ERROR:    RANK = %0d  DX[%0d]LCDLR0 delays", $time, rank_no, byte_no);
                $display("-> %0t: [SYS] Expecting RANK = %0d  DX[%0d]LCDLR0.WLD  [8:0]   = 'h%0h got 'h%0h", $time, rank_no, byte_no, `GRM.dxnlcdlr0[rank_no][byte_no][8:0],   reg_data[8:0]);
              end
              else begin
                // show value
                if (verbose > 7) begin
                  $display("-> %0t: [SYS]       DX[%0d]LCDLR0.WLD  [8:0]       = 'h%0h ", $time, byte_no,  reg_data[8:0]);
                  $display("-> %0t: [SYS]  `GRM.DX[%0d]LCDLR0.WLD  [8:0]       = 'h%0h ", $time, byte_no, `GRM.dxnlcdlr0[rank_no][byte_no][8:0]);
                end               
              end
`ifdef DWC_DDRPHY_X4MODE
              if ((tmp_1 > 2) && (`SYS.abs(tmp_1 - (`SYS.tPRD_ps/(2*`PHYSYS.ddl_step_size*1000))) > 2)) begin
                `SYS.error;
                $display("-> %0t: [SYS] ERROR:    RANK = %0d  DX[%0d]LCDLR0 delays", $time, rank_no, byte_no);
                $display("-> %0t: [SYS] Expecting RANK = %0d  DX[%0d]LCDLR0.X4WLD[24:16] = 'h%0h got 'h%0h", $time, rank_no, byte_no, `GRM.dxnlcdlr0[rank_no][byte_no][24:16], reg_data[24:16]);
              end
              else begin
                // show value
                if (verbose > 7) begin
                  $display("-> %0t: [SYS]       DX[%0d]LCDLR0.X4WLD  [24:16]   = 'h%0h ", $time, byte_no,  reg_data[24:16]);
                  $display("-> %0t: [SYS]  `GRM.DX[%0d]LCDLR0.X4WLD  [24:16]   = 'h%0h ", $time, byte_no, `GRM.dxnlcdlr0[rank_no][byte_no][24:16]);
                end               
              end
`endif
            end

            // DXnGTR0 check wl_wsl
            reg_addr = `DX0GTR0 + (`DX_REG_RANGE*byte_no);
            `CFG.read_register_data(reg_addr, reg_data);
            tmp_0_dly      =                     (reg_data[19:16] - 2) * (`SYS.tPRD_ps/(2 * `PHYSYS.ddl_step_size*1000)) + tmp_0_lcdlr0;
            tmp_0_exp_dly  = (`GRM.dxngtr0[rank_no][byte_no][19:16]-2) * (`SYS.tPRD_ps/(2 * `PHYSYS.ddl_step_size*1000)) + `GRM.dxnlcdlr0[rank_no][byte_no][8:0];
            
            tmp_1_dly      =                     (reg_data[23:20] - 2) * (`SYS.tPRD_ps/(2 * `PHYSYS.ddl_step_size*1000)) + tmp_1_lcdlr0;
            tmp_1_exp_dly  = (`GRM.dxngtr0[rank_no][byte_no][23:20]-2) * (`SYS.tPRD_ps/(2 * `PHYSYS.ddl_step_size*1000)) + `GRM.dxnlcdlr0[rank_no][byte_no][24:16];
            
            if (reg_data[19:16] !== `GRM.dxngtr0[rank_no][byte_no][19:16]) begin
              // check to see if wl_pipe + wl_dly is within 1 step size; if greater than 1 step size than flag error
              if ((reg_data[19:16] >= 2) && (`SYS.abs(tmp_0_dly - tmp_0_exp_dly) > 2)) begin
                `SYS.error;
                $display("-> %0t: [SYS] ERROR:    RANK = %0d  DX[%0d]GTR0 WLSL", $time, rank_no, byte_no);
                $display("-> %0t: [SYS] Expecting RANK = %0d  DX[%0d]GTR0.WLSL  [19:16]   = 'h%0h got 'h%0h", $time, rank_no, byte_no, `GRM.dxngtr0[rank_no][byte_no][19:16],   reg_data[19:16]);
                $display("-> %0t: [SYS]                                    tmp_0_dly      = 'h%0h ", $time, tmp_0_dly);
                $display("-> %0t: [SYS]                                    tmp_0_exp_dly  = 'h%0h ", $time, tmp_0_exp_dly);
              end
            end
`ifdef DWC_DDRPHY_X4MODE
            if (reg_data[23:20] !== `GRM.dxngtr0[rank_no][byte_no][23:20]) begin
              // check to see if wl_pipe + wl_dly is within 1 step size; if greater than 1 step size than flag error
              if ((reg_data[23:20] >= 2) && (`SYS.abs(tmp_1_dly - tmp_1_exp_dly) > 2)) begin
                `SYS.error;
                $display("-> %0t: [SYS] ERROR:    RANK = %0d  DX[%0d]GTR0 X4WLSL", $time, rank_no, byte_no);
                $display("-> %0t: [SYS] Expecting RANK = %0d  DX[%0d]GTR0.X4WLSL  [23:20]   = 'h%0h got 'h%0h", $time, rank_no, byte_no, `GRM.dxngtr0[rank_no][byte_no][23:20],   reg_data[23:20]);
                $display("-> %0t: [SYS]                                    tmp_1_dly      = 'h%0h ", $time, tmp_1_dly);
                $display("-> %0t: [SYS]                                    tmp_1_exp_dly  = 'h%0h ", $time, tmp_1_exp_dly);
              end
            end

`endif            
           end
          end
        end // for (byte_no=0; byte_no<pNUM_LANES; byte_no=byte_no+1)        
      end // if (chk_write_level_adj_done)

      repeat (10) @(posedge `CFG.clk);
      `CFG.enable_read_compare;
      repeat (10) @(posedge `CFG.clk);

      // training issues a precharge all - close all banks for the external 
      // controller
      close_mctl_banks;

`endif
    end
  endtask // write_level_adjust_to_selected_ranks

  // write leveling adjustment for selected ranks
  // --------------------------------------------
  // triggers write levling adjustment for selected ranks to correct for write latency
  task write_level_adjust_selected_ranks;
    input [3:0] rank_en;

    reg [`REG_ADDR_WIDTH-1:0] reg_addr;
    reg [`REG_DATA_WIDTH-1:0] reg_data;
    integer byte_no;
    begin
`ifdef DDR2
      // no write leveling for DDR2
`elsif LPDDR2
      // no write leveling for LPDDR2
`else
      // If the 7 DQ bits of the most significant byte are not used, the default
      // data training data is not good enough because there is only one valid bit;
      // load in a special pattern that can be used with 1 DQ bit
      if (`GRM.msbyte_udq == 7) begin
        `CFG.write_register(`DTDR0, 32'h00000000);
        `CFG.write_register(`DTDR1, 32'hFFFFFFFF);
      end

      // configure rank en for write leveling adjust
      `GRM.dtcr1[31:16] = rank_en;
      // disable a rank if it is not available for train for RDIMM_SINGLE_RANK or run dualcs in a rdimm_quad_rank scenario
`ifdef RDIMM_SINGLE_RANK
  `ifdef RDIMM_DUAL_RANK 
      // For RDIMM_SINGLE_RANK, there is only 1 rank per DIMM.
      // to setup for 1 rank  only, use runtc option ranks=2 and turn on RANKEN only for the even rank; one DIMM device
      // to setup for 2 ranks only, use runtc option ranks=4 and turn on RANKEN only for the even rank; two DIMM device
      for (i=0; i<`DWC_NO_OF_LRANKS; i=i+1) begin
        // disable the odd ones
        if (i%2)
          `GRM.dtcr1 [16+i] = 1'b0;
      end
  `endif
`endif      

`ifdef RDIMM_DUAL_RANK 
      // if run dualcs in a rdimm_quad_rank (DWC_RCD_MODE==2 or 3)
      // only 2 ranks is available as there are 4 CS_N but 2 ODT and 2 CKE available per dimm
      // Hence, /disable the upper two ranks in DTCR1
      if (`DWC_RCD_MODE >= 2) begin
        for (i=0; i<`DWC_NO_OF_LRANKS; i=i+1) begin
          if (i%4 >= 2)
            `GRM.dtcr1 [16+i] = 1'b0;
        end  
      end
`endif
      `CFG.write_register(`DTCR1, `GRM.dtcr1);
      `FCOV_REG.set_cov_registers_write(`DTCR1 ,`GRM.dtcr1,`VALUE_REGISTER_DATA);
      `FCOV_REG.set_cov_write_level_cfg_scenario;
      
      write_levelling_2 = 1'b1;

      // trigger write leveling
      `GRM.pir[0]  = 1'b1;
      `GRM.pir[11] = 1'b1;
      `FCOV_REG.set_cov_registers_write(`PIR , `GRM.pir,`VALUE_REGISTER_DATA);
      `FCOV_REG.set_cov_init_trig_wl_dqsg_data_eye_train_scenario;
      `CFG.write_register(`PIR, `GRM.pir);

      // wait for write leveling to finish
      `CFG.poll_register(`PGSR0, 0, 0, 1'b1, 100, 200000, "init done...");
      `CFG.poll_register(`PGSR0, 7, 7, 1'b1, 100, 1000,   "Write level adjust training done...");
      message(`SYS_OP, `SYS_TRAIN_DONE, 0);

      write_levelling_2 = 1'b0;

      // check to see if error is expected
      // check PGSR0[7]   WLADONE= 1'b1  bit [23] WLAERR= exp_write_level_adj_err
      if (chk_write_level_adj_done) begin
        `CFG.disable_read_compare;

        if (exp_write_level_adj_err === `FALSE) begin
          `CFG.read_register_data(`PGSR0, tmp);

          if ({tmp[23], tmp[7]} != {exp_write_level_adj_err,`TRUE})  
            begin
              `SYS.error;
              $display("-> %0t: [SYSTEM] ERROR: Expect PGSR0 [23,7] = %0h got %0h", $time, {exp_write_level_adj_err,`TRUE}, {tmp[23], tmp[7]});
            end
          
          repeat (10) @(posedge `CFG.clk);
          `CFG.enable_read_compare;
          repeat (10) @(posedge `CFG.clk);
        end
      end
      // training issues a precharge all - close all banks for the external 
      // controller
      close_mctl_banks;

`endif
    end
  endtask // write_level

  // enable static read train from PIR
  task static_read_train;
    input reg [1:0]  rdmode;
    begin
      `GRM.pgcr3[4:3] = rdmode;
      `CFG.write_register(`PGCR3, `GRM.pgcr3);

      `SYS.static_read_training = 1'b1;
      
      `GRM.pir[0]  =1'b1;
      `GRM.pir[16] =1'b1;
      `CFG.write_register(`PIR, `GRM.pir);
      `SYS.nops(200);
      `CFG.poll_register(`PGSR0, 0, 0, 1'b1,  100, 100000, "Static read training done...");

       if (!rank_disconnected) begin            
        `GRM.pgsr0[13] = 1'b1; // done status bits are set
       end

      `SYS.static_read_training = 1'b0;
      
    end
  endtask // static_read_train
  
  // loop-back mode
  // --------------
  // enables/disables PHY loop-back modes
  task enable_loopback;
    input       io_lb;   // selects core-side or pad-side loopback
    input       lb_dqss; // selects auto DQS shift or by software
    input [1:0] lb_gdqs; // seleces DQS gating method
    begin
      
      // to prevent SDRAM from complaining with a DDR2-type preamble used in 
      // DDR3 during loopback, disconnect the SDRAMs
      disconnect_all_sdrams;

      // set the loopback mode bit; the write to the register is done in the
      // configure_loopback task
      `GRM.pgcr1[31] = 1'b1;
      configure_loopback(io_lb, lb_dqss, lb_gdqs);
      phy_fifo_reset;
    end
  endtask // enable_loopback

  task disable_loopback;
    begin
      // disable loopback
      `GRM.pgcr1[31] = 1'b0;
      `CFG.write_register(`PGCR1, `GRM.pgcr1);
      `FCOV_REG.set_cov_registers_write(`PGCR1 , `GRM.pgcr1,`VALUE_REGISTER_DATA);
      `FCOV_REG.set_cov_loopback_cfg_scenario;
      
      // re-connect the SDRAMs
      connect_all_sdrams;
    end
  endtask // disable_loopback

  
  // configures loopback mode
  task configure_loopback;
    input       io_lb;   // selects core-side or pad-side loopback
    input       lb_dqss; // selects auto DQS shift or by software
    input [1:0] lb_gdqs; // seleces DQS gating method
    
    integer i, rank_id;
    reg [`REG_ADDR_WIDTH:0] reg_addr;
    reg [`REG_DATA_WIDTH:0] reg_data;
    reg [7:0] tx_90_dly;
    reg [7:0] rx_90_dly;
    begin

      // set loopback configurations
      `GRM.pgcr1[27]    = io_lb;
      `GRM.pgcr1[28]    = lb_dqss;
      `GRM.pgcr1[30:29] = lb_gdqs;
      `CFG.write_register(`PGCR1, `GRM.pgcr1);
      `FCOV_REG.set_cov_registers_write(`PGCR1 , `GRM.pgcr1,`VALUE_REGISTER_DATA);
      `FCOV_REG.set_cov_loopback_cfg_scenario;

      // if loopback DQS gating is to be set by software write the read-path 90 degrees 
      // phase shift LCDL to 0 so that you don't have 180 degrees shift
       if (lb_gdqs == `LB_GDQS_SW) begin
          for (i=0; i<pNUM_LANES; i=i+1) begin
             for (rank_id = 0; rank_id < pNO_OF_LRANKS; rank_id = rank_id + 1) begin
               `GRM.rankidr[16 +: `RANKID_RD_WIDTH] = rank_id; 
               `GRM.rankidr[0 +: `RANKID_WR_WIDTH] = rank_id; 
               `CFG.write_register(`RANKIDR, `GRM.rankidr);
               repeat (5) @(posedge `CFG.clk); 

                 if (`DWC_DX_NO_OF_DQS == 1)
                   begin
                      reg_addr = `DX0LCDLR3 + (`DX_REG_RANGE * i);
                      
                      // read the trained value - disable the compare
                      `CFG.disable_read_compare;
                      `CFG.read_register_data(reg_addr, reg_data);
                      repeat (2) @(posedge `CFG.clk);      
                      `CFG.enable_read_compare;
                      
                      // Keep a copy of the trained value so we can restore it later
                      // store rdqs in lower half and rdqsn in upper half
                      reg_dxnlcdlr1_init[rank_id][i][0 +: `LCDL_DLY_WIDTH] = reg_data[0 +: `LCDL_DLY_WIDTH];
                      
                      // zero the read DQS LCDLs
                      reg_data[0   +: `LCDL_DLY_WIDTH] = 0;
                      reg_data[16  +: `LCDL_DLY_WIDTH] = 0;
                      
                      @(posedge `CFG.clk);
                      `CFG.write_register(reg_addr, reg_data);
                      `FCOV_REG.set_cov_registers_write(reg_addr, reg_data,`VALUE_REGISTER_DATA);

                      reg_addr = `DX0LCDLR4 + (`DX_REG_RANGE * i);
                      
                      // read the trained value - disable the compare
                      `CFG.disable_read_compare;
                      `CFG.read_register_data(reg_addr, reg_data);
                      repeat (2) @(posedge `CFG.clk);      
                      `CFG.enable_read_compare;
                      
                      // Keep a copy of the trained value so we can restore it later store rdqs in lower half and rdqsn in upper half
                      reg_dxnlcdlr1_init[rank_id][i][16 +: `LCDL_DLY_WIDTH] = reg_data[0 +: `LCDL_DLY_WIDTH];
                      
                      // zero the read DQS LCDLs
                      reg_data[0   +: `LCDL_DLY_WIDTH] = 0;
                      reg_data[16  +: `LCDL_DLY_WIDTH] = 0;
                      
                      @(posedge `CFG.clk);
                      `CFG.write_register(reg_addr, reg_data);
                      `FCOV_REG.set_cov_registers_write(reg_addr, reg_data,`VALUE_REGISTER_DATA);
                   end // if (`DWC_DX_NO_OF_DQS == 1)
                 else
                   begin
                      if(i%2 == 0)
                        begin
                           reg_addr = `DX0LCDLR3 + (`DX_REG_RANGE * (i/2));
                           
                           // read the trained value - disable the compare
                           `CFG.disable_read_compare;
                           `CFG.read_register_data(reg_addr, reg_data);
                           repeat (2) @(posedge `CFG.clk);      
                           `CFG.enable_read_compare;
                           
                           // Keep a copy of the trained value so we can restore it later
                           //  store rdqs in lower half and rdqsn in upper half
                           reg_dxnlcdlr1_init[rank_id][i/2][0 +: `LCDL_DLY_WIDTH] = reg_data[0 +: `LCDL_DLY_WIDTH];
                           
                           // zero the read DQS LCDLs
                           reg_data[0   +: `LCDL_DLY_WIDTH] = 0;
                           reg_data[16  +: `LCDL_DLY_WIDTH] = 0;
                           
                           @(posedge `CFG.clk);
                           `CFG.write_register(reg_addr, reg_data);
                           `FCOV_REG.set_cov_registers_write(reg_addr, reg_data,`VALUE_REGISTER_DATA);
                           reg_addr = `DX0LCDLR4 + (`DX_REG_RANGE * (i/2));
                           
                           // read the trained value - disable the compare
                           `CFG.disable_read_compare;
                           `CFG.read_register_data(reg_addr, reg_data);
                           repeat (2) @(posedge `CFG.clk);      
                           `CFG.enable_read_compare;
                           
                           // Keep a copy of the trained value so we can restore it later
                           //  store rdqs in lower half and rdqsn in upper half
                           reg_dxnlcdlr1_init[rank_id][i/2][16 +: `LCDL_DLY_WIDTH] = reg_data[0 +: `LCDL_DLY_WIDTH];
                           
                           // zero the read DQS LCDLs
                           reg_data[0   +: `LCDL_DLY_WIDTH] = 0;
                           reg_data[16  +: `LCDL_DLY_WIDTH] = 0;
                           
                           @(posedge `CFG.clk);
                           `CFG.write_register(reg_addr, reg_data);
                           `FCOV_REG.set_cov_registers_write(reg_addr, reg_data,`VALUE_REGISTER_DATA);
                         end // if (i%2 == 0)
                      else
                        begin
                           reg_addr = `DX0LCDLR3 + (`DX_REG_RANGE * ((i-1)/2));
                           
                           // read the trained value - disable the compare
                           `CFG.disable_read_compare;
                           `CFG.read_register_data(reg_addr, reg_data);
                           repeat (2) @(posedge `CFG.clk);      
                           `CFG.enable_read_compare;
                           
                           // Keep a copy of the trained value so we can restore it later
                           //  store rdqs in lower half and rdqsn in upper half
                           reg_dxnlcdlr1_init[rank_id][(i-1)/2][0 +: `LCDL_DLY_WIDTH] = reg_data[16 +: `LCDL_DLY_WIDTH];
                           
                           // zero the read DQS LCDLs
                           reg_data[0   +: `LCDL_DLY_WIDTH] = 0;
                           reg_data[16  +: `LCDL_DLY_WIDTH] = 0;
                           
                           @(posedge `CFG.clk);
                           `CFG.write_register(reg_addr, reg_data);
                           `FCOV_REG.set_cov_registers_write(reg_addr, reg_data,`VALUE_REGISTER_DATA);

                           reg_addr = `DX0LCDLR4 + (`DX_REG_RANGE * ((i-1)/2));
                           
                           // read the trained value - disable the compare
                           `CFG.disable_read_compare;
                           `CFG.read_register_data(reg_addr, reg_data);
                           repeat (2) @(posedge `CFG.clk);      
                           `CFG.enable_read_compare;
                           
                           // Keep a copy of the trained value so we can restore it later
                           //  store rdqs in lower half and rdqsn in upper half
                           reg_dxnlcdlr1_init[rank_id][(i-1)/2][16 +: `LCDL_DLY_WIDTH] = reg_data[16 +: `LCDL_DLY_WIDTH];
                           
                           // zero the read DQS LCDLs
                           reg_data[0   +: `LCDL_DLY_WIDTH] = 0;
                           reg_data[16  +: `LCDL_DLY_WIDTH] = 0;
                           
                           @(posedge `CFG.clk);
                           `CFG.write_register(reg_addr, reg_data);
                           `FCOV_REG.set_cov_registers_write(reg_addr, reg_data,`VALUE_REGISTER_DATA);
                        end // else: !if(i%2 == 0)
                   end // else: !if(`DWC_DX_NO_OF_DQS == 1)
              end
          end // for (i=0; i<pNUM_LANES; i=i+1)
          
          // re-adjust the DQS gating for loopback
          adjust_loopback_dqs_gate;
       end
    end
  endtask // configure_loopback

  
  task store_reg_dxnlcdl1_init;
    integer lane_no, rank_id;
    reg [`REG_ADDR_WIDTH:0] reg_addr;
    reg [`REG_DATA_WIDTH:0] reg_data;
    begin
       for (lane_no=0; lane_no<pNUM_LANES; lane_no=lane_no+1)
         begin
            for (rank_id = 0; rank_id < pNO_OF_LRANKS; rank_id = rank_id + 1) begin

                `GRM.rankidr[16 +: `RANKID_RD_WIDTH] = rank_id; 
                `GRM.rankidr[0 +: `RANKID_WR_WIDTH] = rank_id; 
                `CFG.write_register(`RANKIDR, `GRM.rankidr);
                repeat (5) @(posedge `CFG.clk);

             
                if (`DWC_DX_NO_OF_DQS == 1)
                  begin
                     reg_addr = `DX0LCDLR3 + (`DX_REG_RANGE * lane_no);

                     // read the trained value - disable the compare
                     `CFG.disable_read_compare;
                     `CFG.read_register_data(reg_addr, reg_data);
                     repeat (2) @(posedge `CFG.clk);      
                     `CFG.enable_read_compare;

                     // Keep a copy of the trained value so we can restore it later
                     reg_dxnlcdlr1_init[rank_id][lane_no][0 +: `LCDL_DLY_WIDTH] = reg_data[0 +: `LCDL_DLY_WIDTH] ;
                     reg_addr = `DX0LCDLR4 + (`DX_REG_RANGE * lane_no);

                     // read the trained value - disable the compare
                     `CFG.disable_read_compare;
                     `CFG.read_register_data(reg_addr, reg_data);
                     repeat (2) @(posedge `CFG.clk);      
                     `CFG.enable_read_compare;

                     // Keep a copy of the trained value so we can restore it later
                     reg_dxnlcdlr1_init[rank_id][lane_no][16 +: `LCDL_DLY_WIDTH]  = reg_data[0 +: `LCDL_DLY_WIDTH] ;
                   end // if (`DWC_DX_NO_OF_DQS == 1)
                else
                  begin
                     if (lane_no%2 == 0)
                       begin
                          reg_addr = `DX0LCDLR3 + (`DX_REG_RANGE * (lane_no/2));

                          // read the trained value - disable the compare
                          `CFG.disable_read_compare;
                          `CFG.read_register_data(reg_addr, reg_data);
                          repeat (2) @(posedge `CFG.clk);      
                          `CFG.enable_read_compare;

                          // Keep a copy of the trained value so we can restore it later
                          reg_dxnlcdlr1_init[rank_id][lane_no/2][0 +: `LCDL_DLY_WIDTH] = reg_data[0 +: `LCDL_DLY_WIDTH];
                          reg_addr = `DX0LCDLR4 + (`DX_REG_RANGE * (lane_no/2));

                          // read the trained value - disable the compare
                          `CFG.disable_read_compare;
                          `CFG.read_register_data(reg_addr, reg_data);
                          repeat (2) @(posedge `CFG.clk);      
                          `CFG.enable_read_compare;

                          // Keep a copy of the trained value so we can restore it later
                          reg_dxnlcdlr1_init[rank_id][lane_no/2][16 +: `LCDL_DLY_WIDTH] = reg_data[0 +: `LCDL_DLY_WIDTH];
                        end // if (lane_no%2 == 0)
                     else
                       begin
                          reg_addr = `DX0LCDLR3 + (`DX_REG_RANGE * ((lane_no-1)/2));

                          // read the trained value - disable the compare
                          `CFG.disable_read_compare;
                          `CFG.read_register_data(reg_addr, reg_data);
                          repeat (2) @(posedge `CFG.clk);      
                          `CFG.enable_read_compare;

                          // Keep a copy of the trained value so we can restore it later
                          reg_dxnlcdlr1_init[rank_id][(lane_no-1)/2][0 +: `LCDL_DLY_WIDTH] = reg_data[16 +: `LCDL_DLY_WIDTH];
                          reg_addr = `DX0LCDLR4 + (`DX_REG_RANGE * ((lane_no-1)/2));

                          // read the trained value - disable the compare
                          `CFG.disable_read_compare;
                          `CFG.read_register_data(reg_addr, reg_data);
                          repeat (2) @(posedge `CFG.clk);      
                          `CFG.enable_read_compare;

                          // Keep a copy of the trained value so we can restore it later
                          reg_dxnlcdlr1_init[rank_id][(lane_no-1)/2][16 +: `LCDL_DLY_WIDTH] = reg_data[16 +: `LCDL_DLY_WIDTH];
                        end // else: !if(lane_no%2 == 0)
                  end // else: !if(`DWC_DX_NO_OF_DQS == 1)
             end
         end // for (lane_no=0; lane_no<pNUM_LANES; lane_no=lane_no+1)
     end
  endtask // store_reg_dxnlcdl1_init
   
  // close MCTL banks
  task close_mctl_banks;
    integer i;
    begin
      for (i=0; i<`MCTL.MAX_BANKS; i=i+1) begin
        `MCTL.bank_open[i] = `MCTL.BANK_CLOSED;
      end
    end
  endtask // close_mctl_banks
  
  //---------------------------------------------------------------------------
  // Wait and Timeout tasks
  // These following task is for monitoring expected condition that if the
  // event fails to occur will kill the simulation and flag an error
  //---------------------------------------------------------------------------
  task t_wait_reset_done;
    begin
      fork
        begin: WAIT_SYS_RESET
          @(e_sys_reset_done);
          if (verbose > 7) $display("-> %0t: [SYSTEM] ==> SYSTEM RESET DONE", $time);
          disable TIMEOUT_SYS_RESET;
        end
        begin: TIMEOUT_SYS_RESET
          repeat(`TIMEOUT_SYS_RESET_COUNT) @(posedge clk);
          error;
          $display("-> %0t: [SYSTEM] TIMEOUT ON SYSTEM RESET!!!", $time);
          `END_SIMULATION;
        end
      join
    end
  endtask // t_wait_reset_done

  
  task t_wait_pll_lock_done;
    begin
      fork
        begin: WAIT_PLL_LOCK
`ifndef DWC_DDRPHY_EMUL_XILINX
          //wait (`PUB.pll_lock_done == 1'b1);
          `CFG.poll_register(`PGSR0, 1, 1, 1'b1, 100, 100000, "PLDONE set");
 `endif
          //if (verbose > 7) 
            $display("-> %0t: [SYSTEM] ==> PLL LOCK DONE", $time);
          disable TIMEOUT_PLL_LOCK;
        end
        begin: TIMEOUT_PLL_LOCK
          repeat(`TIMEOUT_PLL_INIT_COUNT) @(posedge clk);
          error;
          $display("-> %0t: [SYSTEM]: TIMEOUT ON PLL LOCK!!!", $time);
          `END_SIMULATION;
        end
      join
    end
  endtask // t_wait_pll_lock_done

  
  task t_wait_phy_cal_done;
    begin
      fork
        begin: WAIT_PHY_CAL
`ifndef DWC_DDRPHY_EMUL_XILINX
          check_cfg_calib_done;
 `endif
          if (verbose > 7) $display("-> %0t: [SYSTEM] ==> PHY CALIBRATION DONE", $time);
          disable TIMEOUT_PHY_CAL;
        end
        begin: TIMEOUT_PHY_CAL
          repeat(`TIMEOUT_PHY_CAL_COUNT) @(posedge clk);
          error;
          $display("-> %0t: [SYSTEM]: TIMEOUT ON PHY CAL!!!", $time);
          `END_SIMULATION;
        end
      join
    end
  endtask // t_wait_phy_cal_done

  
  task t_wait_init_done;
    begin
      fork
        begin: WAIT_PHY_INIT
`ifndef DWC_DDRPHY_EMUL_XILINX
          `CFG.poll_register(`PGSR0, 0, 0, 1'b1,  100, 300000, "PUB initialization done...");
          init = 1'b1;
`endif
          if (verbose > 7) $display("-> %0t: [SYSTEM] ==> INIT DONE", $time);
          disable TIMEOUT_PHY_INIT;
        end
        begin: TIMEOUT_PHY_INIT
          repeat(`TIMEOUT_PHY_INIT_COUNT) @(posedge clk);
          error;
          $display("-> %0t: [SYSTEM]: TIMEOUT ON PHY INIT!!!", $time);
          `END_SIMULATION;
        end
      join
    end
  endtask // t_wait_init_done


  task t_wait_dram_init_done;
    begin
      fork
        begin: WAIT_SDRAM_INIT
`ifndef DWC_DDRPHY_EMUL_XILINX
          `CFG.poll_register(`PGSR0, 4, 4, 1'b1,  100, 3000000, "DRAM init done...");
`endif
          if (verbose > 7) $display("-> %0t: [SYSTEM] ==> SDRAM INIT DONE", $time);
          disable TIMEOUT_SDRAM_INIT;
        end
        begin: TIMEOUT_SDRAM_INIT
          repeat(`TIMEOUT_SDRAM_INIT_COUNT) @(posedge clk);
          error;
          $display("-> %0t: [SYSTEM] TIMEOUT ON SDRAM INIT!!!", $time);
          `END_SIMULATION;
        end
      join
    end
  endtask // t_wait_dram_init_done


  task t_wait_write_leveling_done;
    begin
      fork
        begin: WAIT_WRITE_LEVELING
          @(e_write_level_done);
          if (verbose > 7) $display("-> %0t: [SYSTEM] ==> WRITE LEVELING DONE", $time);
          disable TIMEOUT_PHY_WRITE_LEVELING;
        end
        begin: TIMEOUT_PHY_WRITE_LEVELING
          repeat(`TIMEOUT_WRITE_LEVELING_COUNT) @(posedge clk);
          error;
          $display("-> %0t: [SYSTEM] TIMEOUT ON WRITE LEVELING!!!", $time);
          `END_SIMULATION;
        end
      join
    end
  endtask // t_wait_write_leveling_done


  task t_wait_dqs_gate_training_done;
    begin
      fork
        begin: WAIT_DQS_GATE_TRAINING
          @(e_dqs_gate_training_done);
          if (verbose > 7) $display("-> %0t: [SYSTEM] ==> DQS GATE TRAINING DONE", $time);
          disable TIMEOUT_PHY_DQS_GATE_TRAINING;
        end
        begin: TIMEOUT_PHY_DQS_GATE_TRAINING
          repeat(`TIMEOUT_DQS_GATE_TRAIN_COUNT) @(posedge clk);
          error;
          $display("-> %0t: [SYSTEM] TIMEOUT ON DQS GATE TRAINING!!!", $time);
          `END_SIMULATION;
        end
      join
    end
  endtask // t_wait_dqs_gate_training_done

  
  
  task t_wait_system_ready;
    begin
      t_wait_reset_done;
      if (check_all_phy_init_flow) begin
        t_wait_pll_lock_done;
        t_wait_phy_cal_done;
      end
      t_wait_init_done;

      if (check_dram_init_done)
        t_wait_dram_init_done;

      //t_wait_write_leveling_done;

      if (check_dqs_gate_training)
        t_wait_dqs_gate_training_done;
      -> e_phy_ready;
      if (verbose > 7) $display("-> %0t: [SYSTEM] ==> SYSTEM IS READY", $time);
    end
  endtask // t_wait_system_ready
  

  // Monitor the powerup sequence and flag any error when expect
  // event of the initialization did not happen or timeout.
  always @(e_sys_powerup_start)
    t_wait_system_ready;

// TODO - Removing for now. 
/* 
  // Monitor the powerup sequence and check the PGSR0 error status register values
  // when the `PUB.init_done is asserted.
  always @(posedge `PUB.init_done) begin
    t_check_pgsr0_err_regs;
  end

  task t_check_pgsr0_err_regs;
    reg [31:0] pgsr0;
    reg        cpy_grm_cmp;
  begin
    // save the current state of the GRM compare
    cpy_grm_cmp = `CFG.grm_cmp;

    if(cpy_grm_cmp == 1'b1) begin
      `CFG.disable_read_compare;
    end

    `CFG.read_register_data(`PGSR0, pgsr0);

    if(cpy_grm_cmp == 1'b1) begin
      `CFG.enable_read_compare;
    end

    // check PGSR0[ZCERR]
    if(pgsr0[20] == 1'b1) begin
      error;
      $display("-> %0t: [SYSTEM] ERROR: PGSR0[ZCERR] = 1 after `PUB.init_done", $time);
    end

    // check PGSR0[WLERR]
    if(pgsr0[21] == 1'b1) begin
      error;
      $display("-> %0t: [SYSTEM] ERROR: PGSR0[WLERR] = 1 after `PUB.init_done", $time);
    end

    // check PGSR0[QSGERR]
    if(pgsr0[22] == 1'b1) begin
      error;
      $display("-> %0t: [SYSTEM] ERROR: PGSR0[QSGERR] = 1 after `PUB.init_done", $time);
    end

    // check PGSR0[WLAERR]
    if(pgsr0[23] == 1'b1) begin
      error;
      $display("-> %0t: [SYSTEM] ERROR: PGSR0[WLAERR] = 1 after `PUB.init_done", $time);
    end

    // check PGSR0[RDERR]
    if(pgsr0[24] == 1'b1) begin
      error;
      $display("-> %0t: [SYSTEM] ERROR: PGSR0[RDERR] = 1 after `PUB.init_done", $time);
    end

    // check PGSR0[WDERR]
    if(pgsr0[25] == 1'b1) begin
      error;
      $display("-> %0t: [SYSTEM] ERROR: PGSR0[WDERR] = 1 after `PUB.init_done", $time);
    end

    // check PGSR0[REERR]
    if(pgsr0[26] == 1'b1) begin
      error;
      $display("-> %0t: [SYSTEM] ERROR: PGSR0[REERR] = 1 after `PUB.init_done", $time);
    end

    // check PGSR0[WEERR]
    if(pgsr0[27] == 1'b1) begin
      error;
      $display("-> %0t: [SYSTEM] ERROR: PGSR0[WEERR] = 1 after `PUB.init_done", $time);
    end

    // check PGSR0[CAERR]
    if(pgsr0[28] == 1'b1) begin
      error;
      $display("-> %0t: [SYSTEM] ERROR: PGSR0[CAERR] = 1 after `PUB.init_done", $time);
    end
  end
  endtask // t_check_pgsr0_err_regs
*/
  


  //---------------------------------------------------------------------------
  // Rank-Specific Tasks
  //---------------------------------------------------------------------------
  
  // disconnect/connect all SDRAMs
  // -----------------------------
  // disconnects/connects all SDRAMs from the system; especially used for
  // testcases that randomly change configuration to test registers, PHY, etc.
  // diconnecting all SDRAMs from the system avoid unnecessary errors/warnings
  // issued by SDRAMs models when invalid configuration are set
  task disconnect_all_sdrams;
    begin
      // disconnect DDR SDRAM to remove unwanted errors
      // remove corresponding DDR monitors
      rank_cfg_sel = pRANK_DISCONNECT_ALL;
      rank_disconnected = 1'b1;
      #1;
      -> e_configure_rank;
      #1;  // fans out to many ddr_mnt task.. add extra wait 

      // disable parity error checking
      parity_err_chk = 1'b0;
    end
  endtask // disconnect_all_sdrams
  
  task connect_all_sdrams;
    begin
      // connect DDR SDRAM to remove unwanted errors
      rank_cfg_sel = pRANK_CONNECT_ALL;
      rank_disconnected = 1'b0;
      #1;
      -> e_configure_rank;
      #1;
    end
  endtask // connect_all_sdrams
  
  
  // connect/disconnect data byte chips
  // ----------------------------------
  task connect_chips;
    input [31:0] no_of_bytes;
    begin
      rank_cfg_sel = pRANK_CONNECT_CHIPS;
      rank_cfg_val[0] = no_of_bytes;
      #1;
      -> e_configure_rank;
      #1;
    end
  endtask // connect_chips


  // Set chip dis mask
  // ---------------------
  task set_chip_dis_mask;
    input integer rank_idx;
    input [`DWC_NO_OF_BYTES-1:0]  chip_dis_mask;
    begin
      rank_cfg_id     = rank_idx;
      rank_cfg_sel    = pRANK_CHIP_DIS_MASK;
      rank_cfg_val[0] = chip_dis_mask;
      #1;
      -> e_configure_rank;
      #1;
    end
  endtask
      

  // enable/disable SDRAM clock checks
  // ----------------------------------
  // enables/disablesclock checks on all SDRAMs
  task enable_clock_checks;
    begin
      rank_cfg_sel = pRANK_CLOCK_CHECK_EN;
      #1;
      -> e_configure_rank;
      #1;  //enough time for rank configuration to loop through
    end
  endtask // enable_clock_checks
  
  task disable_clock_checks;
    begin
      rank_cfg_sel = pRANK_CLOCK_CHECK_DIS;
      #1;
      -> e_configure_rank;
      #1;  //enough time for rank configuration to loop through
    end
  endtask // disable_clock_checks


  // enable/disable SDRAM refresh check
  // ----------------------------------
  // enables/disables refresh check on all SDRAMs
  task enable_refresh_check;
    begin
      rank_cfg_sel = pRANK_RFSH_CHECK_EN;
      #1;
      -> e_configure_rank;
      #1;  //enough time for rank configuration to loop through
    end
  endtask // enable_refresh_check
  
  task disable_refresh_check;
    begin
      rank_cfg_sel = pRANK_RFSH_CHECK_DIS;
      #1;
      -> e_configure_rank;
      #1;  //enough time for rank configuration to loop through
    end
  endtask // disable_refresh_check

  
  // disable/enable DQ setup/hold checks
  // ------------------------------------
  task enable_dq_setup_hold_checks;
    begin
      rank_cfg_sel = pRANK_SETUP_CHECK_EN;
      #1;
      -> e_configure_rank;
      #1;  //enough time for rank configuration to loop through
    end
  endtask // enable_dq_setup_hold_checks
  
  task disable_dq_setup_hold_checks;
    begin
      rank_cfg_sel = pRANK_SETUP_CHECK_DIS;
      #1;
      -> e_configure_rank;
      #1;  //enough time for rank configuration to loop through
    end
  endtask // disable_dq_setup_hold_checks

  
  // disable/enable DQ pulse width checks
  // ------------------------------------
  task enable_dq_pulse_width_checks;
    begin
      rank_cfg_sel = pRANK_PULSE_CHECK_EN;
      #1;
      -> e_configure_rank;
      #1;  //enough time for rank configuration to loop through
    end
  endtask // enable_dq_pulse_width_checks
  
  task disable_dq_pulse_width_checks;
    begin
      rank_cfg_sel = pRANK_PULSE_CHECK_DIS;
      #1;
      -> e_configure_rank;
      #1;  //enough time for rank configuration to loop through
    end
  endtask // disable_dq_pulse_width_checks

  
  // disable/enable DQS to CK setup/hold checks
  // ------------------------------------------
  task enable_dqs_ck_setup_hold_checks;
    begin
      rank_cfg_sel = pRANK_DQS_CK_SETUP_CHECK_EN;
      #1;
      -> e_configure_rank;
      #1;  //enough time for rank configuration to loop through
    end
  endtask // enable_dqs_ck_setup_hold_checks
  
  task disable_dqs_ck_setup_hold_checks;
    begin
      rank_cfg_sel = pRANK_DQS_CK_SETUP_CHECK_DIS;
      #1;
      -> e_configure_rank;
      #1;  //enough time for rank configuration to loop through
    end
  endtask // disable_dqs_ck_setup_hold_checks

 
 // disable/enable Command and Addr setup/hold timingchecks
  // ------------------------------------------
  task enable_cmd_addr_timing_checks;
    begin
      rank_cfg_sel = pRANK_CMD_ADDR_TIMING_CHECK_EN;
      #1;
      -> e_configure_rank;
      #1;  //enough time for rank configuration to loop through
    end
  endtask // enable_cmd_addr_setup_hold_checks
  
  task disable_cmd_addr_timing_checks;
    begin
      rank_cfg_sel = pRANK_CMD_ADDR_TIMING_CHECK_DIS;
      #1;
      -> e_configure_rank;
      #1;  //enough time for rank configuration to loop through
    end
  endtask // disable_cmd_addr_timing_checks


  // disable/enable Control and Addr pulse width checks
  // ------------------------------------
  task enable_ctrl_addr_pulse_width_checks;
    begin
      rank_cfg_sel = pRANK_CTRL_ADDR_PULSE_CHECK_EN;
      #1;
      -> e_configure_rank;
      #1;  //enough time for rank configuration to loop through
    end
  endtask // enable_ctrl_addr_pulse_width_checks
  
  task disable_ctrl_addr_pulse_width_checks;
    begin
      rank_cfg_sel = pRANK_CTRL_ADDR_PULSE_CHECK_DIS;
      #1;
      -> e_configure_rank;
      #1;  //enough time for rank configuration to loop through
    end
  endtask // disable_ctrl_addr_pulse_width_checks

`ifdef DDR3
  // disable/enable ODTH{4,8} timing checks
  // ------------------------------------
  task enable_odth_timing_checks;
    begin
      rank_cfg_sel = pRANK_ODTH_TIMING_CHECK_EN;
      #1;
      -> e_configure_rank;
      #1;  //enough time for rank configuration to loop through
    end
  endtask // enable_odth_timing_checks

  task disable_odth_timing_checks;
    begin
      rank_cfg_sel = pRANK_ODTH_TIMING_CHECK_DIS;
      #1;
      -> e_configure_rank;
      #1;  //enough time for rank configuration to loop through
    end
  endtask // disable_odth_timing_checks
  // disable/enable DQS Latching timing checks
  // -----------------------------------------
  task enable_dqs_latch_timing_checks;
    begin
      rank_cfg_sel = pRANK_DQS_LATCH_EN;
      -> e_configure_rank;
      #0.001;
    end
  endtask // enable_dqs_latch_timing_checks

  task disable_dqs_latch_timing_checks;
    begin
      rank_cfg_sel = pRANK_DQS_LATCH_DIS;
      -> e_configure_rank;
      #0.001;
    end
  endtask // disable_dqs_latch_timing_checks
`endif
  
  // disable/enable rank monitors
  // ----------------------------
  task disable_all_rank_monitors;
    begin
      // disbales rank monitors on all ranks
      rank_cfg_sel = pRANK_MNT_DIS;
      #1;
      -> e_configure_rank;
      #1;  //enough time for rank configuration to loop through
    end
  endtask // disable_all_rank_monitors
  
  task enable_all_rank_monitors;
    begin
      // disbales rank monitors on all ranks
      rank_cfg_sel = pRANK_MNT_EN;
      #1;
      -> e_configure_rank;
      #1;  //enough time for rank configuration to loop through
    end
  endtask // enable_all_rank_monitors

  
  // disable/enable ODT monitors
  // ---------------------------
  task disable_all_odt_monitors;
    begin
      // disbales ODT monitors on all ranks
      rank_cfg_sel = pRANK_ODT_MNT_DIS;
      #1;
      -> e_configure_rank;
      #1;  //enough time for rank configuration to loop through
    end
  endtask // disable_all_odt_monitors
  
  task enable_all_odt_monitors;
    begin
      // disbales ODT monitors on all ranks
      rank_cfg_sel = pRANK_ODT_MNT_EN;
      #1;
      -> e_configure_rank;
      #1;  //enough time for rank configuration to loop through
    end
  endtask // enable_all_odt_monitors


  // disable/enable RTT monitors
  // ---------------------------
  task disable_all_rtt_monitors;
    begin
      // disbales RTT monitors on all ranks
      rank_cfg_sel = pRANK_RTT_MNT_DIS;
      #1;
      -> e_configure_rank;
      #1;  //enough time for rank configuration to loop through
    end
  endtask // disable_all_rtt_monitors
  
  task enable_all_rtt_monitors;
    begin
      // disbales RTT monitors on all ranks
      rank_cfg_sel = pRANK_RTT_MNT_EN;
      #1;
      -> e_configure_rank;
      #1;  //enough time for rank configuration to loop through
    end
  endtask // enable_all_rtt_monitors

  
  // disable/enable INIT monitors
  // ---------------------------
  task disable_all_init_monitors;
    begin
      // disbales INIT monitors on all ranks
      rank_cfg_sel = pRANK_INIT_MNT_DIS;
      #1;
      -> e_configure_rank;
      #1;  //enough time for rank configuration to loop through
    end
  endtask // disable_all_init_monitors
  
  task enable_all_init_monitors;
    begin
      // disbales INIT monitors on all ranks
      rank_cfg_sel = pRANK_INIT_MNT_EN;
      #1;
      -> e_configure_rank;
      #1;  //enough time for rank configuration to loop through
    end
  endtask // enable_all_init_monitors

 
  // disable/enable RESET_CKE monitors
  // ---------------------------
  task disable_all_reset_cke_monitors;
    begin
      // disbales RESET_CKE monitors on all ranks
      rank_cfg_sel = pRANK_RESET_CKE_MNT_DIS;
      #1;
      -> e_configure_rank;
      #1;  //enough time for rank configuration to loop through
    end
  endtask // disable_all_reset_cke_monitors
  
  task enable_all_reset_cke_monitors;
    begin
      // disbales RESET_CKE monitors on all ranks
      rank_cfg_sel = pRANK_RESET_CKE_MNT_EN;
      #1;
      -> e_configure_rank;
      #1;  //enough time for rank configuration to loop through
    end
  endtask // enable_all_reset_cke_monitors


  // disable/enable RDIMM monitors
  // ---------------------------
  task disable_all_rdimm_monitors;
    begin
      // disbales RDIMM monitors on all ranks
      rank_cfg_sel = pRANK_RDIMM_MNT_DIS;
      #1;
      -> e_configure_rank;
      #1;  //enough time for rank configuration to loop through
    end
  endtask // disable_all_rdimm_monitors
  
  task enable_all_rdimm_monitors;
    begin
      // disbales RDIMM monitors on all ranks
      rank_cfg_sel = pRANK_RDIMM_MNT_EN;
      #1;
      -> e_configure_rank;
      #1;  //enough time for rank configuration to loop through
    end
  endtask // enable_all_rdimm_monitors

  
  // disable/enable MPR monitors
  // ---------------------------
  task disable_all_mpr_monitors;
    begin
      // disbales MPR monitors on all ranks
      rank_cfg_sel = pRANK_MPR_MNT_DIS;
      #1;
      -> e_configure_rank;
      #1;  //enough time for rank configuration to loop through
    end
  endtask // disable_all_mpr_monitors
  
  task enable_all_mpr_monitors;
    begin
      // disbales MPR monitors on all ranks
      rank_cfg_sel = pRANK_MPR_MNT_EN;
      #1;
      -> e_configure_rank;
      #1;  //enough time for rank configuration to loop through
    end
  endtask // enable_all_mpr_monitors

 // disable/enable tPDMax checks
  // ----------------------------
  task disable_tpdmax_checks;
    begin
      rank_cfg_sel = pRANK_TPDMAX_CHECK_DIS;
      #1;
      -> e_configure_rank;
      #1;
    end
  endtask // disable_tpdmax_checks

  task enable_tpdmax_checks;
    begin
      rank_cfg_sel = pRANK_TPDMAX_CHECK_EN;
      #1;
      -> e_configure_rank;
      #1;
    end
  endtask // enable_tpdmax_checks  
  
  // Set fly-by delays on a rank
  // ---------------------------
  task set_fly_by_delay;
    input integer rank_idx;
    input integer chip_idx;
    input integer board_delay;
    
    integer auxbytecnt;
    integer index_ck, index_addr, index_ba, index_cid;     
    begin

`ifdef DDR2
      // no write leveling for DDR2
      board_delay = 0;
`elsif LPDDR2
      // no write leveling for LPDDR2
      board_delay = 0;
`endif
`ifdef DWC_DDRPHY_BOARD_DELAYS 
  `ifdef BIDIRECTIONAL_SDRAM_DELAYS

      `TB.u_ddr_board_cfg.config_delay("ck"    ,0, rank_idx, chip_idx, 0, board_delay);
      `TB.u_ddr_board_cfg.config_delay("ckn"   ,0, rank_idx, chip_idx, 0, board_delay); 
      `TB.u_ddr_board_cfg.config_delay("csn"   ,0, rank_idx, chip_idx, 0, board_delay);
      `TB.u_ddr_board_cfg.config_delay("cke"   ,0, rank_idx, chip_idx, 0, board_delay);
      `TB.u_ddr_board_cfg.config_delay("odt"   ,0, rank_idx, chip_idx, 0, board_delay); 
      `TB.u_ddr_board_cfg.config_delay("rasn"  ,0, rank_idx, chip_idx, 0, board_delay);
      `TB.u_ddr_board_cfg.config_delay("casn"  ,0, rank_idx, chip_idx, 0, board_delay);
      `TB.u_ddr_board_cfg.config_delay("wen"   ,0, rank_idx, chip_idx, 0, board_delay);
      `TB.u_ddr_board_cfg.config_delay("actn"  ,0, rank_idx, chip_idx, 0, board_delay);
      `TB.u_ddr_board_cfg.config_delay("parin" ,0, rank_idx, chip_idx, 0, board_delay); 
      `TB.u_ddr_board_cfg.config_delay("alertn",0, rank_idx, chip_idx, 0, board_delay);
      
      for(index_cid = 0; index_cid < pCID_DELAY_WIDTH; index_cid = index_cid + 1) begin 
        `TB.u_ddr_board_cfg.config_delay("cid" ,0, rank_idx, chip_idx, index_cid,  board_delay);     
      end
      
      for(index_addr = 0; index_addr < pADDR_DELAY_WIDTH; index_addr = index_addr + 1) begin
        `TB.u_ddr_board_cfg.config_delay("addr",0, rank_idx, chip_idx, index_addr, board_delay);
      end
      
      for(index_ba = 0; index_ba < pBA_DELAY_WIDTH; index_ba = index_ba + 1) begin
        `TB.u_ddr_board_cfg.config_delay("ba"  ,0, rank_idx, chip_idx, index_ba,   board_delay);
      end
      #1;
      `TB.u_ddr_board_cfg.set_board_cfg ;
      #1;  //enough time for rank configuration to loop through
  `endif
`endif
    end
  endtask // set_fly_by_delay

  // Set read board delay  ->> used for `OUT direction
  // -------------------------------------------------
  task set_read_board_delay;
    input integer rank_idx;
    input integer chip_idx;
    input integer board_delay;
    
    integer auxbytecnt;
    integer index_dq, index_dqs;
    begin

`ifdef DWC_DDRPHY_BOARD_DELAYS 
  `ifdef BIDIRECTIONAL_SDRAM_DELAYS
      ///* -----\/----- EXCLUDED -----\/-----      
  /*`ifdef SDRAMx32     
      for (auxbytecnt = 0; auxbytecnt < 4; auxbytecnt = auxbytecnt + 1) begin
        
        for(index_dqs = 0; index_dqs < pDQS_DELAY_WIDTH; index_dqs = index_dqs + 1) begin 
          `TB.u_ddr_board_cfg.config_delay("dqs" ,`IN, rank_idx, chip_idx/4 + auxbytecnt, index_dqs, board_delay);
          `TB.u_ddr_board_cfg.config_delay("dqsn",`IN, rank_idx, chip_idx/4 + auxbytecnt, index_dqs, board_delay);
          `TB.u_ddr_board_cfg.config_delay("dm"  ,`IN, rank_idx, chip_idx/4 + auxbytecnt, index_dqs, board_delay);
        end
        
        for(index_dq = 0; index_dq < pDQ_DELAY_WIDTH; index_dq = index_dq + 1) begin
          `TB.u_ddr_board_cfg.config_delay("dq"  ,`IN, rank_idx, chip_idx/4 + auxbytecnt, index_dq,  board_delay);
        end
      end     
      `elsif SDRAMx16
        for (auxbytecnt = 0; auxbytecnt < 2; auxbytecnt = auxbytecnt + 1) begin 
          
          for(index_dqs = 0; index_dqs < pDQS_DELAY_WIDTH; index_dqs = index_dqs + 1) begin 
            `TB.u_ddr_board_cfg.config_delay("dqs" ,`IN, rank_idx, chip_idx/2 + auxbytecnt, index_dqs, board_delay);
            `TB.u_ddr_board_cfg.config_delay("dqsn",`IN, rank_idx, chip_idx/2 + auxbytecnt, index_dqs, board_delay);
            `TB.u_ddr_board_cfg.config_delay("dm"  ,`IN, rank_idx, chip_idx/2 + auxbytecnt, index_dqs, board_delay);
          end
          
          for(index_dq = 0; index_dq < pDQ_DELAY_WIDTH; index_dq = index_dq + 1) begin
            `TB.u_ddr_board_cfg.config_delay("dq"  ,`IN, rank_idx, chip_idx/2 + auxbytecnt, index_dq,  board_delay);
          end
        end     
  `else   */   
      // -----/\----- EXCLUDED -----/\----- */
      for(index_dqs = 0; index_dqs < pDQS_DELAY_WIDTH; index_dqs = index_dqs + 1) begin 
        `TB.u_ddr_board_cfg.config_delay("dqs" ,`IN, rank_idx, chip_idx, index_dqs, board_delay);
        `TB.u_ddr_board_cfg.config_delay("dqsn",`IN, rank_idx, chip_idx, index_dqs, board_delay);
        `TB.u_ddr_board_cfg.config_delay("dm"  ,`IN, rank_idx, chip_idx, index_dqs, board_delay);
      end
      
      for(index_dq = 0; index_dq < pDQ_DELAY_WIDTH; index_dq = index_dq + 1) begin
        `TB.u_ddr_board_cfg.config_delay("dq"  ,`IN, rank_idx, chip_idx, index_dq, board_delay);
      end
 // `endif  
      #1;
      `TB.u_ddr_board_cfg.set_board_cfg ;
      #1;  //enough time for rank configuration to loop through
  `endif    
`endif    
    end
  endtask

  // Set write board delay  ->> used for `OUT direction
  // -------------------------------------------------
  task set_write_board_delay;
    input integer rank_idx;
    input integer chip_idx;
    input integer board_delay;
    
    integer   auxbytecnt, index_dqs, index_dq;
    begin

`ifdef DWC_DDRPHY_BOARD_DELAYS 
  `ifdef BIDIRECTIONAL_SDRAM_DELAYS
      ///* -----\/----- EXCLUDED -----\/-----
 /* `ifdef SDRAMx32     
      for (auxbytecnt = 0; auxbytecnt < 4; auxbytecnt = auxbytecnt + 1) begin 
        
        for(index_dqs = 0; index_dqs < pDQS_DELAY_WIDTH; index_dqs = index_dqs + 1) begin 
          `TB.u_ddr_board_cfg.config_delay("dqs" ,`OUT, rank_idx, chip_idx/4 + auxbytecnt, index_dqs, board_delay);
          `TB.u_ddr_board_cfg.config_delay("dqsn",`OUT, rank_idx, chip_idx/4 + auxbytecnt, index_dqs, board_delay);
          `TB.u_ddr_board_cfg.config_delay("dm"  ,`OUT, rank_idx, chip_idx/4 + auxbytecnt, index_dqs, board_delay);
        end
        
        for(index_dq = 0; index_dq < pDQ_DELAY_WIDTH; index_dq = index_dq + 1) begin
          `TB.u_ddr_board_cfg.config_delay("dq"  ,`OUT, rank_idx, chip_idx/4 + auxbytecnt, index_dq,  board_delay);
        end
      end     
      `elsif SDRAMx16
        for (auxbytecnt = 0; auxbytecnt < 2; auxbytecnt = auxbytecnt + 1) begin 
          
          for(index_dqs = 0; index_dqs < pDQS_DELAY_WIDTH; index_dqs = index_dqs + 1) begin 
            `TB.u_ddr_board_cfg.config_delay("dqs" ,`OUT, rank_idx, chip_idx/2 + auxbytecnt, index_dqs, board_delay);
            `TB.u_ddr_board_cfg.config_delay("dqsn",`OUT, rank_idx, chip_idx/2 + auxbytecnt, index_dqs, board_delay);
            `TB.u_ddr_board_cfg.config_delay("dm"  ,`OUT, rank_idx, chip_idx/2 + auxbytecnt, index_dqs, board_delay);
          end
          
          for(index_dq = 0; index_dq < pDQ_DELAY_WIDTH; index_dq = index_dq + 1) begin
            `TB.u_ddr_board_cfg.config_delay("dq"  ,`OUT, rank_idx, chip_idx/2 + auxbytecnt, index_dq,  board_delay);
          end
        end     
  `else    */  
      // -----/\----- EXCLUDED -----/\----- */
      for(index_dqs = 0; index_dqs < pDQS_DELAY_WIDTH; index_dqs = index_dqs + 1) begin 
        `TB.u_ddr_board_cfg.config_delay("dqs" ,`OUT, rank_idx, chip_idx, index_dqs, board_delay);
        `TB.u_ddr_board_cfg.config_delay("dqsn",`OUT, rank_idx, chip_idx, index_dqs, board_delay);
        `TB.u_ddr_board_cfg.config_delay("dm"  ,`OUT, rank_idx, chip_idx, index_dqs, board_delay);
      end
      
      for(index_dq = 0; index_dq < pDQ_DELAY_WIDTH; index_dq = index_dq + 1) begin
        `TB.u_ddr_board_cfg.config_delay("dq"  ,`OUT, rank_idx, chip_idx, index_dq,  board_delay);
      end
  //`endif
      #1;
      `TB.u_ddr_board_cfg.set_board_cfg ;
      #1;
  `endif    
`endif    
    end
  endtask

  // Set write-leveling feedback bits for a chip
  // -------------------------------------------
  task set_wl_feedback_bits;
    input integer rank_idx;
    input integer chip_idx;
    input integer all_bits;
    input integer bit_idx;
    begin
      rank_cfg_id     = rank_idx;
      rank_cfg_sel    = pRANK_WL_FDBACK;
      rank_cfg_val[0] = chip_idx;
      rank_cfg_val[1] = `TRUE;
      rank_cfg_val[2] = bit_idx;
      #1;
      -> e_configure_rank;
      #1;  //enough time for rank configuration to loop through
    end
  endtask // set_wl_feedback_bits
  
  // Set rank byte en 
  // --------------------
  task set_rank_byte_enable_per_channel;
    input integer rank_idx;
    input integer chip_idx;
    input integer byte_en;
    begin
      rank_cfg_id     = rank_idx;
      rank_cfg_sel    = pRANK_BYTE_ENABLE_PER_CHNL;
      rank_cfg_val[0] = byte_en;
      -> e_configure_rank;
      #0.0001;
    end
  endtask
  
  
  always @(e_disconn_rank) begin
    // Disconnect the dq data bus too.
    #20.0;
    `TB.data_disc = 1;
    // Disconnect the ck bus after 10ns, to ensure tCKSRE satisfied
    #10.0;
    `TB.ck_disc = 1;
    #10.0;
  end  
            
  always @(e_data_ck) begin
    // Default connect all dq lines.  Only pRANK_DISCONNECT_ALL disconnects
    // it.
    `TB.data_disc = 0;
    // Connect the ck bus after 10ns, to ensure tCKSRE satisfied
    #10.0;
    `TB.ck_disc = 0;
  end
                        
  always @(e_conn_rank_all) begin
    #20.0;
    `TB.ck_disc = 0;
    #50.0;
  end
  
  // event -driven calls to control only the enabled ranks
  generate
    for (dwc_dim=0; dwc_dim<`DWC_NO_OF_DIMMS; dwc_dim=dwc_dim+1) begin:ddr_dimm
      for (dwc_rnk=0; dwc_rnk<`DWC_RANKS_PER_DIMM; dwc_rnk=dwc_rnk+1) begin:ddr_rank
      always @(e_configure_rank) begin: u_configure_rank
        -> e_data_ck;
        case (rank_cfg_sel)
          pRANK_DISCONNECT_ALL: begin
  `ifdef DWC_DDRPHY_EMUL_XILINX
           `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[dwc_rnk].sdram_rank.disconnect_rank_async;
  `else
           `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[dwc_rnk].sdram_rank.disconnect_rank;
  `endif
            `TB.dwc_dimm[dwc_dim].dwc_rank_mnt[0].u_ddr_mnt.disable_monitor;
            `TB.dwc_dimm[dwc_dim].dwc_rank_mnt[0].u_ddr_mnt.disable_odt_monitor;
            `TB.dwc_dimm[dwc_dim].dwc_rank_mnt[0].u_ddr_mnt.disable_rtt_monitor;
            
          -> e_disconn_rank;
          end
          pRANK_CONNECT_ALL    : begin
          -> e_conn_rank_all;
          
  `ifdef DWC_DDRPHY_EMUL_XILINX
             `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[dwc_rnk].sdram_rank.connect_rank_async;
  `else
             `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[dwc_rnk].sdram_rank.connect_rank;
  `endif
          end
          pRANK_CONNECT_CHIPS  : begin
            `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[dwc_rnk].sdram_rank.connect_chips(rank_cfg_val[0]);
          end
          pRANK_BYTE_EN        : begin
            `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[dwc_rnk].sdram_rank.set_byte_enables(rank_cfg_val[0]);
          end

          pRANK_TPDMAX_CHECK_EN : begin
            `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[dwc_rnk].sdram_rank.enable_tpdmax_checks;
          end

          pRANK_TPDMAX_CHECK_DIS : begin
            `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[dwc_rnk].sdram_rank.disable_tpdmax_checks;
          end        

          pRANK_CLOCK_CHECK_EN : `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[dwc_rnk].sdram_rank.enable_clock_checks;
          pRANK_CLOCK_CHECK_DIS: begin
            `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[dwc_rnk].sdram_rank.disable_clock_checks;
          end
          pRANK_RFSH_CHECK_EN  : `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[dwc_rnk].sdram_rank.enable_refresh_check;
          pRANK_RFSH_CHECK_DIS : `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[dwc_rnk].sdram_rank.disable_refresh_check;
`ifdef DDR4
`else     
          pRANK_SETUP_CHECK_EN : `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[dwc_rnk].sdram_rank.enable_dq_setup_hold_checks;
          pRANK_SETUP_CHECK_DIS: `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[dwc_rnk].sdram_rank.disable_dq_setup_hold_checks;
          pRANK_PULSE_CHECK_EN : `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[dwc_rnk].sdram_rank.enable_dq_pulse_width_checks;
          pRANK_PULSE_CHECK_DIS: `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[dwc_rnk].sdram_rank.disable_dq_pulse_width_checks;
`endif
          pRANK_MNT_EN         : `TB.dwc_dimm[dwc_dim].dwc_rank_mnt[dwc_rnk].u_ddr_mnt.enable_monitor;
          pRANK_MNT_DIS        : `TB.dwc_dimm[dwc_dim].dwc_rank_mnt[dwc_rnk].u_ddr_mnt.disable_monitor;
          pRANK_ODT_MNT_EN     : `TB.dwc_dimm[dwc_dim].dwc_rank_mnt[dwc_rnk].u_ddr_mnt.enable_odt_monitor;
          pRANK_ODT_MNT_DIS    : `TB.dwc_dimm[dwc_dim].dwc_rank_mnt[dwc_rnk].u_ddr_mnt.disable_odt_monitor;
          pRANK_RTT_MNT_EN     : `TB.dwc_dimm[dwc_dim].dwc_rank_mnt[dwc_rnk].u_ddr_mnt.enable_rtt_monitor;
          pRANK_RTT_MNT_DIS    : `TB.dwc_dimm[dwc_dim].dwc_rank_mnt[dwc_rnk].u_ddr_mnt.disable_rtt_monitor;
          pRANK_UNDF_MNT_EN    : `TB.dwc_dimm[dwc_dim].dwc_rank_mnt[dwc_rnk].u_ddr_mnt.enable_undefined_warning;
          pRANK_UNDF_MNT_DIS   : `TB.dwc_dimm[dwc_dim].dwc_rank_mnt[dwc_rnk].u_ddr_mnt.disable_undefined_warning;
`ifdef DDR4
`else          
          // is this used anymore??
          //pRANK_QS_DLY         : `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[dwc_rnk].sdram_rank.delay_data_strobes(rank_cfg_val[0], rank_cfg_val[1]);
`endif
          pRANK_INIT_MNT_EN    : `TB.dwc_dimm[dwc_dim].dwc_rank_mnt[dwc_rnk].u_ddr_mnt.enable_init_monitor;
          pRANK_INIT_MNT_DIS   : `TB.dwc_dimm[dwc_dim].dwc_rank_mnt[dwc_rnk].u_ddr_mnt.disable_init_monitor;
          pRANK_RESET_CKE_MNT_EN    : `TB.dwc_dimm[dwc_dim].dwc_rank_mnt[dwc_rnk].u_ddr_mnt.enable_reset_cke_monitor;
          pRANK_RESET_CKE_MNT_DIS   : `TB.dwc_dimm[dwc_dim].dwc_rank_mnt[dwc_rnk].u_ddr_mnt.disable_reset_cke_monitor;
`ifdef DDR4
`else          
          pRANK_DQS_CK_SETUP_CHECK_EN : `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[dwc_rnk].sdram_rank.enable_dqs_ck_setup_hold_checks;
          pRANK_DQS_CK_SETUP_CHECK_DIS: `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[dwc_rnk].sdram_rank.disable_dqs_ck_setup_hold_checks;
          pRANK_CMD_ADDR_TIMING_CHECK_EN : `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[dwc_rnk].sdram_rank.enable_cmd_addr_timing_checks;
          pRANK_CMD_ADDR_TIMING_CHECK_DIS :`TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[dwc_rnk].sdram_rank.disable_cmd_addr_timing_checks;
          pRANK_CTRL_ADDR_PULSE_CHECK_EN : `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[dwc_rnk].sdram_rank.enable_ctrl_addr_pulse_width_checks;
          pRANK_CTRL_ADDR_PULSE_CHECK_DIS :`TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[dwc_rnk].sdram_rank.disable_ctrl_addr_pulse_width_checks;
  `ifdef DDR3
      	  pRANK_ODTH_TIMING_CHECK_EN : `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[dwc_rnk].sdram_rank.enable_odth_timing_checks;
          pRANK_ODTH_TIMING_CHECK_DIS: `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[dwc_rnk].sdram_rank.disable_odth_timing_checks;
          pRANK_DQS_LATCH_EN         : `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[dwc_rnk].sdram_rank.enable_dqs_latch_timing_checks;
          pRANK_DQS_LATCH_DIS        : `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[dwc_rnk].sdram_rank.disable_dqs_latch_timing_checks;
  `endif
`endif
          pRANK_RDIMM_MNT_EN   : `TB.dwc_dimm[dwc_dim].dwc_rank_mnt[dwc_rnk].u_ddr_mnt.enable_rdimm_monitor;
          pRANK_RDIMM_MNT_DIS  : `TB.dwc_dimm[dwc_dim].dwc_rank_mnt[dwc_rnk].u_ddr_mnt.disable_rdimm_monitor;
          pRANK_MPR_MNT_EN     : `TB.dwc_dimm[dwc_dim].dwc_rank_mnt[dwc_rnk].u_ddr_mnt.enable_mpr_monitor;
          pRANK_MPR_MNT_DIS    : `TB.dwc_dimm[dwc_dim].dwc_rank_mnt[dwc_rnk].u_ddr_mnt.disable_mpr_monitor;
          default: begin
`ifdef DDR4
`else            
            // delays are not from rank_models anymore

            // execute only on the selectec rank
            if (dwc_dim+dwc_rnk == rank_cfg_id) begin
              case (rank_cfg_sel)
 
                //pRANK_FLYBY_DLY: ;//`TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[dwc_rnk].sdram_rank.set_fly_by_delay     (rank_cfg_val[0], rank_cfg_val[1]); // ->> Miguel Board Delays Update
                //pRANK_RDBRD_DLY: `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[dwc_rnk].sdram_rank.set_read_board_delay (rank_cfg_val[0], rank_cfg_val[1]);
                //pRANK_WRBRD_DLY: `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[dwc_rnk].sdram_rank.set_write_board_delay(rank_cfg_val[0], rank_cfg_val[1]);
  `ifdef DDR3
                pRANK_WL_FDBACK: `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[dwc_rnk].sdram_rank.set_wl_feedback_bits (rank_cfg_val[0], rank_cfg_val[1], rank_cfg_val[2]);
  `endif
                //pRANK_CHIP_DIS_MASK : `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[dwc_rnk].sdram_rank.set_chip_dis_mask(rank_cfg_val[0]);          
                pRANK_BYTE_ENABLE_PER_CHNL: `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[dwc_rnk].sdram_rank.set_byte_enables (rank_cfg_val[0]);
                pRANK_BYTE_ENABLE_PER_CHNL_DIS_REF: `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[dwc_rnk].sdram_rank.set_byte_enables_disable_ref (rank_cfg_val[0]);
             endcase // case (rank_cfg_sel)
            end
`endif
          end
        endcase // case (rank_cfg_sel)
      end
   end // block: ddr_rank
   end // block: ddr_rank_2
  endgenerate

`ifdef DWC_DDRPHY_EMUL_XILINX
  generate
    for (dwc_dim=0; dwc_dim<`DWC_NO_OF_DIMMS; dwc_dim=dwc_dim+1) begin
      for (dwc_rnk=0; dwc_rnk<`DWC_RANKS_PER_DIMM; dwc_rnk=dwc_rnk+1) begin
        always @(e_emul_sdram_connect) begin: u_configure_rank_emul
          `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[dwc_rnk].sdram_rank.connect_rank_async;
        end
      end
    end
  endgenerate
`endif

  
  // access only one rank
  // --------------------


  // reset SDRAM model refresh
  // -------------------------
  // resets the refresh counter in the SDRAM model so that it does not issue
  // false refresh violations
  task reset_sdram_refresh;
    begin
      `SYS.init_done = 1'b0;
      `HOST.nop;
      `SYS.init_done = 1'b1;
      `HOST.sdram_nops(`GRM.t_rfc);
    end
  endtask // reset_sdram_refresh
  

  //---------------------------------------------------------------------------
  // DDR System Configuration
  //---------------------------------------------------------------------------
  // Miscellaneous tasks for configuring and controlling the DDR system
  // (DDR Controller and PHY)

  // enable/disable bytes (generic)
  task enable_bytes;
    input [pNUM_LANES-1:0] lane_en;
    reg [`DWC_NO_OF_BYTES-1:0] byte_en;

    integer i;
    integer rank_i;
    begin
       for (i=0; i<pNUM_LANES; i=i+1) begin
          if (`DWC_DX_NO_OF_DQS == 1)
            begin
               byte_en[i]            = lane_en[i];
               `GRM.dxngcr0[i][0] = lane_en[i];
               `GRM.dxngcr1[i][31:16] = {16{1'b0}}; //DDRG2MPHY: Based on PUB table 106 version 0.1 (10/28/2011). Setting DQ IO recievers for dynamic powerdown mode
               `GRM.dxngcr3[i][11:10] = {2{1'b0}};  //DDRG2MPHY: Based on PUB table 108 version 0.1 (10/28/2011). Setting DM IO receivers for dynamic powerdown mode
               `CFG.write_register(`DX0GCR0+(`DX_REG_RANGE*i), `GRM.dxngcr0[i]);
               `CFG.write_register(`DX0GCR1+(`DX_REG_RANGE*i), `GRM.dxngcr1[i]);
               `CFG.write_register(`DX0GCR3+(`DX_REG_RANGE*i), `GRM.dxngcr3[i]);

               `FCOV_REG.set_cov_registers_write(`DX0GCR0+(`DX_REG_RANGE*i),`GRM.dxngcr0[i],`VALUE_REGISTER_DATA);
               `FCOV_REG.set_cov_registers_write(`DX0GCR1+(`DX_REG_RANGE*i),`GRM.dxngcr1[i],`VALUE_REGISTER_DATA);
               `FCOV_REG.set_cov_registers_write(`DX0GCR3+(`DX_REG_RANGE*i),`GRM.dxngcr3[i],`VALUE_REGISTER_DATA);            
            end // if (`DWC_DX_NO_OF_DQS == 1)
          else
            begin
               if (i%2 == 0) // even lanes are nibble0
                 begin
                    byte_en[i/2]             = lane_en[i];       
                    `GRM.dxngcr0[i/2][0]     = lane_en[i];
                    `GRM.dxngcr1[i/2][31:16] = {16{1'b0}}; //DDRG2MPHY: Based on PUB table 106 version 0.1 (10/28/2011). Setting DQ IO recievers for dynamic powerdown mode
                    `GRM.dxngcr3[i/2][11:10] = {2{1'b0}};  //DDRG2MPHY: Based on PUB table 108 version 0.1 (10/28/2011). Setting DM IO receivers for dynamic powerdown mode
                    `CFG.write_register(`DX0GCR0+(`DX_REG_RANGE*(i/2)), `GRM.dxngcr0[i/2]);
                    `CFG.write_register(`DX0GCR1+(`DX_REG_RANGE*(i/2)), `GRM.dxngcr1[i/2]);
                    `CFG.write_register(`DX0GCR3+(`DX_REG_RANGE*(i/2)), `GRM.dxngcr3[i/2]);

                    `FCOV_REG.set_cov_registers_write(`DX0GCR0+(`DX_REG_RANGE*(i/2)),`GRM.dxngcr0[i/2],`VALUE_REGISTER_DATA);
                    `FCOV_REG.set_cov_registers_write(`DX0GCR1+(`DX_REG_RANGE*(i/2)),`GRM.dxngcr1[i/2],`VALUE_REGISTER_DATA);
                    `FCOV_REG.set_cov_registers_write(`DX0GCR3+(`DX_REG_RANGE*(i/2)),`GRM.dxngcr3[i/2],`VALUE_REGISTER_DATA);
                 end // if (i%2 == 0)
               else  // odd lanes are nibble1
                 begin
                    `GRM.dxngcr7[(i-1)/2][11:10] = {2{1'b0}}; 
                    `CFG.write_register(`DX0GCR7+(`DX_REG_RANGE*((i-1)/2)), `GRM.dxngcr7[(i-1)/2]);

                    `FCOV_REG.set_cov_registers_write(`DX0GCR7+(`DX_REG_RANGE*((i-1)/2)),`GRM.dxngcr7[(i-1)/2],`VALUE_REGISTER_DATA);
                 end // else: !if(i%2 == 0)
            end // else: !if(`DWC_DX_NO_OF_DQS == 1)
       end // for (i=0; i<pNUM_LANES; i=i+1)

      // disable/enable connections to the SDRAM
`ifdef DWC_USE_SHARED_AC_TB
      `DFI0.dfi_data_byte_disable = ~byte_en[(`DWC_NO_OF_BYTES/2)-1:0];
      `DFI1.dfi_data_byte_disable = ~byte_en[`DWC_NO_OF_BYTES-1:`DWC_NO_OF_BYTES/2];
        
      // disable/enable connections to the SDRAM
      for (rank_i=0;rank_i<pNO_OF_PRANKS; rank_i=rank_i+1) begin
        `SYS.rank_cfg_id     = rank_i;
        `SYS.rank_cfg_sel    = `SYS.pRANK_BYTE_ENABLE_PER_CHNL;
        `SYS.rank_cfg_val[0] = (rank_i%2 == 0) ? byte_en[(`DWC_NO_OF_BYTES/2)-1:0] :
                                                 byte_en[`DWC_NO_OF_BYTES-1:`DWC_NO_OF_BYTES/2];
        -> `SYS.e_configure_rank;
        #0.0001;
      end
`else
      `DFI.dfi_data_byte_disable = ~byte_en;

      rank_cfg_sel    = pRANK_BYTE_EN;
      rank_cfg_val[0] = byte_en;
      -> e_configure_rank;
      #0.0001;
`endif


      // Set the data mask for proper comparison of expected data
      repeat (2) @(posedge `SYS.clk);
      `GRM.set_byte_enable_mask(byte_en);

      // if some bytes are disabled, disable the flagging of undefined data 
      // buses as warnings because disabled bytes will drive 'z' on DQS and 
      // DQ buses
      if (!(&lane_en)) `SYS.disable_undefined_warning;
      
    end
  endtask // enable_bytes

  
  // enable/disable bytes (generic)
  // This is same as enable_bytes but without setting to dxngcr.dxen[0]
  task enable_bytes_ddr_rank_and_grm_mask;
    input [`DWC_NO_OF_BYTES-1:0] byte_en;

    integer i;
    begin
      // disable/enable connections to the SDRAM
      rank_cfg_sel = pRANK_BYTE_EN;
      rank_cfg_val[0] = byte_en;
      -> e_configure_rank;
      #1;

      // Set the data mask for proper comparison of expected data
      `GRM.set_byte_enable_mask(byte_en);
      
      // if some bytes are disabled, disable the flagging of undefined data 
      // buses as warnings because disabled bytes will drive 'z' on DQS and 
      // DQ buses
      if (!(&byte_en)) `SYS.disable_undefined_warning;
      
    end
  endtask // enable_bytes_ddr_rank_and_grm_mask


  // enables/disables PHY initialization bypass
  task enable_initialization_bypass;
    begin
      cfg_phy_init_byp(`TRUE);
    end
  endtask // enable_initialization_bypass
  
  task disable_initialization_bypass;
    begin
      cfg_phy_init_byp(`FALSE);
    end
  endtask // disable_initialization_bypass
  
  // triggers PHY initialization
  task trigger_initialization;
    begin
      phy_init;
    end
  endtask // trigger_initialization
  
  // ZQnCR: triggers ZQ calibration on per ZCTRL basic
  task trigger_zq_calibration;
    reg [31:0]  tmp;
    begin
      @(posedge `CFG.clk);
      // GEN2MPHY - there is no variable "i" in this task, also there is only 1
      //            ZQCR to control all the ZQ blocks, so only write to it.
      // `CFG.write_register(`ZQCR + 4*i, `GRM.zqcr);
      `CFG.write_register(`ZQCR, `GRM.zqcr);
      //Functional coverage   
      `FCOV_REG.set_cov_registers_write(`ZQCR, `GRM.zqcr ,`VALUE_REGISTER_DATA); 
      // trigger calibration of all impedance controllers
      `GRM.pir[0] = 1'b1;
      `GRM.pir[1] = 1'b1;
      // Also, don't forget to disable zcal bypass
      `GRM.pir[30] = 1'b0;
      tmp = `GRM.pir;
      @(posedge `CFG.clk);
      `CFG.write_register(`PIR, `GRM.pir);
      //Functional coverage   
      `FCOV_REG.set_cov_registers_write(`PIR ,tmp,`VALUE_REGISTER_DATA);
      `FCOV_REG.set_cov_init_trig_pll_dcal_phy_dram_scenario;
    end
  endtask // trigger_zq_calibration
  
  // ZQnCR: enables/disables ZQ calibrartion bypass
  task bypass_zq_calibration;
    begin
          // bypass calibration of all impedance controllers
          `GRM.pir[30] = 1'b1;
          tmp = `GRM.pir;
          @(posedge `CFG.clk);
          `CFG.write_register(`PIR, `GRM.pir);
          `FCOV_REG.set_cov_registers_write(`PIR ,tmp,`VALUE_REGISTER_DATA);
    end
  endtask // bypass_zq_calibration
  
   task end_zq_calibration_bypass;
     begin
           // bypass calibration of all impedance controllers
           tmp = `GRM.pir;
           @(posedge `CFG.clk);
           `CFG.write_register(`PIR, `GRM.pir);
           `FCOV_REG.set_cov_registers_write(`PIR ,tmp,`VALUE_REGISTER_DATA);
     end
   endtask // end_zq_calibration_bypass
 
  task wait_for_zq_calibration;
    begin
`ifdef DWC_DDRPHY_NO_PZQ
      @(posedge `CFG.clk);
`else
     `CFG.poll_register(`PGSR0, 3, 3, 1'b1, 100, 10000, "ZCal done complete");
      zcal_all_done = 1'b1;
      `CFG.poll_register(`PGSR0, 0, 0, 1'b1,  100, 3000000, "PUB initialization done...");
      init = 1'b1;
`endif
    end
  endtask // wait_for_zq_calibration

  task polling_zq_calibration_done;
    input integer zctrl_no;
    reg [31:0]   tmp;
    begin
      // polling status...
      `CFG.disable_read_compare;
      @(posedge `CFG.clk);
`ifdef DWC_DDRPHY_APB
      repeat (10) @(posedge `CFG.clk);
`endif
      `CFG.read_register_data(`ZQ0SR + 4*zctrl_no, tmp);

      while(tmp[31] == 1'b0) begin
        repeat (100) @(posedge clk);
        `CFG.read_register_data(`ZQ0SR + 4*zctrl_no, tmp);
      end

      $display("-> %0t: [SYSTEM] ZQ0SR.BDONE asserted...",$time);
      repeat (2) @(posedge `CFG.clk);      
      `CFG.enable_read_compare;
    end
  endtask // polling_zq_calibration_done

// PHY power-down mode
task set_phy_power_down;
  begin
    phy_power_down_1(1);
    phy_power_down_2(2'b01);
  end
endtask // phy_power_down


task reset_phy_power_down;
  begin
    phy_power_down_1(0);
    phy_power_down_2(2'b10);
  end
endtask // phy_power_down

//DDRG2MPHY: Added the dynamic powerdown task

task set_phy_dynamic_power_down;
begin
  phy_power_down_2(2'b00);
end
endtask

//DDRG2MPHY; updated the below task
  task phy_power_down_1;
    input enter_exit_1;
    integer i; 
    begin
      // put all PLLs in power-down
      `GRM.pllcr[30:29] = {2{enter_exit_1}};
      @(posedge `CFG.clk);
      `CFG.write_register(`PLLCR, `GRM.pllcr);      
      `FCOV_REG.set_cov_registers_write(`PLLCR,`GRM.pllcr,`VALUE_REGISTER_DATA);
       
      // put all AC SSTL I/Os in power-down
      `GRM.aciocr0[4]    = {1{enter_exit_1}}; //ACPDR
      `GRM.aciocr0[13:10] = {4{enter_exit_1}};
      `GRM.aciocr0[25:22] = {4{enter_exit_1}};
      `GRM.aciocr0[28:27] = {2{enter_exit_1}};
      @(posedge `CFG.clk);
      `CFG.write_register(`ACIOCR0, `GRM.aciocr0);
      `FCOV_REG.set_cov_registers_write(`ACIOCR0,`GRM.aciocr0,`VALUE_REGISTER_DATA);

       for (i=0;i<`DWC_NO_OF_BYTES;i=i+1)
       begin

//Power down controls for the DQSG IOS

         `GRM.dxngcr0[i][5:4]={2{enter_exit_1}};
         `CFG.write_register(`DX0GCR0+(i * `DX_REG_RANGE),`GRM.dxngcr0[i]);
         `CFG.nops(2);
          if (`DWC_DX_NO_OF_DQS == 2)
            begin
               `GRM.dxngcr7[i][19:18]={2{enter_exit_1}};
               `CFG.write_register(`DX0GCR7+(i * `DX_REG_RANGE),`GRM.dxngcr7[i]);
               `CFG.nops(2);
            end
       end
  
`ifdef DWC_DDR_RDIMM
      // put RDIMM signals in power-down
      `GRM.rdimmgcr0[16:15] = {2{enter_exit_1}};
      `GRM.rdimmgcr0[21:20] = {2{enter_exit_1}};
      `GRM.rdimmgcr0[26:25] = {2{enter_exit_1}};
      @(posedge `CFG.clk);
      `CFG.write_register(`RDIMMGCR0,`GRM.rdimmgcr0);
`endif
      `CFG.nops(5); //DDRG2MPHY: Reduced nops(10) to nops(5)
    end
  endtask // phy_power_down

//DDRG2MPHY; added the below task
  task phy_power_down_2;
    input[1:0] enter_exit_2;
    integer i; 
    begin
      // put all AC SSTL I/Os in power-down
      `GRM.aciocr2[31:0]  = {16{enter_exit_2}}; //APDD
      `GRM.aciocr4[7:0]   = {4{enter_exit_2}};  //CKPDD
      `GRM.aciocr4[15:8]  = {4{enter_exit_2}};  //CSPDD
      `GRM.aciocr4[17:16]  = enter_exit_2;      //RASPDD
      `GRM.aciocr4[19:18]  = enter_exit_2;      //CASPDD
      `GRM.aciocr4[21:20]  = enter_exit_2;      //WEPDD
      `GRM.aciocr4[27:22]  = {3{enter_exit_2}}; //BAPDD
      `GRM.aciocr4[29:28]  = enter_exit_2;      //PAPDD   
      `GRM.aciocr5[23:16]  = {4{enter_exit_2}}; //ODTPDD  
      `GRM.aciocr5[31:24]  = {4{enter_exit_2}}; //CKEPDD
      @(posedge `CFG.clk);
      `CFG.write_register(`ACIOCR2, `GRM.aciocr2);
      `CFG.write_register(`ACIOCR4, `GRM.aciocr4);
      `CFG.write_register(`ACIOCR5, `GRM.aciocr5); //DDR2GMPHY: Need to check whether 3 registers could be written one by one or not?

      `FCOV_REG.set_cov_registers_write(`ACIOCR2,`GRM.aciocr2,`VALUE_REGISTER_DATA);
      `FCOV_REG.set_cov_registers_write(`ACIOCR4,`GRM.aciocr4,`VALUE_REGISTER_DATA);
      `FCOV_REG.set_cov_registers_write(`ACIOCR5,`GRM.aciocr5,`VALUE_REGISTER_DATA); 
       
      // put all bytes SSTL I/Os in power-down
       for (i=0;i<`DWC_NO_OF_BYTES;i=i+1)
       begin

//Power down controls for the DQ[7:0] IOS

         `GRM.dxngcr1[i][31:0]={16{enter_exit_2}};
         `CFG.write_register(`DX0GCR1+(i * `DX_REG_RANGE),`GRM.dxngcr1[i]);
         `CFG.nops(2);
          

//Power down controls for the DM/DQS IOS

         `GRM.dxngcr3[i][3:0]={2{enter_exit_2}};
         `GRM.dxngcr3[i][11:8]={2{enter_exit_2}}; 
         `CFG.write_register(`DX0GCR3+(i * `DX_REG_RANGE),`GRM.dxngcr3[i]);
         `CFG.nops(2);

          if (`DWC_DX_NO_OF_DQS == 2)
            begin
               //Power down controls for the DQ[9] IOS and 

               `GRM.dxngcr7[i][15:12]={2{enter_exit_2}};
               `GRM.dxngcr7[i][3:0]={2{enter_exit_2}};
               `CFG.write_register(`DX0GCR7+(i * `DX_REG_RANGE),`GRM.dxngcr7[i]);
               `CFG.nops(2);
            end
          
       end 

      `CFG.nops(10);
    end
  endtask // phy_power_down
 

 
  // MR: sets the burst length
  task set_burst_length;
    input [3:0] burst_length;
    
    reg [2:0] bl;
    begin
      case (burst_length)
        2:       bl = 3'b001;
        4:       bl = 3'b010;
        8:       bl = 3'b011;
        default: bl = 3'b010; // unsupported defaults to 4
      endcase // case(burst_length)
      
      `GRM.mr[2:0] = bl;
      `GRM.write_controller_register(`MR, `GRM.mr);
    end
  endtask // set_burst_length
  
  // MR: sets the CAS latency
  task set_cas_latency;
    input [2:0] cl;
    begin
      `GRM.mr[6:4] = cl;
      `GRM.write_controller_register(`MR, `GRM.mr);
    end
  endtask // set_cas_latency

  // EMR: sets the additive CAS latency
  task set_additive_latency;
    input [1:0] al;
    integer rnk_idx;
    begin
      `GRM.emr[0][4:3] = al;
      `GRM.write_controller_register(`EMR1, `GRM.emr[0]);
    end
  endtask // set_additive_latency

  
  // DDR SDRAM Commands
  //-------------------
  // precharge: closes (deactivates) all DDR SDRAM bank
  task precharge_all;
    input [2:0] rank;
    begin
      `HOST.precharge_all(rank);
    end
  endtask // precharge_all
    
  // refresh: executes a refresh command
  task refresh;
    input [2:0] rank;
    begin
      `HOST.refresh;
    end
  endtask // refresh
    
  // SDRAM NOP; executes an SDRAM NOP
  task sdram_nop;
    begin
      `HOST.sdram_nop;
    end
  endtask // sdram_nop
      
  task sdram_nops;
    input [31:0] no_of_nops;
    integer i;
    begin
      for (i=0; i<no_of_nops; i=i+1)
      begin
        sdram_nop;
      end
    end
  endtask // nops

  
  // pll_bypass
  // ----------
  // bypasses PHY PLL using the pll bypass register bit in PLLCR
  task pll_bypass;
    begin
      pll_byp = 1'b1;
      cfg_phy_pll_byp(`TRUE);
    end
  endtask // pll_bypass

  
  task end_pll_bypass;
    begin
      if (pll_byp)
        begin
          pll_byp = 1'b0;          
          cfg_phy_pll_byp(`FALSE);
         end
    end
  endtask // end_pll_bypass

    
  // cal_bypass
  // ----------
  // bypasses PHY CAL either the call bypass pin or the cal bypass register
  // bit in PIR
  task cal_bypass;
    input mode;
    begin
      cal_byp  = 1'b1;
      bypass_mode = mode;
      cfg_phy_cal_byp(`TRUE);
    end
  endtask // cal_bypass

  
  task end_cal_bypass;
    begin
      if (cal_byp)
        begin
          cal_byp = 1'b0;          
          cfg_phy_cal_byp(`FALSE);
        end
    end
  endtask // end_cal_bypass

  // Setup PUB + PHY for DDL test
  task ddl_test_setup_pub_phy;
    integer   byte_no;
    reg [`REG_ADDR_WIDTH:0] reg_addr;
    begin
      // reset control pins for power down and output enable. 
      `GRM.dsgcr[14:13] = 2'b00; // diable power down
      `GRM.dsgcr[16]    = 1'b1;  // enable dto
      `CFG.write_register(`DSGCR, `GRM.dsgcr);
      //Functional coverage 
      `FCOV_REG.set_cov_registers_write(`DSGCR, `GRM.dsgcr,`VALUE_REGISTER_DATA);  
      `SYS.nops(4);

      // disable AC/DATX8 MDL calibration, reset AC/DATX8 macros without resetting PUB RTL
      // logic and power down the byte lane receivers
      $display("\n=> Disable assertion of VT drift and inhibit VT compensation");
      `GRM.pgcr1[25]    = 1'b0; // assert PHYHRST  
      `GRM.pgcr1[9]     = 1'b0; // disable AC MDL  
      `CFG.write_register(`PGCR1, `GRM.pgcr1);
      `GRM.pgcr6[0]    = 1'b0; // assert VT calculation inhibit
      `GRM.pgcr6[23:16]= 8'b0; // disable assertion of DDL VT drift signal 
      `CFG.write_register(`PGCR6, `GRM.pgcr6);
      //Functional coverage 
      `FCOV_REG.set_cov_registers_write(`PGCR1, `GRM.pgcr1 ,`VALUE_REGISTER_DATA);  
       
      $display("\n=> Disable the master delay line calibration and");
      $display  ("=> power down the byte lane receivers"); // TBD
      `GRM.dxccr[2] = 1'b0;    // Master delay line enable
      //`GRM.dxccr[4] = 1'b1;  // power down the byte lane receivers // - now reserved bit. TBD
      `CFG.write_register(`DXCCR, `GRM.dxccr);
      //Functional coverage 
      `FCOV_REG.set_cov_registers_write(`DXCCR, `GRM.dxccr,`VALUE_REGISTER_DATA);
      
      // keep the PHY FIFOs in reset to prevent false read data because of toggling DQS
      `GRM.pgcr0[26] = 1'b0; // PHY FIFO Reset
      `CFG.write_register(`PGCR0, `GRM.pgcr0);
 
      // Wait required for RTL simulation using the PHY behavioral model 
      // -Due to the #<delay> modeling of the LCDL we must wait for the
      // mdl calibration to complete.
      // -without the wait the MDL delays may toggle and cause
      // the simulation scheduler to miss an event and result in the wrong
      // dto output.
      $display("\n-> %t: For RTL simulation ONLY wait a long time for the last mdl calibration to complete.",$realtime);
      `SYS.nops(20000); // wait-time required for mdl calibration to be completely disabled   

      // initialize AC/DATX8 MDL values to 0 because the will be at an undetermined value when calibration halted
      for (byte_no=0; byte_no<`DWC_NO_OF_BYTES; byte_no=byte_no+1)
        begin
          reg_addr = `DX0MDLR0 + (`DX_REG_RANGE * byte_no);
          `CFG.write_register(reg_addr, 0);
          reg_addr = `DX0MDLR1 + (`DX_REG_RANGE * byte_no);
          `CFG.write_register(reg_addr, 0);
        end
      // ACMDLR1
      `CFG.write_register(`ACMDLR1, 0);
      repeat(50) @(posedge `CFG.clk);
      
      // De-assert the resets as they are not self-clearning 
      `GRM.pgcr1[25] = 1'b1; // assert DXHRST 
      `CFG.write_register(`PGCR1, `GRM.pgcr1);
      //Functional coverage 
      `FCOV_REG.set_cov_registers_write(`PGCR1, `GRM.pgcr1 ,`VALUE_REGISTER_DATA);  
      repeat(50) @(posedge `CFG.clk);         

      $display("\n=> Set oscillator test mode");
      `GRM.pgcr0[6]     = 1'b1;    // enable oscillator test mode
      `CFG.write_register(`PGCR0, `GRM.pgcr0);
      //Functional coverage 
      `FCOV_REG.set_cov_registers_write(`PGCR0, `GRM.pgcr0 ,`VALUE_REGISTER_DATA);
    end
  endtask // ddl_test_setup_pub_phy
  
  
  // initialization
  // --------------
  // bypasses initialization using either the bypass pin or the bypass register
  // bit in CCR
  task bypass_initialization;
    input mode;
    begin
      init_byp    = 1'b1;
      bypass_mode = mode;
      $display("-> %0t [SYSTEM] PHY INIT BYPASS thru PIR register bit INIT",$time);
      enable_initialization_bypass;
    end
  endtask // bypass_initialization
  
  // ends initialization by resetting initialization bypass (if it was enabled)
  task end_initialization;
    begin
      if (init_byp)
        begin
          init_byp = 1'b0;          
          disable_initialization_bypass;
        end
    end
  endtask // end_initialization


  // waits for power-down/self-refresh by polling the init pin
  task wait_for_power_down;
    begin
      //@(posedge init);
      `CFG.poll_register(`PGSR0, 0, 0, 1'b1,  100, 3000000, "PUB initialization done...");
      init = 1'b1;
    end
  endtask // wait_for_power_down

  
  // test mode
  // ---------
  // sets the test mode
  task set_test_mode;
    input [2:0] tst_mode;
    begin
      {scan_ms, test_mode} = tst_mode;
    end
  endtask // set_test_mode

  // configuration NOP
  // -----------------
  task cfg_nops;
    input [31:0] no_of_nops;
    integer i;
    begin
      `CFG.nops(no_of_nops);
    end
  endtask // cfg_nops

  task cfg_nop;
    begin
      `CFG.nops(1);
    end
  endtask // cfg_nop


  // skip register info
  // ------------------
  // used for register testcases, especially those that iterate through all 
  // registers and set random register data
  
  // avoid setting senstive bits
  // PIR: don't trigger the initialization, etc
  // ACIOCR: don't change output enable
  // PGCR0: don't change delay line oscillator test mode
  // PGCR1: don't change the vt inhibit bit
  //        don't change the filter depth
  // PLLCR: don't bypass PLL
  // DSGCR: don't change CK output enable
  // DXnGCR: don't disable the byte or disturb the PLL
  // DCURR: don't trigger DCU command execution
  // BIST: don't trigger BIST run
  // RDIMMGCR0: don't change direction (output enable) of ERR_OUT_B signal

//DDRG2MPHY updated the below function as per the DDRG2MPHY updated address fields. Need to update the function based on the new register set

  function [`REG_DATA_WIDTH-1:0] skip_special_bits;
    input [`REG_ADDR_WIDTH-1:0]  reg_addr;
    input [`REG_DATA_WIDTH-1:0]  reg_data;
    integer i;
    begin
      case (reg_addr)
        `PIR: 
          begin
            reg_data[1:0]  = `GRM.pir[1:0];
            reg_data[9]    = `GRM.pir[9];
            reg_data[17]   = `GRM.pir[17];
`ifdef DWC_DDRPHY_EMUL_XILINX
            reg_data[26:18]   = `GRM.pir[26:18];
            reg_data[31:27]   = `GRM.pir[31:27];  
`else
            reg_data[30:29]   = `GRM.pir[30:29];
`endif
          end
`ifdef DWC_PUB_CLOCK_GATING
        `CGCR:
          begin
            reg_data[7:0]   = `GRM.cgcr[7:0];
            reg_data[31:8]   = 24'd0;
          end
`endif

        `PGCR0:  begin
                   reg_data[5:1]= `GRM.pgcr0[5:1];
                   reg_data[6]  = `GRM.pgcr0[6];
                   reg_data[26] = `GRM.pgcr0[26];
                 end
        `PGCR1:  begin
                   reg_data[0]  = `GRM.pgcr1[0];
                   reg_data[6]  = `GRM.pgcr1[6];
                   reg_data[20]  = `GRM.pgcr1[20];
`ifdef DWC_DDRPHY_D4M_IO
                   reg_data[8:7] =`GRM.pgcr1[8:7];
`endif 
                   reg_data[9]  = `GRM.pgcr1[9]; 
                   reg_data[14:10] = `GRM.pgcr1[14:10]; 
`ifdef DWC_DDRPHY_EMUL_XILINX
                   reg_data[23:21] = `GRM.pgcr1[23:21]; // AC loop back valid delay
                   reg_data[25]    = `GRM.pgcr1[25]; 
                   reg_data[31:28] = `GRM.pgcr1[31:28]; // Loop Back not supported by emulation
`endif
                   reg_data[27] = `GRM.pgcr1[27]; 
                   reg_data[31] = `GRM.pgcr1[31];
                   reg_data[25] = `GRM.pgcr1[25];	    
                 end
        `PGCR3:  begin
                   reg_data[8]     = `GRM.pgcr3[8];
                   reg_data[23:16] = `GRM.pgcr3[23:16];
                 end
        `PGCR5:  begin
                   reg_data[1:0] = `GRM.pgcr5[1:0];
                 end
        `PGCR6:  begin
                   reg_data[0] = `GRM.pgcr6[0]; 
                   reg_data[1] = `GRM.pgcr6[1];
                 end
        `ACIOCR3:  begin
                   reg_data[7:0] = `GRM.aciocr3[7:0];
                 end		 		 
        `PLLCR:  begin
  `ifdef DWC_DDRPHY_PLL_TYPEB
                   reg_data[12]    = `GRM.pllcr[12];
                   reg_data[23]    = `GRM.pllcr[23];
                   reg_data[28]    = `GRM.pllcr[28];
  `else
                   reg_data[11]    = `GRM.pllcr[11];
                   reg_data[18]    = `GRM.pllcr[18];
                   reg_data[21]    = `GRM.pllcr[21];
  `endif
                   reg_data[31:29] = `GRM.pllcr[31:29];
                 end
        `PTR2:   begin
                   if(reg_data[4:0]   == 0) reg_data[4:0]   = 1;
                   if(reg_data[9:5]   == 0) reg_data[9:5]   = 1;
                   if(reg_data[14:10] == 0) reg_data[14:10] = 1;
                   if(reg_data[19:15] == 0) reg_data[19:15] = 1;
                 end
        // DDRG2MPHY - removing this special bit because bit 1 is now RESERVED bit (used to be ACOE bit).
        // `ACIOCR0: reg_data[1]     = `GRM.aciocr0[1]; //DDRG2MPHY need to change to ACBDLR1
        `DXCCR:  begin
                    reg_data[4:2]     = `GRM.dxccr[4:2];
                    reg_data[31:30]   = `GRM.dxccr[31:30];
                 end
        `DCR:    begin
                   reg_data[2:0] = `GRM.dcr[2:0];
                   if (`DWC_NO_SRA == 1)
                     reg_data[27] = `GRM.dcr[27];
                   if (`DWC_UDIMM == 1)
                     reg_data[29] = `GRM.dcr[29];
                 end
        `DTPR6:  begin
                   // Do not change the PUB RL or WL
                   reg_data[31:30] = `GRM.dtpr6[31:30];
                 end
        // DDRG2MPHY - Cannot switch the HDR/SDR modes during register testing as this will cause VT drift
        // and cause the VTDONE bit to be set.  HDR/SDR mode register is tested using -csdr/-psdr/-heoc/-hec/-hoc
        // so we are not creating a verification hole here.
        `DSGCR: 
          begin
            reg_data[0]     = 1'b0; // do not issue PHY update
            `ifdef DWC_AC_RST_USE
              reg_data[21]    = 1'b1;
            `endif
            reg_data[20:19] = `GRM.dsgcr[20:19];
            reg_data[13] = 1'b0;
          end
        `DTCR0:          
          begin
            reg_data[21]  = `GRM.dtcr0[21];
          end
        `DQSDR0: reg_data[0]   = 1'b0; // disable drift enable
        `DCURR : reg_data[3:0] = (`GRM.dcurr[3:0] == 4'h1)? 4'h0: `GRM.dcurr[3:0]; // do not trigger dcu run
        `BISTRR: reg_data[2:0] = `GRM.bistrr[2:0];
        
`ifdef DWC_DDRPHY_EMUL_XILINX
        // don't exercize CKE OE controls - generates mem models errors
        `ACIOCR5:reg_data[15:8] = `GRM.aciocr5[15:8]; 
`endif
        // don't enable the anti-aging during register tests
        `AACR :  reg_data[31:30] = `GRM.aacr[31:30]; 

        // skip the command trigger register bit
        `SCHCR0 :  reg_data[3:0] = 4'b0000; 

        `ZQCR: 
          begin
            //reg_data[0] = `GRM.zqcr[0];
            reg_data[1] = 1'b0;   // skip trigger zcal
            reg_data[2] = `GRM.zqcr[2];
            reg_data[10:8] = `GRM.zqcr[10:8];
            reg_data[13:11] = `GRM.zqcr[13:11];
            reg_data[16:14] = `GRM.zqcr[16:14];
            reg_data[24:17] = 8'b0;
            //reg_data[26:24] = `GRM.zqcr[26:24];
            //reg_data[26:24] = 3'b0;
            reg_data[27] = `GRM.zqcr[27];
          end
          
        `RIOCR3:
          begin
            reg_data[31:0] = 32'b0;
          end
          
        `RIOCR4:
          begin
            reg_data[31:16] = 16'b0;
          end
          
        `RIOCR5:
          begin
            reg_data[31:16] = 16'b0;
          end
          
        `ACIOCR0:
          begin
             reg_data[27] = 1'b0;
          end
          
        `ACIOCR2:
          begin
            reg_data[31:0] = 32'b0;
          end
          
        `ACIOCR4:
          begin
            reg_data[31:0] = 32'b0;
          end
          
        `ACBDLR10:
          begin
            reg_data[31:0] = 32'b0;
          end

        `RDIMMGCR0:
          begin
              reg_data[20] = 1'b0;
              reg_data[25] = 1'b0;
             if (`DWC_RDIMM == 1)
               reg_data[0] = `GRM.rdimmgcr0[0];

            `ifdef DWC_DDR_LRDIMM_EN
              reg_data[18] = `GRM.rdimmgcr0[18];
            `endif

             reg_data[21] = `GRM.rdimmgcr0[21];
             reg_data[23] = `GRM.rdimmgcr0[23]; 
          end
        `RDIMMCR1:
          begin
               reg_data[31:16] = 16'b0;
          end
         endcase // case(reg_addr)
      

      // loop thru the number of ZQ's and check the ZQCR bits
      // Skip bit 0 which is the ZCALBYP (calibration bypass bit). 
      // Skip bit 2 which is the ZQPD (powerdown). 
      // Skip bits 10:8 which is the PGWAIT (wait counter cycles)
      // Setting these bits will cause an error to be flagged since
      // calibration will be interrupted unexpectedly
      for (i=0; i<`DWC_NO_OF_ZQ_SEG; i=i+1)
      begin
        // for ZQnPR, cannot have ZQDIV[7:4] and ZQDIV[3:0] both equal to zero, this will 
        // cause an error
        if (reg_addr == (`ZQ0PR + (i*4)))
        begin
          reg_data[31:28] = `GRM.zqnpr[i][31:28];
          // if ZQDIV[7:4] is 0, change to random value
          if (reg_data[11:8] == 4'b0)
            reg_data[11:8] = 4'b1;

          // if ZQDIV[3:0] is 0, change to random value
          if (reg_data[15:12] == 4'b0)
            reg_data[15:12] = 4'b1;
          // ODT
          if (reg_data[19:16] == 4'b0)
            reg_data[19:16] = 4'b1;
        end
      end

      // loop thru the number of ZQ's and check the ZQnDR bits
      for (i=0; i<`DWC_NO_OF_ZQ; i=i+1)
      begin
        if (reg_addr == (`ZQ0DR + (i*4)))
        begin
          // Guarantee that ZDATA field is not equal to 0's
          if (reg_data[ 6: 0] == 'h0) reg_data[ 6: 0] = 'h1;
          if (reg_data[14: 8] == 'h0) reg_data[14: 8] = 'h1;
          if (reg_data[22:16] == 'h0) reg_data[22:16] = 'h1;
          if (reg_data[30:24] == 'h0) reg_data[30:24] = 'h1;
        end 
      end

      // byte lanes                             
      for (i=0; i<9; i=i+1)
        begin
          if (reg_addr == (`DX0GCR0 + (i * `DX_REG_RANGE)))
            begin
              reg_data[4]     = 1'b0;
              reg_data[0]     = `GRM.dxngcr0[i][0];
              reg_data[17:16] = `GRM.dxngcr0[i][17:16];
              reg_data[19]    = `GRM.dxngcr0[i][19];
            end
          if (reg_addr == (`DX0GCR1 + (i * `DX_REG_RANGE)))
            begin
                reg_data[15:0] = 16'b0;
            end
          if (reg_addr == (`DX0GCR3 + (i * `DX_REG_RANGE)))
            begin
                reg_data[1:0] = 2'b0;
                reg_data[9:8] = 2'b0;
              // force DSOEMODE [7:6] == 2'b00. As OE mode =off would put
              // X's on the qs gate and there is no external pullup/down
              // to simulate the actual board setting. In that case, Host will
              // see X on qvld coming in as a result. Need to resolve this later.
              // NB: somehow allowing only 2'b00 or 2'b01 would cause X's on the
              // qs_gate, so for the time being just force 2'b00 (default in GRM)
              reg_data[3:2]   = `GRM.dxngcr3[i][3:2];
              reg_data[7:6]   = `GRM.dxngcr3[i][7:6];
             end
           if (reg_addr == (`DX0GCR7 + (i  * `DX_REG_RANGE)))
             begin
                reg_data[1:0] = 2'b0;
                reg_data[9:8] = 2'b0;
                reg_data[18] = 1'b0;
              // force X4DSOEMODE [7:6] == 2'b00 and X4DXOEMODE [15:14] == 2'b00. 
              // As OE mode =off would put
              // X's on the qs gate and there is no external pullup/down
              // to simulate the actual board setting. In that case, Host will
              // see X on qvld coming in as a result. Need to resolve this later.
              // NB: somehow allowing only 2'b00 or 2'b01 would cause X's on the
              // qs_gate, so for the time being just force 2'b00 (default in GRM)
              reg_data[7:6]   = `GRM.dxngcr7[i][7:6];
              reg_data[15:14] = `GRM.dxngcr7[i][15:14];
             end
           if (reg_addr == (`DX0GCR2 + ( i * `DX_REG_RANGE)))
             begin
                // force DXOEMODE to 00 (Dynamic) since OE always ON causes X's on dq
                reg_data[31:16] = `GRM.dxngcr2[i][31:16];
             end
          if (reg_addr == (`DX0BDLR6 + (i * `DX_REG_RANGE)))
            begin
                reg_data[5:0] = 6'b0;
            end
          if (reg_addr == (`DX0BDLR9 + (i * `DX_REG_RANGE)))
            begin
                reg_data[5:0] = 6'b0;
            end
         end

       skip_special_bits = reg_data;
    end
  endfunction // skip_special_bits


  // skip special register addresses
  // these are registers that we don't want to randomly access (please give
  // reason below for each register); they will be tested in testcases
  // targeted for that partuclar functionality
  // *MDLR: These registers continously update their value and hence cannot
  //        compared correctly in the GRM
  // DCUDR: the contents of this register depends on the execution of command caches
  // Emulation Mode:
  //    GSR0, BDLR1, GTR, LCDLR1 LCDLR2 ZQnSR0 are registers being affected under the calibration,
  //    Thus, their value cannot compare with default in the GRM.

//DDRGR2MPHY: Need to update the below section for newly added registers

  function [`REG_ADDR_WIDTH-1:0] skip_special_registers;
    input [`REG_ADDR_WIDTH-1:0]  reg_addr;
    input [31:0]                 new_addr;
    reg                          block_no;
    begin
      
      if (
`ifdef DWC_DDRPHY_EMUL_XILINX
          reg_addr == `RANKIDR  ||
          reg_addr == `ACIOCR5  ||
          
          reg_addr == `ACMDLR0    ||
          reg_addr == `ACMDLR1    ||
          //DDL Registers 0-8
          reg_addr == `DX0BDLR2   ||
          reg_addr == `DX0BDLR3   ||
          reg_addr == `DX0BDLR4   ||
          reg_addr == `DX0LCDLR0  ||
          reg_addr == `DX0LCDLR1  ||
          reg_addr == `DX0LCDLR2  ||
          reg_addr == `DX0LCDLR3  ||
          reg_addr == `DX0LCDLR4  ||
          reg_addr == `DX0LCDLR5  ||
          reg_addr == `DX0MDLR0   ||
          reg_addr == `DX0MDLR1   ||
          reg_addr == `DX0GTR0    ||

          reg_addr == `DX1BDLR2   ||
          reg_addr == `DX1BDLR3   ||
          reg_addr == `DX1BDLR4   ||
          reg_addr == `DX1LCDLR0  ||
          reg_addr == `DX1LCDLR1  ||
          reg_addr == `DX1LCDLR2  ||
          reg_addr == `DX1LCDLR3  ||
          reg_addr == `DX1LCDLR4  ||
          reg_addr == `DX1LCDLR5  ||
          reg_addr == `DX1MDLR0   ||
          reg_addr == `DX1MDLR1   ||
          reg_addr == `DX1GTR0    ||

          reg_addr == `DX2BDLR2   ||
          reg_addr == `DX2BDLR3   ||
          reg_addr == `DX2BDLR4   ||
          reg_addr == `DX2LCDLR0  ||
          reg_addr == `DX2LCDLR1  ||
          reg_addr == `DX2LCDLR2  ||
          reg_addr == `DX2LCDLR3  ||
          reg_addr == `DX2LCDLR4  ||
          reg_addr == `DX2LCDLR5  ||
          reg_addr == `DX2MDLR0   ||
          reg_addr == `DX2MDLR1   ||
          reg_addr == `DX2GTR0    ||

          reg_addr == `DX3BDLR2   ||
          reg_addr == `DX3BDLR3   ||
          reg_addr == `DX3BDLR4   ||
          reg_addr == `DX3LCDLR0  ||
          reg_addr == `DX3LCDLR1  ||
          reg_addr == `DX3LCDLR2  ||
          reg_addr == `DX3LCDLR3  ||
          reg_addr == `DX3LCDLR4  ||
          reg_addr == `DX3LCDLR5  ||
          reg_addr == `DX3MDLR0   ||
          reg_addr == `DX3MDLR1   ||
          reg_addr == `DX3GTR0    ||

          reg_addr == `DX4BDLR2   ||
          reg_addr == `DX4BDLR3   ||
          reg_addr == `DX4BDLR4   ||
          reg_addr == `DX4LCDLR0  ||
          reg_addr == `DX4LCDLR1  ||
          reg_addr == `DX4LCDLR2  ||
          reg_addr == `DX4LCDLR3  ||
          reg_addr == `DX4LCDLR4  ||
          reg_addr == `DX4LCDLR5  ||
          reg_addr == `DX4MDLR0   ||
          reg_addr == `DX4MDLR1   ||
          reg_addr == `DX4GTR0    ||

          reg_addr == `DX5BDLR2   ||
          reg_addr == `DX5BDLR3   ||
          reg_addr == `DX5BDLR4   ||
          reg_addr == `DX5LCDLR0  ||
          reg_addr == `DX5LCDLR1  ||
          reg_addr == `DX5LCDLR2  ||
          reg_addr == `DX5LCDLR3  ||
          reg_addr == `DX5LCDLR4  ||
          reg_addr == `DX5LCDLR5  ||
          reg_addr == `DX5MDLR0   ||
          reg_addr == `DX5MDLR1   ||
          reg_addr == `DX5GTR0    ||

          reg_addr == `DX6BDLR2   ||
          reg_addr == `DX6BDLR3   ||
          reg_addr == `DX6BDLR4   ||
          reg_addr == `DX6LCDLR0  ||
          reg_addr == `DX6LCDLR1  ||
          reg_addr == `DX6LCDLR2  ||
          reg_addr == `DX6LCDLR3  ||
          reg_addr == `DX6LCDLR4  ||
          reg_addr == `DX6LCDLR5  ||
          reg_addr == `DX6MDLR0   ||
          reg_addr == `DX6MDLR1   ||
          reg_addr == `DX6GTR0    ||

          reg_addr == `DX7BDLR2   ||
          reg_addr == `DX7BDLR3   ||
          reg_addr == `DX7BDLR4   ||
          reg_addr == `DX7LCDLR0  ||
          reg_addr == `DX7LCDLR1  ||
          reg_addr == `DX7LCDLR2  ||
          reg_addr == `DX7LCDLR3  ||
          reg_addr == `DX7LCDLR4  ||
          reg_addr == `DX7LCDLR5  ||
          reg_addr == `DX7MDLR0   ||
          reg_addr == `DX7MDLR1   ||
          reg_addr == `DX7GTR0    ||

          reg_addr == `DX8BDLR2   ||
          reg_addr == `DX8BDLR3   ||
          reg_addr == `DX8BDLR4   ||
          reg_addr == `DX8LCDLR0  ||
          reg_addr == `DX8LCDLR1  ||
          reg_addr == `DX8LCDLR2  ||
          reg_addr == `DX8LCDLR3  ||
          reg_addr == `DX8LCDLR4  ||
          reg_addr == `DX8LCDLR5  ||
          reg_addr == `DX8MDLR0   ||
          reg_addr == `DX8MDLR1   ||
          reg_addr == `DX8GTR0    ||
          reg_addr == `IOVCR0     ||
          reg_addr == `IOVCR1     ||
          reg_addr == `VTCR0      ||
          reg_addr == `VTCR1      ||
          reg_addr == `PLLCR      ||
          reg_addr == `ZQCR       ||
          reg_addr == `ZQ0PR      ||
          reg_addr == `ZQ1PR      ||
          reg_addr == `ZQ2PR      ||
          reg_addr == `ZQ3PR      ||
          reg_addr == `ZQ0DR      ||
          reg_addr == `ZQ1DR      ||
          reg_addr == `ZQ2DR      ||
          reg_addr == `ZQ3DR      ||
          reg_addr == `ZQ0SR      ||
          reg_addr == `ZQ1SR      ||
          reg_addr == `ZQ2SR      ||
          reg_addr == `ZQ3SR      ||
          reg_addr == `DX0GTR0    ||
          reg_addr == `DX1GTR0    ||
          reg_addr == `DX2GTR0    ||
          reg_addr == `DX3GTR0    ||
          reg_addr == `DX4GTR0    ||
          reg_addr == `DX5GTR0    ||
          reg_addr == `DX6GTR0    ||
          reg_addr == `DX7GTR0    ||
          reg_addr == `DX8GTR0    ||
          // Maybe supported in the future
          reg_addr == `DX0GCR5    ||
          reg_addr == `DX0GCR6    ||
          reg_addr == `DX1GCR5    ||
          reg_addr == `DX1GCR6    ||
          reg_addr == `DX2GCR5    ||
          reg_addr == `DX2GCR6    ||
          reg_addr == `DX3GCR5    ||
          reg_addr == `DX3GCR6    ||
          reg_addr == `DX4GCR5    ||
          reg_addr == `DX4GCR6    ||
          reg_addr == `DX5GCR5    ||
          reg_addr == `DX5GCR6    ||
          reg_addr == `DX6GCR5    ||
          reg_addr == `DX6GCR6    ||
          reg_addr == `DX7GCR5    ||
          reg_addr == `DX7GCR6    ||
          reg_addr == `DX8GCR5    ||
          reg_addr == `DX8GCR6    
        
        //`ifndef DWC_DDRPHY_X4X2
          ||
          reg_addr == `DX0GCR7  ||
          reg_addr == `DX1GCR7  ||
          reg_addr == `DX2GCR7  ||
          reg_addr == `DX3GCR7  ||
          reg_addr == `DX4GCR7  ||
          reg_addr == `DX5GCR7  ||
          reg_addr == `DX6GCR7  ||
          reg_addr == `DX7GCR7  ||
          reg_addr == `DX8GCR7  ||
          reg_addr == `DX0GCR8  ||
          reg_addr == `DX1GCR8  ||
          reg_addr == `DX2GCR8  ||
          reg_addr == `DX3GCR8  ||
          reg_addr == `DX4GCR8  ||
          reg_addr == `DX5GCR8  ||
          reg_addr == `DX6GCR8  ||
          reg_addr == `DX7GCR8  ||
          reg_addr == `DX8GCR8  ||
          reg_addr == `DX0GCR9  ||
          reg_addr == `DX1GCR9  ||
          reg_addr == `DX2GCR9  ||
          reg_addr == `DX3GCR9  ||
          reg_addr == `DX4GCR9  ||
          reg_addr == `DX5GCR9  ||
          reg_addr == `DX6GCR9  ||
          reg_addr == `DX7GCR9  ||
          reg_addr == `DX8GCR9  ||
          reg_addr == `DX0BDLR7  ||
          reg_addr == `DX1BDLR7  ||
          reg_addr == `DX2BDLR7  ||
          reg_addr == `DX3BDLR7  ||
          reg_addr == `DX4BDLR7  ||
          reg_addr == `DX5BDLR7  ||
          reg_addr == `DX6BDLR7  ||
          reg_addr == `DX7BDLR7  ||
          reg_addr == `DX8BDLR7  ||
          reg_addr == `DX0BDLR8  ||
          reg_addr == `DX1BDLR8  ||
          reg_addr == `DX2BDLR8  ||
          reg_addr == `DX3BDLR8  ||
          reg_addr == `DX4BDLR8  ||
          reg_addr == `DX5BDLR8  ||
          reg_addr == `DX6BDLR8  ||
          reg_addr == `DX7BDLR8  ||
          reg_addr == `DX8BDLR8  ||
          reg_addr == `DX0BDLR9  ||
          reg_addr == `DX1BDLR9  ||
          reg_addr == `DX2BDLR9  ||
          reg_addr == `DX3BDLR9  ||
          reg_addr == `DX4BDLR9  ||
          reg_addr == `DX5BDLR9  ||
          reg_addr == `DX6BDLR9  ||
          reg_addr == `DX7BDLR9  ||
          reg_addr == `DX8BDLR9  ||
          reg_addr == `DX0GSR4  ||
          reg_addr == `DX1GSR4  ||
          reg_addr == `DX2GSR4  ||
          reg_addr == `DX3GSR4  ||
          reg_addr == `DX4GSR4  ||
          reg_addr == `DX5GSR4  ||
          reg_addr == `DX6GSR4  ||
          reg_addr == `DX7GSR4  ||
          reg_addr == `DX8GSR4  ||
          reg_addr == `DX0GSR5  ||
          reg_addr == `DX1GSR5  ||
          reg_addr == `DX2GSR5  ||
          reg_addr == `DX3GSR5  ||
          reg_addr == `DX4GSR5  ||
          reg_addr == `DX5GSR5  ||
          reg_addr == `DX6GSR5  ||
          reg_addr == `DX7GSR5  ||
          reg_addr == `DX8GSR5  ||
          reg_addr == `DX0GSR6  ||
          reg_addr == `DX1GSR6  ||
          reg_addr == `DX2GSR6  ||
          reg_addr == `DX3GSR6  ||
          reg_addr == `DX4GSR6  ||
          reg_addr == `DX5GSR6  ||
          reg_addr == `DX6GSR6  ||
          reg_addr == `DX7GSR6  ||
          reg_addr == `DX8GSR6  
        //`endif //  `ifndef DWC_DDRPHY_X4X2

  
`else //nominal PHY
 `ifndef DWC_DDRPHY_X4X2
                                
          reg_addr == `DX0GCR7  ||
          reg_addr == `DX1GCR7  ||
          reg_addr == `DX2GCR7  ||
          reg_addr == `DX3GCR7  ||
          reg_addr == `DX4GCR7  ||
          reg_addr == `DX5GCR7  ||
          reg_addr == `DX6GCR7  ||
          reg_addr == `DX7GCR7  ||
          reg_addr == `DX8GCR7  ||
          reg_addr == `DX0GCR8  ||
          reg_addr == `DX1GCR8  ||
          reg_addr == `DX2GCR8  ||
          reg_addr == `DX3GCR8  ||
          reg_addr == `DX4GCR8  ||
          reg_addr == `DX5GCR8  ||
          reg_addr == `DX6GCR8  ||
          reg_addr == `DX7GCR8  ||
          reg_addr == `DX8GCR8  ||
          reg_addr == `DX0GCR9  ||
          reg_addr == `DX1GCR9  ||
          reg_addr == `DX2GCR9  ||
          reg_addr == `DX3GCR9  ||
          reg_addr == `DX4GCR9  ||
          reg_addr == `DX5GCR9  ||
          reg_addr == `DX6GCR9  ||
          reg_addr == `DX7GCR9  ||
          reg_addr == `DX8GCR9  ||
          reg_addr == `DX0GSR4  ||
          reg_addr == `DX1GSR4  ||
          reg_addr == `DX2GSR4  ||
          reg_addr == `DX3GSR4  ||
          reg_addr == `DX4GSR4  ||
          reg_addr == `DX5GSR4  ||
          reg_addr == `DX6GSR4  ||
          reg_addr == `DX7GSR4  ||
          reg_addr == `DX8GSR4  ||
          reg_addr == `DX0GSR5  ||
          reg_addr == `DX1GSR5  ||
          reg_addr == `DX2GSR5  ||
          reg_addr == `DX3GSR5  ||
          reg_addr == `DX4GSR5  ||
          reg_addr == `DX5GSR5  ||
          reg_addr == `DX6GSR5  ||
          reg_addr == `DX7GSR5  ||
          reg_addr == `DX8GSR5  ||
          reg_addr == `DX0GSR6  ||
          reg_addr == `DX1GSR6  ||
          reg_addr == `DX2GSR6  ||
          reg_addr == `DX3GSR6  ||
          reg_addr == `DX4GSR6  ||
          reg_addr == `DX5GSR6  ||
          reg_addr == `DX6GSR6  ||
          reg_addr == `DX7GSR6  ||
          reg_addr == `DX8GSR6  ||
          reg_addr == `DX0BDLR7  ||
          reg_addr == `DX1BDLR7  ||
          reg_addr == `DX2BDLR7  ||
          reg_addr == `DX3BDLR7  ||
          reg_addr == `DX4BDLR7  ||
          reg_addr == `DX5BDLR7  ||
          reg_addr == `DX6BDLR7  ||
          reg_addr == `DX7BDLR7  ||
          reg_addr == `DX8BDLR7  ||
          reg_addr == `DX0BDLR8  ||
          reg_addr == `DX1BDLR8  ||
          reg_addr == `DX2BDLR8  ||
          reg_addr == `DX3BDLR8  ||
          reg_addr == `DX4BDLR8  ||
          reg_addr == `DX5BDLR8  ||
          reg_addr == `DX6BDLR8  ||
          reg_addr == `DX7BDLR8  ||
          reg_addr == `DX8BDLR8  ||
          reg_addr == `DX0BDLR9  ||
          reg_addr == `DX1BDLR9  ||
          reg_addr == `DX2BDLR9  ||
          reg_addr == `DX3BDLR9  ||
          reg_addr == `DX4BDLR9  ||
          reg_addr == `DX5BDLR9  ||
          reg_addr == `DX6BDLR9  ||
          reg_addr == `DX7BDLR9  ||
          reg_addr == `DX8BDLR9  ||
`endif //  `ifndef DWC_DDRPHY_X4X2
 `ifdef  DWC_DDRPHY_X4MODE
           reg_addr == `DXCCR  ||
 `endif
          reg_addr == `RANKIDR  ||
          reg_addr == `ACIOCR5  ||
          reg_addr == `ACMDLR0  ||
          reg_addr == `ACMDLR1  ||
          reg_addr == `DX0MDLR0 ||
          reg_addr == `DX1MDLR0 ||
          reg_addr == `DX2MDLR0 ||
          reg_addr == `DX3MDLR0 ||
          reg_addr == `DX4MDLR0 ||
          reg_addr == `DX5MDLR0 ||
          reg_addr == `DX6MDLR0 ||
          reg_addr == `DX7MDLR0 ||
          reg_addr == `DX8MDLR0 ||
          reg_addr == `DX0MDLR1 ||
          reg_addr == `DX1MDLR1 ||
          reg_addr == `DX2MDLR1 ||
          reg_addr == `DX3MDLR1 ||
          reg_addr == `DX4MDLR1 ||
          reg_addr == `DX5MDLR1 ||
          reg_addr == `DX6MDLR1 ||
          reg_addr == `DX7MDLR1 ||
          reg_addr == `DX8MDLR1 ||
          reg_addr == `ZQ0SR    ||
          reg_addr == `ZQ1SR    ||
          reg_addr == `ZQ2SR    ||
          reg_addr == `ZQ3SR    || //DDRG2MPHY: Added ZQnDR to skip_special_register as the calibration goes in background always
          reg_addr == `ZQ0DR    || //DDRG2MPHY: Added ZQnDR to skip_special_register as the calibration goes in background always
          reg_addr == `ZQ1DR    || //DDRG2MPHY: Added ZQnDR to skip_special_register as the calibration goes in background always
          reg_addr == `ZQ2DR    || //DDRG2MPHY: Added ZQnDR to skip_special_register as the calibration goes in background always
          reg_addr == `ZQ3DR    
          
`endif
          )
        begin
          case (new_addr)
            `NEXT_ADDR, `RND_ADDR: 
              begin
                case (reg_addr)
`ifdef DWC_DDRPHY_EMUL_XILINX
       `ACMDLR0     : reg_addr = `DX0GCR0; 
       `ACMDLR1     : reg_addr = `DX0GCR0; 

       `DX0BDLR2    : reg_addr = `DX1GCR0;
       `DX0BDLR3    : reg_addr = `DX1GCR0;
       `DX0BDLR4    : reg_addr = `DX1GCR0;
       `DX0LCDLR0   : reg_addr = `DX1GCR0;
       `DX0LCDLR1   : reg_addr = `DX1GCR0;
       `DX0LCDLR2   : reg_addr = `DX1GCR0;
       `DX0MDLR0     : reg_addr = `DX1GCR0;
       pDX0GTR      : reg_addr = `DX1GCR0;

       `DX1BDLR2    : reg_addr = `DX2GCR0;
       `DX1BDLR3    : reg_addr = `DX2GCR0;
       `DX1BDLR4    : reg_addr = `DX2GCR0;
       `DX1LCDLR0   : reg_addr = `DX2GCR0;
       `DX1LCDLR1   : reg_addr = `DX2GCR0;
       `DX1LCDLR2   : reg_addr = `DX2GCR0;
       `DX1MDLR0     : reg_addr = `DX2GCR0;
       pDX1GTR      : reg_addr = `DX2GCR0;

       `DX2BDLR2    : reg_addr = `DX3GCR0;
       `DX2BDLR3    : reg_addr = `DX3GCR0;
       `DX2BDLR4    : reg_addr = `DX3GCR0;
       `DX2LCDLR0   : reg_addr = `DX3GCR0;
       `DX2LCDLR1   : reg_addr = `DX3GCR0;
       `DX2LCDLR2   : reg_addr = `DX3GCR0;
       `DX2MDLR0     : reg_addr = `DX3GCR0;
       pDX2GTR      : reg_addr = `DX3GCR0;

       `DX3BDLR2    : reg_addr = `DX4GCR0;
       `DX3BDLR3    : reg_addr = `DX4GCR0;
       `DX3BDLR4    : reg_addr = `DX4GCR0;
       `DX3LCDLR0   : reg_addr = `DX4GCR0;
       `DX3LCDLR1   : reg_addr = `DX4GCR0;
       `DX3LCDLR2   : reg_addr = `DX4GCR0;
       `DX3MDLR0     : reg_addr = `DX4GCR0;
       pDX3GTR      : reg_addr = `DX4GCR0;

       `DX4BDLR2    : reg_addr = `DX5GCR0;
       `DX4BDLR3    : reg_addr = `DX5GCR0;
       `DX4BDLR4    : reg_addr = `DX5GCR0;
       `DX4LCDLR0   : reg_addr = `DX5GCR0;
       `DX4LCDLR1   : reg_addr = `DX5GCR0;
       `DX4LCDLR2   : reg_addr = `DX5GCR0;
       `DX4MDLR0     : reg_addr = `DX5GCR0;
       pDX4GTR      : reg_addr = `DX5GCR0;

       `DX5BDLR2    : reg_addr = `DX6GCR0;
       `DX5BDLR3    : reg_addr = `DX6GCR0;
       `DX5BDLR4    : reg_addr = `DX6GCR0;
       `DX5LCDLR0   : reg_addr = `DX6GCR0;
       `DX5LCDLR1   : reg_addr = `DX6GCR0;
       `DX5LCDLR2   : reg_addr = `DX6GCR0;
       `DX5MDLR0     : reg_addr = `DX6GCR0;
       pDX5GTR      : reg_addr = `DX6GCR0;

       `DX6BDLR2    : reg_addr = `DX7GCR0;
       `DX6BDLR3    : reg_addr = `DX7GCR0;
       `DX6BDLR4    : reg_addr = `DX7GCR0;
       `DX6LCDLR0   : reg_addr = `DX7GCR0;
       `DX6LCDLR1   : reg_addr = `DX7GCR0;
       `DX6LCDLR2   : reg_addr = `DX7GCR0;
       `DX6MDLR0     : reg_addr = `DX7GCR0;
       pDX6GTR      : reg_addr = `DX7GCR0;

       `DX7BDLR2    : reg_addr = `DX8GCR0;
       `DX7BDLR3    : reg_addr = `DX8GCR0;
       `DX7BDLR4    : reg_addr = `DX8GCR0;
       `DX7LCDLR0   : reg_addr = `DX8GCR0;
       `DX7LCDLR1   : reg_addr = `DX8GCR0;
       `DX7LCDLR2   : reg_addr = `DX8GCR0;
       `DX7MDLR0     : reg_addr = `DX8GCR0;
       pDX7GTR      : reg_addr = `DX8GCR0;

       `DX8BDLR2    : reg_addr = pDX8GTR+1;
       `DX8BDLR3    : reg_addr = pDX8GTR+1;
       `DX8BDLR4    : reg_addr = pDX8GTR+1;
       `DX8LCDLR0   : reg_addr = pDX8GTR+1;
       `DX8LCDLR1   : reg_addr = pDX8GTR+1;
       `DX8LCDLR2   : reg_addr = pDX8GTR+1;
       `DX8MDLR0     : reg_addr = pDX8GTR+1;
       pDX8GTR      : reg_addr = pDX8GTR+1; // will make loop stop

       // adding ZQ status registers since bits 7:0 of these registers
       // are continuously changing due to background calibration
       `ZQ0SR      : reg_addr = `DX0GCR0; 
       `ZQ1SR      : reg_addr = `DX0GCR0; 
       `ZQ2SR      : reg_addr = `DX0GCR0; 
       `ZQ3SR      : reg_addr = `DX0GCR0; 
       `ZQ0DR      : reg_addr = `DX0GCR0; //DDRG2MPHY: Added ZQnDR to skip_special_register as the calibration goes in background always 
       `ZQ1DR      : reg_addr = `DX0GCR0; //DDRG2MPHY: Added ZQnDR to skip_special_register as the calibration goes in background always
       `ZQ2DR      : reg_addr = `DX0GCR0; //DDRG2MPHY: Added ZQnDR to skip_special_register as the calibration goes in background always
       `ZQ3DR      : reg_addr = `DX0GCR0; //DDRG2MPHY: Added ZQnDR to skip_special_register as the calibration goes in background always
       
       `RANKIDR    : reg_addr = `RIOCR0;
       `ACIOCR5    : reg_addr = `ACBDLR0;
       
       `PLLCR      : reg_addr = `DXCCR;
       `IOVCR0     : reg_addr = `ACBDLR0;
       `IOVCR1     : reg_addr = `ACBDLR0;
       `VTCR0      : reg_addr = `ACBDLR0;
       `VTCR1      : reg_addr = `ACBDLR0;
       `ZQCR       : reg_addr = `DX0GCR0;
       `ZQ0PR      : reg_addr = `DX0GCR0;
       `ZQ1PR      : reg_addr = `DX0GCR0;
       `ZQ2PR      : reg_addr = `DX0GCR0;
       `ZQ3PR      : reg_addr = `DX0GCR0;
       `DX0GTR0    : reg_addr = `DX1GCR0;
       `DX1GTR0    : reg_addr = `DX2GCR0;
       `DX2GTR0    : reg_addr = `DX3GCR0;
       `DX3GTR0    : reg_addr = `DX4GCR0;
       `DX4GTR0    : reg_addr = `DX5GCR0;
       `DX5GTR0    : reg_addr = `DX6GCR0;
       `DX6GTR0    : reg_addr = `DX7GCR0;
       `DX7GTR0    : reg_addr = `DX8GCR0;
       `DX8GTR0    : reg_addr = `DX8GTR0+2;
       // Maybe supported in the future
       `DX0GCR5    : reg_addr = `DX0GSR0;
       `DX0GCR6    : reg_addr = `DX0GSR0;
       `DX1GCR5    : reg_addr = `DX1GSR0;
       `DX1GCR6    : reg_addr = `DX1GSR0;
       `DX2GCR5    : reg_addr = `DX2GSR0;
       `DX2GCR6    : reg_addr = `DX2GSR0;
       `DX3GCR5    : reg_addr = `DX3GSR0;
       `DX3GCR6    : reg_addr = `DX3GSR0;
       `DX4GCR5    : reg_addr = `DX4GSR0;
       `DX4GCR6    : reg_addr = `DX4GSR0;
       `DX5GCR5    : reg_addr = `DX5GSR0;
       `DX5GCR6    : reg_addr = `DX5GSR0;
       `DX6GCR5    : reg_addr = `DX6GSR0;
       `DX6GCR6    : reg_addr = `DX6GSR0;
       `DX7GCR5    : reg_addr = `DX7GSR0;
       `DX7GCR6    : reg_addr = `DX7GSR0;
       `DX8GCR5    : reg_addr = `DX8GSR0;
       `DX8GCR6    : reg_addr = `DX8GSR0;
       
      //`ifndef DWC_DDRPHY_X4X2 
       `DX0GCR7, `DX0GCR8, `DX0GCR9  : reg_addr = `DX0BDLR0;    
       `DX1GCR7, `DX1GCR8, `DX1GCR9  : reg_addr = `DX1BDLR0;    
       `DX2GCR7, `DX2GCR8, `DX2GCR9  : reg_addr = `DX2BDLR0;    
       `DX3GCR7, `DX3GCR8, `DX3GCR9  : reg_addr = `DX3BDLR0;    
       `DX4GCR7, `DX4GCR8, `DX4GCR9  : reg_addr = `DX4BDLR0;    
       `DX5GCR7, `DX5GCR8, `DX5GCR9  : reg_addr = `DX5BDLR0;    
       `DX6GCR7, `DX6GCR8, `DX6GCR9  : reg_addr = `DX6BDLR0;    
       `DX7GCR7, `DX7GCR8, `DX7GCR9  : reg_addr = `DX7BDLR0;    
       `DX8GCR7, `DX8GCR8, `DX8GCR9  : reg_addr = `DX8BDLR0;
       `DX0BDLR7,`DX0BDLR8,`DX0BDLR9   : reg_addr = `DX0LCDLR0;   
       `DX1BDLR7,`DX1BDLR8,`DX1BDLR9   : reg_addr = `DX1LCDLR0;   
       `DX2BDLR7,`DX2BDLR8,`DX2BDLR9   : reg_addr = `DX2LCDLR0;   
       `DX3BDLR7,`DX3BDLR8,`DX3BDLR9   : reg_addr = `DX3LCDLR0;   
       `DX4BDLR7,`DX4BDLR8,`DX4BDLR9   : reg_addr = `DX4LCDLR0;   
       `DX5BDLR7,`DX5BDLR8,`DX5BDLR9   : reg_addr = `DX5LCDLR0;   
       `DX6BDLR7,`DX6BDLR8,`DX6BDLR9   : reg_addr = `DX6LCDLR0;   
       `DX7BDLR7,`DX7BDLR8,`DX7BDLR9   : reg_addr = `DX7LCDLR0;   
       `DX8BDLR7,`DX8BDLR8,`DX8BDLR9   : reg_addr = `DX8LCDLR0;
       `DX0GSR4,`DX0GSR5,`DX0GSR6    : reg_addr = `DX0GSR6 + 1;  
       `DX1GSR4,`DX1GSR5,`DX1GSR6    : reg_addr = `DX1GSR6 + 1;  
       `DX2GSR4,`DX2GSR5,`DX2GSR6    : reg_addr = `DX2GSR6 + 1;  
       `DX3GSR4,`DX3GSR5,`DX3GSR6    : reg_addr = `DX3GSR6 + 1;  
       `DX4GSR4,`DX4GSR5,`DX4GSR6    : reg_addr = `DX4GSR6 + 1;  
       `DX5GSR4,`DX5GSR5,`DX5GSR6    : reg_addr = `DX5GSR6 + 1;  
       `DX6GSR4,`DX6GSR5,`DX6GSR6    : reg_addr = `DX6GSR6 + 1;  
       `DX7GSR4,`DX7GSR5,`DX7GSR6    : reg_addr = `DX7GSR6 + 1;  
       `DX8GSR4,`DX8GSR5,`DX8GSR6    : reg_addr = `LAST_REG_ADDR;
      //`endif
          
`else
//SPN_DEBUG - removed for deme_reg.v test for EA release.
                  `ACMDLR0:  reg_addr = `ACMDLR0+2;// skip ACMDLR0-1
                  `ACMDLR1:  reg_addr = `ACMDLR1+1;// skip ACMDLR1

                  // adding ZQ status registers since bits 7:0 of these registers
                  // are continuously changing due to background calibration
                  `ZQ0SR      : reg_addr = `ZQ1PR; 
                  `ZQ1SR      : reg_addr = `ZQ2PR; 
                  `ZQ2SR      : reg_addr = `ZQ3PR; 
                  `ZQ3SR      : reg_addr = `DX0GCR0; 
                  `ZQ0DR      : reg_addr = `ZQ1PR; //DDRG2MPHY: Added ZQnDR to skip_special_register as the calibration goes in background always
                  `ZQ1DR      : reg_addr = `ZQ2PR; //DDRG2MPHY: Added ZQnDR to skip_special_register as the calibration goes in background always
                  `ZQ2DR      : reg_addr = `ZQ3PR; //DDRG2MPHY: Added ZQnDR to skip_special_register as the calibration goes in background always
                  `ZQ3DR      : reg_addr = `DX0GCR0; //DDRG2MPHY: Added ZQnDR to skip_special_register as the calibration goes in background always
                  `RANKIDR    : reg_addr = `RIOCR0;
                  `ACIOCR5    : reg_addr = `IOVCR0;
 `ifndef DWC_DDRPHY_X4X2
                  
                  `DX0MDLR0,`DX0MDLR1: reg_addr = `DX0GTR0;
                  `DX1MDLR0,`DX1MDLR1: reg_addr = `DX1GTR0;
                  `DX2MDLR0,`DX2MDLR1: reg_addr = `DX2GTR0;
                  `DX3MDLR0,`DX3MDLR1: reg_addr = `DX3GTR0;
                  `DX4MDLR0,`DX4MDLR1: reg_addr = `DX4GTR0;
                  `DX5MDLR0,`DX5MDLR1: reg_addr = `DX5GTR0;
                  `DX6MDLR0,`DX6MDLR1: reg_addr = `DX6GTR0;
                  `DX7MDLR0,`DX7MDLR1: reg_addr = `DX7GTR0;
                  `DX8MDLR0,`DX8MDLR1: reg_addr = `DX8GTR0;


                  `DX0GCR7, `DX0GCR8, `DX0GCR9  : reg_addr = `DX0BDLR0;    
                  `DX1GCR7, `DX1GCR8, `DX1GCR9  : reg_addr = `DX1BDLR0;    
                  `DX2GCR7, `DX2GCR8, `DX2GCR9  : reg_addr = `DX2BDLR0;    
                  `DX3GCR7, `DX3GCR8, `DX3GCR9  : reg_addr = `DX3BDLR0;    
                  `DX4GCR7, `DX4GCR8, `DX4GCR9  : reg_addr = `DX4BDLR0;    
                  `DX5GCR7, `DX5GCR8, `DX5GCR9  : reg_addr = `DX5BDLR0;    
                  `DX6GCR7, `DX6GCR8, `DX6GCR9  : reg_addr = `DX6BDLR0;    
                  `DX7GCR7, `DX7GCR8, `DX7GCR9  : reg_addr = `DX7BDLR0;    
                  `DX8GCR7, `DX8GCR8, `DX8GCR9  : reg_addr = `DX8BDLR0;    


                  `DX0BDLR7,`DX0BDLR8,`DX0BDLR9   : reg_addr = `DX0LCDLR0;   
                  `DX1BDLR7,`DX1BDLR8,`DX1BDLR9   : reg_addr = `DX1LCDLR0;   
                  `DX2BDLR7,`DX2BDLR8,`DX2BDLR9   : reg_addr = `DX2LCDLR0;   
                  `DX3BDLR7,`DX3BDLR8,`DX3BDLR9   : reg_addr = `DX3LCDLR0;   
                  `DX4BDLR7,`DX4BDLR8,`DX4BDLR9   : reg_addr = `DX4LCDLR0;   
                  `DX5BDLR7,`DX5BDLR8,`DX5BDLR9   : reg_addr = `DX5LCDLR0;   
                  `DX6BDLR7,`DX6BDLR8,`DX6BDLR9   : reg_addr = `DX6LCDLR0;   
                  `DX7BDLR7,`DX7BDLR8,`DX7BDLR9   : reg_addr = `DX7LCDLR0;   
                  `DX8BDLR7,`DX8BDLR8,`DX8BDLR9   : reg_addr = `DX8LCDLR0;   

                  `DX0GSR4,`DX0GSR5,`DX0GSR6    : reg_addr = `DX0GSR6 + 1;  
                  `DX1GSR4,`DX1GSR5,`DX1GSR6    : reg_addr = `DX1GSR6 + 1;  
                  `DX2GSR4,`DX2GSR5,`DX2GSR6    : reg_addr = `DX2GSR6 + 1;  
                  `DX3GSR4,`DX3GSR5,`DX3GSR6    : reg_addr = `DX3GSR6 + 1;  
                  `DX4GSR4,`DX4GSR5,`DX4GSR6    : reg_addr = `DX4GSR6 + 1;  
                  `DX5GSR4,`DX5GSR5,`DX5GSR6    : reg_addr = `DX5GSR6 + 1;  
                  `DX6GSR4,`DX6GSR5,`DX6GSR6    : reg_addr = `DX6GSR6 + 1;  
                  `DX7GSR4,`DX7GSR5,`DX7GSR6    : reg_addr = `DX7GSR6 + 1;  
                  //`DX8GSR4,`DX8GSR5,`DX8GSR6    : reg_addr = `DX8GSR6 + 1;  

`else
                  `DX0MDLR0,`DX0MDLR1:  reg_addr = `DX0MDLR1 +1;
                  `DX1MDLR0,`DX1MDLR1:  reg_addr = `DX1MDLR1 +1;
                  `DX2MDLR0,`DX2MDLR1: reg_addr = `DX2MDLR1 +1;
                  `DX3MDLR0,`DX3MDLR1: reg_addr = `DX3MDLR1 +1;
                  `DX4MDLR0,`DX4MDLR1: reg_addr = `DX4MDLR1 +1;
                  `DX5MDLR0,`DX5MDLR1: reg_addr = `DX5MDLR1 +1;
                  `DX6MDLR0,`DX6MDLR1: reg_addr = `DX6MDLR1 +1;
                  `DX7MDLR0,`DX7MDLR1: reg_addr = `DX7MDLR1 +1;
                  `DX8MDLR0,`DX8MDLR1: reg_addr = `DX8MDLR1 +1; // skip DXnMDLR0-1
`endif // !`ifndef DWC_DDRPHY_X4X2
                  
`ifdef DWC_DDRPHY_X4MODE
                  `DXCCR      : reg_addr = `DXCCR + 1;
`endif 

`endif
                 endcase 
              end
            `PREV_ADDR:
              begin
                case (reg_addr)
`ifdef DWC_DDRPHY_EMUL_XILINX
                  `ACMDLR0     : reg_addr = `ACMDLR0-1; 
                  `ACMDLR1     : reg_addr = `ACMDLR1-2;

                  `DX0BDLR2   : reg_addr = `DX0BDLR1;
                  `DX0BDLR3   : reg_addr = `DX0BDLR1;
                  `DX0BDLR4   : reg_addr = `DX0BDLR1;
                  `DX0LCDLR0  : reg_addr = `DX0BDLR1;
                  `DX0LCDLR1  : reg_addr = `DX0BDLR1;
                  `DX0LCDLR2  : reg_addr = `DX0BDLR1;
                  `DX0MDLR0    : reg_addr = `DX0BDLR1;
                  pDX0GTR     : reg_addr = `DX0BDLR1;

                  `DX1BDLR2   : reg_addr = `DX1BDLR1;
                  `DX1BDLR3   : reg_addr = `DX1BDLR1;
                  `DX1BDLR4   : reg_addr = `DX1BDLR1;
                  `DX1LCDLR0  : reg_addr = `DX1BDLR1;
                  `DX1LCDLR1  : reg_addr = `DX1BDLR1;
                  `DX1LCDLR2  : reg_addr = `DX1BDLR1;
                  `DX1MDLR0    : reg_addr = `DX1BDLR1;
                  pDX1GTR     : reg_addr = `DX1BDLR1;

                  `DX2BDLR2   : reg_addr = `DX2BDLR1;
                  `DX2BDLR3   : reg_addr = `DX2BDLR1;
                  `DX2BDLR4   : reg_addr = `DX2BDLR1;
                  `DX2LCDLR0  : reg_addr = `DX2BDLR1;
                  `DX2LCDLR1  : reg_addr = `DX2BDLR1;
                  `DX2LCDLR2  : reg_addr = `DX2BDLR1;
                  `DX2MDLR0    : reg_addr = `DX2BDLR1;
                  pDX2GTR     : reg_addr = `DX2BDLR1;

                  `DX3BDLR2   : reg_addr = `DX3BDLR1;
                  `DX3BDLR3   : reg_addr = `DX3BDLR1;
                  `DX3BDLR4   : reg_addr = `DX3BDLR1;
                  `DX3LCDLR0  : reg_addr = `DX3BDLR1;
                  `DX3LCDLR1  : reg_addr = `DX3BDLR1;
                  `DX3LCDLR2  : reg_addr = `DX3BDLR1;
                  `DX3MDLR0    : reg_addr = `DX3BDLR1;
                  pDX3GTR     : reg_addr = `DX3BDLR1;

                  `DX4BDLR2   : reg_addr = `DX4BDLR1;
                  `DX4BDLR3   : reg_addr = `DX4BDLR1;
                  `DX4BDLR4   : reg_addr = `DX4BDLR1;
                  `DX4LCDLR0  : reg_addr = `DX4BDLR1;
                  `DX4LCDLR1  : reg_addr = `DX4BDLR1;
                  `DX4LCDLR2  : reg_addr = `DX4BDLR1;
                  `DX4MDLR0    : reg_addr = `DX4BDLR1;
                  pDX4GTR     : reg_addr = `DX4BDLR1;

                  `DX5BDLR2   : reg_addr = `DX5BDLR1;
                  `DX5BDLR3   : reg_addr = `DX5BDLR1;
                  `DX5BDLR4   : reg_addr = `DX5BDLR1;
                  `DX5LCDLR0  : reg_addr = `DX5BDLR1;
                  `DX5LCDLR1  : reg_addr = `DX5BDLR1;
                  `DX5LCDLR2  : reg_addr = `DX5BDLR1;
                  `DX5MDLR0    : reg_addr = `DX5BDLR1;
                  pDX5GTR     : reg_addr = `DX5BDLR1;

                  `DX6BDLR2   : reg_addr = `DX6BDLR1;
                  `DX6BDLR3   : reg_addr = `DX6BDLR1;
                  `DX6BDLR4   : reg_addr = `DX6BDLR1;
                  `DX6LCDLR0  : reg_addr = `DX6BDLR1;
                  `DX6LCDLR1  : reg_addr = `DX6BDLR1;
                  `DX6LCDLR2  : reg_addr = `DX6BDLR1;
                  `DX6MDLR0    : reg_addr = `DX6BDLR1;
                  pDX6GTR     : reg_addr = `DX6BDLR1;

                  `DX7BDLR2   : reg_addr = `DX7BDLR1;
                  `DX7BDLR3   : reg_addr = `DX7BDLR1;
                  `DX7BDLR4   : reg_addr = `DX7BDLR1;
                  `DX7LCDLR0  : reg_addr = `DX7BDLR1;
                  `DX7LCDLR1  : reg_addr = `DX7BDLR1;
                  `DX7LCDLR2  : reg_addr = `DX7BDLR1;
                  `DX7MDLR0    : reg_addr = `DX7BDLR1;
                  pDX7GTR     : reg_addr = `DX7BDLR1;

                  `DX8BDLR2   : reg_addr = `DX8BDLR1; 
                  `DX8BDLR3   : reg_addr = `DX8BDLR1; 
                  `DX8BDLR4   : reg_addr = `DX8BDLR1; 
                  `DX8LCDLR0  : reg_addr = `DX8BDLR1; 
                  `DX8LCDLR1  : reg_addr = `DX8BDLR1; 
                  `DX8LCDLR2  : reg_addr = `DX8BDLR1; 
                  `DX8MDLR0    : reg_addr = `DX8BDLR1; 
                  pDX8GTR     : reg_addr = `DX8BDLR1; 


                  // adding ZQ status registers since bits 7:0 of these registers
                  // are continuously changing due to background calibration
                  `ZQ0SR      : reg_addr = `ACBDLR10; //DDRG2MPHY: Changed ZQ0DR to ZQ0PR
                  `ZQ1SR      : reg_addr = `ACBDLR10; //DDRG2MPHY: Changed ZQ1DR to ZQ0PR
                  `ZQ2SR      : reg_addr = `ACBDLR10; //DDRG2MPHY: Changed ZQ2DR to ZQ0PR
                  `ZQ3SR      : reg_addr = `ACBDLR10; //DDRG2MPHY: Changed ZQ3DR to ZQ0PR
                  `ZQ0DR      : reg_addr = `ACBDLR10; //DDRG2MPHY: Added ZQnDR to skip_special_register as the calibration goes in background always 
                  `ZQ1DR      : reg_addr = `ACBDLR10; //DDRG2MPHY: Added ZQnDR to skip_special_register as the calibration goes in background always
                  `ZQ2DR      : reg_addr = `ACBDLR10; //DDRG2MPHY: Added ZQnDR to skip_special_register as the calibration goes in background always 
                  `ZQ3DR      : reg_addr = `ACBDLR10; //DDRG2MPHY: Added ZQnDR to skip_special_register as the calibration goes in background always
                  
                  `PLLCR      : reg_addr = `PLLCR-1;
                  `IOVCR0     : reg_addr = `DCUSR1;
                  `IOVCR1     : reg_addr = `DCUSR1;
                  `VTCR0      : reg_addr = `DCUSR1;
                  `VTCR1      : reg_addr = `DCUSR1;
                  `ZQCR       : reg_addr = `ACBDLR10;
                  `ZQ0PR      : reg_addr = `ACBDLR10;
                  `ZQ1PR      : reg_addr = `ACBDLR10;
                  `ZQ2PR      : reg_addr = `ACBDLR10;
                  `ZQ3PR      : reg_addr = `ACBDLR10;
                  // Maybe supported in the future
                  `DX0GCR5    : reg_addr = `DX0BDLR6;
                  `DX0GCR6    : reg_addr = `DX0BDLR6;
                  `DX1GCR5    : reg_addr = `DX1BDLR6;
                  `DX1GCR6    : reg_addr = `DX1BDLR6;
                  `DX2GCR5    : reg_addr = `DX2BDLR6;
                  `DX2GCR6    : reg_addr = `DX2BDLR6;
                  `DX3GCR5    : reg_addr = `DX3BDLR6;
                  `DX3GCR6    : reg_addr = `DX3BDLR6;
                  `DX4GCR5    : reg_addr = `DX4BDLR6;
                  `DX4GCR6    : reg_addr = `DX4BDLR6;
                  `DX5GCR5    : reg_addr = `DX5BDLR6;
                  `DX5GCR6    : reg_addr = `DX5BDLR6;
                  `DX6GCR5    : reg_addr = `DX6BDLR6;
                  `DX6GCR6    : reg_addr = `DX6BDLR6;
                  `DX7GCR5    : reg_addr = `DX7BDLR6;
                  `DX7GCR6    : reg_addr = `DX7BDLR6;
                  `DX8GCR5    : reg_addr = `DX8BDLR6;
                  `DX8GCR6    : reg_addr = `DX8BDLR6;
                  
                  `DX0GTR0    : reg_addr = `DX0BDLR6;
                  `DX1GTR0    : reg_addr = `DX1BDLR6;
                  `DX2GTR0    : reg_addr = `DX2BDLR6;
                  `DX3GTR0    : reg_addr = `DX3BDLR6;
                  `DX4GTR0    : reg_addr = `DX4BDLR6;
                  `DX5GTR0    : reg_addr = `DX5BDLR6;
                  `DX6GTR0    : reg_addr = `DX6BDLR6;
                  `DX7GTR0    : reg_addr = `DX7BDLR6;
                  `DX8GTR0    : reg_addr = `DX8BDLR6;
                  
`else
                  `ACMDLR0, `ACMDLR1 : reg_addr = `ACMDLR0 -1;
                  `DX0MDLR0,`DX0MDLR1: reg_addr = `DX0MDLR0-1;
                  `DX1MDLR0,`DX1MDLR1: reg_addr = `DX1MDLR0-1;
                  `DX2MDLR0,`DX2MDLR1: reg_addr = `DX2MDLR0-1;
                  `DX3MDLR0,`DX3MDLR1: reg_addr = `DX3MDLR0-1;
                  `DX4MDLR0,`DX4MDLR1: reg_addr = `DX4MDLR0-1;
                  `DX5MDLR0,`DX5MDLR1: reg_addr = `DX5MDLR0-1;
                  `DX6MDLR0,`DX6MDLR1: reg_addr = `DX6MDLR0-1;
                  `DX7MDLR0,`DX7MDLR1: reg_addr = `DX7MDLR0-1;
                  `DX8MDLR0,`DX8MDLR1: reg_addr = `DX8MDLR0-1;

`endif
                endcase 
              end
          endcase // case(new_addr)
        end

       case (reg_addr)
         `DCUDR:  reg_addr = (new_addr == `NEXT_ADDR) ? reg_addr + 1 : reg_addr - 1;
       endcase // case (reg_addr)
       skip_special_registers = reg_addr;      
     end
  endfunction // skip_special_registers

  function real abs;
    input a;
    integer a;
    integer neg_a;

    begin

      if (a == 0) neg_a = 0;
      else if (a > 0) neg_a = a;
      else if (a < 0) neg_a = -a;
      abs = neg_a;


    end
  endfunction

  
  // DDR PHY configuration and check
  // -------------------------------
  task check_cfg_pll_lock_done;
    reg [31:0] tmp;
    
    begin
      // polling status...
      `CFG.disable_read_compare;
      `CFG.read_register_data(`PGSR0, tmp);
      
      while(tmp[1] == 1'b0) begin
        repeat (10) @(posedge clk);
        `CFG.read_register_data(`PGSR0, tmp);
       end
      $display("-> %0t: [SYSTEM] PGSR0.PLDONE set",$time);
      repeat (5) @(posedge clk);
      `CFG.enable_read_compare;
    end
  endtask // check_cfg_pll_lock_done


  task check_cfg_init_done;
    reg [31:0] tmp;
    
    begin
      // polling status...
      `CFG.disable_read_compare;
      `CFG.read_register_data(`PGSR0, tmp);
      
      while(tmp[0] == 1'b0) begin
        repeat (10) @(posedge clk);
        `CFG.read_register_data(`PGSR0, tmp);
      end
      $display("-> %0t: [SYSTEM] PGSR0.INIT set",$time);
      phy_init_done = 1'b1;
      init          = 1'b1;
      repeat (5) @(posedge clk);
      `CFG.enable_read_compare;
     end
  endtask

  
  task check_cfg_calib_done;
    reg [31:0] tmp;
    begin
      // polling status...
      `CFG.disable_read_compare;
      `CFG.read_register_data(`PGSR0, tmp);
          
      while(tmp[2] == 1'b0) begin
        repeat (10) @(posedge clk);
        `CFG.read_register_data(`PGSR0, tmp);
      end
      $display("-> %0t: [SYSTEM] PGSR0.DCDONE set",$time);
      phy_calib_done = 1'b1;
      cal_done       = 1'b1;
      repeat (5) @(posedge clk);
      `CFG.enable_read_compare;
     end
  endtask


  task check_cfg_wl_done;
    reg [31:0] tmp;
    begin
      // polling status...
      `CFG.disable_read_compare;
      `CFG.read_register_data(`PGSR0, tmp);
      
      while(tmp[3] == 1'b0) begin
        repeat (10) @(posedge clk);
        `CFG.read_register_data(`PGSR0, tmp);
      end
      $display("-> %0t: [SYSTEM] PGSR0.WL set",$time);
      repeat (5) @(posedge clk);
      `CFG.enable_read_compare;
     end
  endtask


   task check_cfg_aplock_done;
    reg [31:0] tmp;
    begin
      // polling status...
      `CFG.disable_read_compare;
      `CFG.read_register_data(`PGSR0, tmp);
      
      while(tmp[5] == 1'b0) begin
        repeat (10) @(posedge clk);
        `CFG.read_register_data(`PGSR0, tmp);
      end
      $display("-> %0t: [SYSTEM] PGSR0.APLOCK set",$time);
      repeat (5) @(posedge clk);
      `CFG.enable_read_compare;
     end
  endtask


  task check_tb_pll_lock_done;
    input status;
    reg [31:0] reg_addr;
    reg [31:0] reg_read_data;
    begin
`ifndef DWC_DDRPHY_EMUL_XILINX
      `CFG.disable_read_compare;
      // Initial register read
      @(posedge `CFG.clk);
      `CFG.read_register_data(reg_addr, reg_read_data);

      //if (`PUB.pll_lock_done != status) begin
      if (reg_read_data[1] != status) begin
      //if (`PUB.pll_lock_done != status) begin
        error;
        $display("-> %0t: [SYSTEM] ERROR: PGSR0[PLDONE] = %0d not %0d as expected!!!", $time, 
                  reg_read_data[1], status);
      end
`endif
    end
  endtask // check_tb_pll_lock_done

  task check_tb_cal_done;
    input status;
    reg [31:0] reg_addr;
    reg [31:0] reg_read_data;
    begin
`ifndef DWC_DDRPHY_EMUL_XILINX
      `CFG.disable_read_compare;
      // Initial register read
      @(posedge `CFG.clk);
      `CFG.read_register_data(reg_addr, reg_read_data);
      cal_done = reg_read_data[2];

      if (`SYS.cal_done != status) begin
        error;
        $display("-> %0t: [SYSTEM] ERROR: cal_done = %0d not %0d as expected!!!", $time, 
                 `SYS.cal_done, status);
      end
      `CFG.enable_read_compare;
`endif
    end
  endtask // check_tb_cal_done

  task check_tb_phy_init_done;
    input status;
    reg [31:0] reg_addr;
    reg [31:0] reg_read_data;
    begin
`ifndef DWC_DDRPHY_EMUL_XILINX
      `CFG.disable_read_compare;
      // Initial register read
      @(posedge `CFG.clk);
      `CFG.read_register_data(reg_addr, reg_read_data);
      init = reg_read_data[0];

      //if (`PUB.phy_init_done != status) begin
      if (init != status) begin
        error;
        $display("-> %0t: [SYSTEM] ERROR: init = %0d not %0d as expected!!!", $time, 
                  init, status);
      end
`endif
    end
  endtask // check_tb_phy_init_done

// ->>  Miguel Board Delays Update
`ifndef DWC_DDRPHY_EMUL_XILINX // Not needed in Xilinx's emulation mode
  `ifdef DWC_DDRPHY_BOARD_DELAYS  
    generate
      for(dwc_dim=0;dwc_dim<`DWC_NO_OF_DIMMS;dwc_dim=dwc_dim+1) begin : gather_read_dqs_dlys 
        for(dwc_rnk=0;dwc_rnk<`DWC_RANKS_PER_DIMM;dwc_rnk=dwc_rnk+1) begin : gen_read_dqs_brd_dly
          //`ifdef SDRAMx4
          //  for(dwc_dly=0;dwc_dly<(`SDRAM_DATA_WIDTH/4);dwc_dly=dwc_dly+1) begin : gen_read_dqs_brd_dly
          //`else
          //  for(dwc_dly=0;dwc_dly<(`SDRAM_DATA_WIDTH/8);dwc_dly=dwc_dly+1) begin : gen_read_dqs_brd_dly
          //`endif     
          for(dwc_byte=0;dwc_byte<`DWC_NO_OF_BYTES;dwc_byte=dwc_byte+1) begin : gen_read_dqs_brd_dly
            `ifdef DWC_USE_SHARED_AC
              `ifdef SDRAMx4
                for(dwc_chip=0;dwc_chip<( `CH0_DX8_BYTE_WIDTH + (`DWC_NO_OF_BYTES % 2)*(dwc_dim % 2) )*2;dwc_chip=dwc_chip+1) begin : u_chip_sdram_cfg
              `else
                for(dwc_chip=0;dwc_chip<( `CH0_DX8_BYTE_WIDTH + (`DWC_NO_OF_BYTES % 2)*(dwc_dim % 2) )/(`SDRAM_DATA_WIDTH/8);dwc_chip=dwc_chip+1) begin : u_chip_sdram_cfg
              `endif
            `else
              `ifdef SDRAMx4
                for(dwc_chip=0;dwc_chip<`DWC_NO_OF_BYTES*2;dwc_chip=dwc_chip+1) begin : u_chip_sdram_cfg
              `else
                for(dwc_chip=0;dwc_chip<`DWC_NO_OF_BYTES/(`SDRAM_DATA_WIDTH/8);dwc_chip=dwc_chip+1) begin : u_chip_sdram_cfg
              `endif
            `endif
            assign    read_dqs_brd_dly[dwc_dim*`DWC_RANKS_PER_DIMM+dwc_rnk][dwc_byte] = `RAM_PROBE(dwc_dim,dwc_rnk,dwc_chip).board_delay_model.dqs_di_sdram_dly[dwc_byte%`SDRAM_BYTE_WIDTH];//`DXn_IO.u_board_dly.dqs_di_board_dly[dwc_rnk]; oldest version
            end
            //end
          end
        end 
      end
    endgenerate
  `endif
`endif  


  // set extra dqs tolerance used for DXnLCDLR0 value comparison when jitter or skew is in place
  always @(*)
    dqs_extra_step_tolerance = ((pRANDOM_JITTER_PK2PK/2) + (pSIN_JITTER_PK2PK/2) + pDCD_VALUE + pISI_VALUE + pMAX_DX_SIGNAL_SKEW)/(`PHYSYS.ddl_step_size*1000);
  
`ifndef GATE_LEVEL_SIM
  // align the two asynchronous clocks used in the PHY FIFO
  task align_phy_fifo_clocks;
    integer rank_idx, byte_idx;
    begin
      `SYS.suppress_err_msg = 1'b1; // report errors as information

      // execute a read transaction and measure the offset of DQS to controller
      // clock (clk) and then align the clocks
      dqs_to_clk_offset = pRANDOM_JITTER_PK2PK/2;
      `HOST.nops(50);
      -> e_align_dqs_and_phy_clk;
      `HOST.read({`ADDR_WIDTH{1'b0}});
      `HOST.nops(50);
      for (rank_idx = 0; rank_idx < pNO_OF_LRANKS; rank_idx = rank_idx + 1)
        `HOST.precharge_all(rank_idx);

      // reset errors, warnings and read counters
      `HOST.nops(25);
      `SYS.clear_errors;
      `SYS.clear_warnings;
      `GRM.host_reads_rxd   = 0;
      `GRM.host_reads_txd   = 0;
      `GRM.bl4_reads_txd    = 0;
      `GRM.ch0_fifo_rdptr  = 0;
      `GRM.ch0_fifo_wrptr  = 0;
      `GRM.ch1_fifo_rdptr  = 0;
      `GRM.ch1_fifo_wrptr  = 0;
      `SYS.phy_fifo_reset;
      `SYS.suppress_err_msg = 1'b0; // report errors as errors

      // turn off bus conflict at dq
      $display("-> %0t: [SYSTEM] Note: Turning off BUS CONFLICT checks in testcase for bubbles in sim_options at runtc...", $time);
      
      // Turn off any warnings from ddr_mnt.v 
      $display("-> %0t: [SYSTEM] Note: Disabling checks for X's from ddr_mnt for bubbles...", $time);
      `SYS.disable_undefined_warning;
      
`ifndef DWC_DDRPHY_EMUL_XILINX
`ifdef DWC_DDRPHY_BOARD_DELAYS
`ifndef DWC_JITTER_DEFAULTS 
      // allow jitter to be injected (for now use peak fixed jitter)
      for (rank_idx=0; rank_idx<pNO_OF_LRANKS; rank_idx=rank_idx+1) begin : apply_bubbles_rj_rank
        for (byte_idx=0; byte_idx<`NUM_DEVICES; byte_idx=byte_idx+1) begin : apply_bubbles_rj
         `TB.u_ddr_board_cfg.config_jitter("rj_peak","dqs" ,rank_idx, byte_idx, dqs_to_clk_offset*2);
         `TB.u_ddr_board_cfg.config_jitter("rj_peak","dqsn",rank_idx, byte_idx, dqs_to_clk_offset*2);
         `TB.u_ddr_board_cfg.config_jitter("rj_peak","dm"  ,rank_idx, byte_idx, dqs_to_clk_offset*2);
         `TB.u_ddr_board_cfg.config_jitter("rj_peak","dq"  ,rank_idx, byte_idx, dqs_to_clk_offset*2);
          #0.001;
        end
      end
     `TB.u_ddr_board_cfg.set_board_jitter_cfg ; 
`endif
`endif
`endif
      // wait some time to allow board delays to be updated
      `HOST.nops(5);
      
      // need to re-train the bytes before you do any SDRAM reads
      need_data_train = 1'b1;
      `SYS.chk_dqs_gate_train_done  = 1'b0;
      `SYS.chk_write_level_adj_done = 1'b0;

    end
  endtask // align_phy_fifo_clocks

  // creates bubbles in the valid data coming back from the PHY to PUB
  generate
    for (dwc_byte=0; dwc_byte<`DWC_NO_OF_BYTES; dwc_byte=dwc_byte+1) begin : force_or_release_phy_qvld
      always @( e_force_phy_qvld ) begin
        //force `DXn.phy_qvld = 0; 
        // Suppress internal DFI fifo_pop signals during bubbles creation in
        // fixed-latency configuration (since the pop is generated regardless
        // of whether the DFI read data FIFOs have data or not)
        if (`DWC_FIXED_LAT == 1)
          force `PHYDFI.chn[0].dx.dx_ctl.fifo_pop_per_lane = 0;
      end
      always @( e_release_phy_qvld ) begin
        //release `DXn.phy_qvld;
        if (`DWC_FIXED_LAT == 1)
          release `PHYDFI.chn[0].dx.dx_ctl.fifo_pop_per_lane;
      end
    end
  endgenerate

 task disable_bubble_insertion_during_power_up;
   begin
      $display("-> %0t: [SYSTEM] Note: setting the disable bubbles flag...", $time);
      #0;
      disable_bubbles = 1'b1;
    end
  endtask // disable_bubble_insertion_during_power_up

  task enable_bubble_insertion_during_power_up;
    begin
      $display("-> %0t: [SYSTEM] Note: setting the enable bubbles flag...", $time);
      #0;
      disable_bubbles = 1'b0;
    end
  endtask // enable_bubble_insertion_during_power_up

  task create_bubbles;
    begin
      $display("-> %0t: [SYSTEM] Note: Creating bubbles...", $time);
      // Since we're going to do dummy reads, prevent any rddata valids from 
      // going into the PUB and potentially corrupting something
      -> e_force_phy_qvld;
      align_phy_fifo_clocks;
      bubbles_created = 1'b1;
      // Release PHY rddata valid signal
      -> e_release_phy_qvld;
      $display("-> %0t: [SYSTEM] Note: Done creating bubbles", $time);
    end
  endtask // create_bubbles

  // DQS (qs_clk) and controller clock (phy_clk) alignment
  // ------------------------------------------
  // measures the delay from DQS to controller clock inside the DATX8 slices so that they can
  // used to align the clocks to create one of the conditions required for bubbles to happen
  generate  
      //for(dwc_dim=0;dwc_dim<`DWC_NO_OF_DIMMS;dwc_dim=dwc_dim+1) begin : align_dqs_with_phy_clk_dim
      for (dwc_byte=0; dwc_byte<`DWC_NO_OF_BYTES; dwc_byte=dwc_byte+1) begin : align_dqs_with_phy_clk_byte
      //`ifdef DWC_USE_SHARED_AC
      //  `ifdef SDRAMx4
      //    for(dwc_chip=0;dwc_chip<( `CH0_DX8_BYTE_WIDTH + (`DWC_NO_OF_BYTES % 2)*(dwc_dim % 2) )*2;dwc_chip=dwc_chip+1) begin : u_chip_sdram_cfg
      //  `else
      //    for(dwc_chip=0;dwc_chip<( `CH0_DX8_BYTE_WIDTH + (`DWC_NO_OF_BYTES % 2)*(dwc_dim % 2) )/(`SDRAM_DATA_WIDTH/8);dwc_chip=dwc_chip+1) begin : u_chip_sdram_cfg
      //  `endif
      //`else
      //  `ifdef SDRAMx4
      //    for(dwc_chip=0;dwc_chip<`DWC_NO_OF_BYTES*2;dwc_chip=dwc_chip+1) begin : u_chip_sdram_cfg
      //  `else
      //    for(dwc_chip=0;dwc_chip<`DWC_NO_OF_BYTES/(`SDRAM_DATA_WIDTH/8);dwc_chip=dwc_chip+1) begin : u_chip_sdram_cfg
      //  `endif
      //`endif
            
      always @(e_align_dqs_and_phy_clk) begin: measure_dqs_to_phy_clk_skews
`ifndef DWC_DDRPHY_EMUL_XILINX 
        real tmp_dly;
        integer dqs_to_clk_dly;
        integer dqs_to_clk_shift;
        integer rank_no, chip_no, dqs_no, bit_no, dly_dir;
//         integer sys_lat;
//         integer dqs_sel;
//         integer rank_no;

          @(posedge `DXn_core.`DX_DQS0.qs_n_dly_clk);
          tmp_dly = $realtime;
          @(/*posedge `DXn_core.phy_clk_in or*/
            negedge `DXn_core.`DX_DQS0.ctl_rd_clk /*phy_clk*/ );

          tmp_dly = $realtime - tmp_dly;
          dqs_to_clk_dly = 1000*tmp_dly;
          if (dqs_to_clk_dly < dqs_to_clk_offset) dqs_to_clk_offset = dqs_to_clk_dly ;

          $display("-> %0t: [SYS-BUBBLES-MESURE] byte=%0d    dqs_to_clk_dly=%0d ", $time, dwc_byte, dqs_to_clk_dly);
	  
	        `HOST.nops(8);

          // now apply delays on byte 0 input signals to align the DQS with phy_clk, DQS leading by the
          // specified offset; if DQS is already leading by less than the set dqs_to_clk_offset, don't
          // shift the DQS; if there is already some board delay on the signals, add shift value to 
          // the existing delays (to keep shift relative to existing alignment, instead of absolute)

          dqs_to_clk_shift = dqs_to_clk_dly ;
        
  `ifdef DWC_DDRPHY_BOARD_DELAYS 	  
          for (rank_no=0; rank_no<pNO_OF_LRANKS; rank_no=rank_no+1) begin
    `ifdef SDRAMx4
            chip_no = dwc_byte*8/`SDRAM_DATA_WIDTH;
            dqs_no  = 0;
    `else
            chip_no = dwc_byte/`SDRAM_BYTE_WIDTH;
            dqs_no  = dwc_byte%`SDRAM_BYTE_WIDTH;
    `endif
            // For the "IN" direction only
            for (dly_dir=1; dly_dir<2; dly_dir=dly_dir+1) begin
              
              if (dly_dir==1) begin
                //`TB.u_ddr_board_cfg.config_delay("dqs" ,dly_dir, rank_no, chip_no,   dqs_no, `RAM_PROBE(dwc_dim,dwc_rnk,dwc_chip).board_delay_model.dqs_di_sdram_dly [dwc_dly] + dqs_to_clk_shift);
                `TB.u_ddr_board_cfg.config_delay("dqs" ,dly_dir, rank_no, chip_no,   dqs_no, dqs_to_clk_shift);
                `TB.u_ddr_board_cfg.config_delay("dqsn",dly_dir, rank_no, chip_no,   dqs_no, dqs_to_clk_shift);
                `TB.u_ddr_board_cfg.config_delay("dm"  ,dly_dir, rank_no, chip_no,   dqs_no, dqs_to_clk_shift);

    `ifdef SDRAMx4
                `TB.u_ddr_board_cfg.config_delay("dqs" ,dly_dir, rank_no, chip_no+1, dqs_no, dqs_to_clk_shift);
                `TB.u_ddr_board_cfg.config_delay("dqsn",dly_dir, rank_no, chip_no+1, dqs_no, dqs_to_clk_shift);
                `TB.u_ddr_board_cfg.config_delay("dm"  ,dly_dir, rank_no, chip_no+1, dqs_no, dqs_to_clk_shift);
    `endif
                for ( bit_no=0; bit_no<`SDRAM_DATA_WIDTH; bit_no=bit_no+1) begin
                  `TB.u_ddr_board_cfg.config_delay("dq"  ,dly_dir, rank_no, chip_no, bit_no, dqs_to_clk_shift);
                end
              end // if (dly_dir==1) 
              
            end // for dly_dir
          end // for rank_no

          #1;
          `TB.u_ddr_board_cfg.set_board_cfg ;
  `endif
          // since the signals have been shifted, DQS gating will be re-trained - generate the expected status for
          // trained bytes - TBD!
//           sys_lat = dqs_to_clk_shift/tPRD_ps;
//           dqs_sel = (dqs_to_clk_shift - (sys_lat*tPRD_ps))/(tPRD_ps/4);
//           for (rank_no=0; rank_no<`DWC_NO_OF_RANKS; rank_no=rank_no+1) begin
//             bubbles_sys_lat[rank_no][0] = sys_lat;
//             bubbles_dqs_sel[rank_no][0] = dqs_sel;
//            end
`endif
      end
    end
  endgenerate

// if GATE, but BUILD or GATE_SIM_EXCEPTION
`elsif DWC_DDRPHY_GATE_SIM_EXCEPT 
  // align the two asynchronous clocks used in the PHY FIFO
  task align_phy_fifo_clocks;
    integer rank_idx, byte_idx;
    begin
      `SYS.suppress_err_msg = 1'b1; // report errors as information

      // execute a read transaction and measure the offset of DQS to controller
      // clock (clk) and then align the clocks
      dqs_to_clk_offset = pRANDOM_JITTER_PK2PK/2;
      `HOST.nops(50);
      -> e_align_dqs_and_phy_clk;
      `HOST.read({`ADDR_WIDTH{1'b0}});
      `HOST.nops(50);
      for (rank_idx = 0; rank_idx < pNO_OF_LRANKS; rank_idx = rank_idx + 1)
        `HOST.precharge_all(rank_idx);

      // reset errors, warnings and read counters
      `HOST.nops(25);
      `SYS.clear_errors;
      `SYS.clear_warnings;
      `GRM.host_reads_rxd   = 0;
      `GRM.host_reads_txd   = 0;
      `GRM.bl4_reads_txd    = 0;
      `GRM.ch0_fifo_rdptr  = 0;
      `GRM.ch0_fifo_wrptr  = 0;
      `GRM.ch1_fifo_rdptr  = 0;
      `GRM.ch1_fifo_wrptr  = 0;
      `SYS.phy_fifo_reset;
      `SYS.suppress_err_msg = 1'b0; // report errors as errors

      // turn off bus conflict at dq
      $display("-> %0t: [SYSTEM] Note: Turning off BUS CONFLICT checks in testcase for bubbles in sim_options at runtc...", $time);
      
      // Turn off any warnings from ddr_mnt.v 
      $display("-> %0t: [SYSTEM] Note: Disabling checks for X's from ddr_mnt for bubbles...", $time);
      `SYS.disable_undefined_warning;
      
`ifndef DWC_DDRPHY_EMUL_XILINX
`ifdef DWC_DDRPHY_BOARD_DELAYS
`ifndef DWC_JITTER_DEFAULTS 
      // allow jitter to be injected (for now use peak fixed jitter)
      for (rank_idx=0; rank_idx<pNO_OF_LRANKS; rank_idx=rank_idx+1) begin : apply_bubbles_rj_rank
        for (byte_idx=0; byte_idx<`NUM_DEVICES; byte_idx=byte_idx+1) begin : apply_bubbles_rj
         `TB.u_ddr_board_cfg.config_jitter("rj_peak","dqs" ,rank_idx, byte_idx, dqs_to_clk_offset*2);
         `TB.u_ddr_board_cfg.config_jitter("rj_peak","dqsn",rank_idx, byte_idx, dqs_to_clk_offset*2);
         `TB.u_ddr_board_cfg.config_jitter("rj_peak","dm"  ,rank_idx, byte_idx, dqs_to_clk_offset*2);
         `TB.u_ddr_board_cfg.config_jitter("rj_peak","dq"  ,rank_idx, byte_idx, dqs_to_clk_offset*2);
          #0.001;
        end
      end
     `TB.u_ddr_board_cfg.set_board_jitter_cfg ; 
`endif
`endif
`endif
      // wait some time to allow board delays to be updated
      `HOST.nops(5);
      
      // need to re-train the bytes before you do any SDRAM reads
      need_data_train = 1'b1;
      `SYS.chk_dqs_gate_train_done  = 1'b0;
      `SYS.chk_write_level_adj_done = 1'b0;

    end
  endtask // align_phy_fifo_clocks

  // creates bubbles in the valid data coming back from the PHY to PUB
  generate
    for (dwc_byte=0; dwc_byte<`DWC_NO_OF_BYTES; dwc_byte=dwc_byte+1) begin : force_or_release_phy_qvld
      always @( e_force_phy_qvld ) begin
        //force `DXn.phy_qvld = 0; 
        // Suppress internal DFI fifo_pop signals during bubbles creation in
        // fixed-latency configuration (since the pop is generated regardless
        // of whether the DFI read data FIFOs have data or not)
        if (`DWC_FIXED_LAT == 1)
          force `PHYDFI.chn[0].dx.dx_ctl.fifo_pop_per_lane = 0;
      end
      always @( e_release_phy_qvld ) begin
        //release `DXn.phy_qvld;
        if (`DWC_FIXED_LAT == 1)
          release `PHYDFI.chn[0].dx.dx_ctl.fifo_pop_per_lane;
      end
    end
  endgenerate

 task disable_bubble_insertion_during_power_up;
   begin
      $display("-> %0t: [SYSTEM] Note: setting the disable bubbles flag...", $time);
      #0;
      disable_bubbles = 1'b1;
    end
  endtask // disable_bubble_insertion_during_power_up

  task enable_bubble_insertion_during_power_up;
    begin
      $display("-> %0t: [SYSTEM] Note: setting the enable bubbles flag...", $time);
      #0;
      disable_bubbles = 1'b0;
    end
  endtask // enable_bubble_insertion_during_power_up

  task create_bubbles;
    begin
      $display("-> %0t: [SYSTEM] Note: Creating bubbles...", $time);
      // Since we're going to do dummy reads, prevent any rddata valids from 
      // going into the PUB and potentially corrupting something
      -> e_force_phy_qvld;
      align_phy_fifo_clocks;
      bubbles_created = 1'b1;
      // Release PHY rddata valid signal
      -> e_release_phy_qvld;
      $display("-> %0t: [SYSTEM] Note: Done creating bubbles", $time);
    end
  endtask // create_bubbles

  // DQS (qs_clk) and controller clock (phy_clk) alignment
  // ------------------------------------------
  // measures the delay from DQS to controller clock inside the DATX8 slices so that they can
  // used to align the clocks to create one of the conditions required for bubbles to happen
  generate  
      //for(dwc_dim=0;dwc_dim<`DWC_NO_OF_DIMMS;dwc_dim=dwc_dim+1) begin : align_dqs_with_phy_clk_dim
      for (dwc_byte=0; dwc_byte<`DWC_NO_OF_BYTES; dwc_byte=dwc_byte+1) begin : align_dqs_with_phy_clk_byte
      //`ifdef DWC_USE_SHARED_AC
      //  `ifdef SDRAMx4
      //    for(dwc_chip=0;dwc_chip<( `CH0_DX8_BYTE_WIDTH + (`DWC_NO_OF_BYTES % 2)*(dwc_dim % 2) )*2;dwc_chip=dwc_chip+1) begin : u_chip_sdram_cfg
      //  `else
      //    for(dwc_chip=0;dwc_chip<( `CH0_DX8_BYTE_WIDTH + (`DWC_NO_OF_BYTES % 2)*(dwc_dim % 2) )/(`SDRAM_DATA_WIDTH/8);dwc_chip=dwc_chip+1) begin : u_chip_sdram_cfg
      //  `endif
      //`else
      //  `ifdef SDRAMx4
      //    for(dwc_chip=0;dwc_chip<`DWC_NO_OF_BYTES*2;dwc_chip=dwc_chip+1) begin : u_chip_sdram_cfg
      //  `else
      //    for(dwc_chip=0;dwc_chip<`DWC_NO_OF_BYTES/(`SDRAM_DATA_WIDTH/8);dwc_chip=dwc_chip+1) begin : u_chip_sdram_cfg
      //  `endif
      //`endif
            
      always @(e_align_dqs_and_phy_clk) begin: measure_dqs_to_phy_clk_skews
`ifndef DWC_DDRPHY_EMUL_XILINX 
        real tmp_dly;
        integer dqs_to_clk_dly;
        integer dqs_to_clk_shift;
        integer rank_no, chip_no, dqs_no, bit_no, dly_dir;
//         integer sys_lat;
//         integer dqs_sel;
//         integer rank_no;

          @(posedge `DXn_core.`DX_DQS0.qs_n_dly_clk);
          tmp_dly = $realtime;
          @(/*posedge `DXn_core.phy_clk_in or*/
            negedge `DXn_core.`DX_DQS0.ctl_rd_clk /*phy_clk*/ );

          tmp_dly = $realtime - tmp_dly;
          dqs_to_clk_dly = 1000*tmp_dly;
          if (dqs_to_clk_dly < dqs_to_clk_offset) dqs_to_clk_offset = dqs_to_clk_dly ;

          $display("-> %0t: [SYS-BUBBLES-MESURE] byte=%0d    dqs_to_clk_dly=%0d ", $time, dwc_byte, dqs_to_clk_dly);
	  
	        `HOST.nops(8);

          // now apply delays on byte 0 input signals to align the DQS with phy_clk, DQS leading by the
          // specified offset; if DQS is already leading by less than the set dqs_to_clk_offset, don't
          // shift the DQS; if there is already some board delay on the signals, add shift value to 
          // the existing delays (to keep shift relative to existing alignment, instead of absolute)

          dqs_to_clk_shift = dqs_to_clk_dly ;
        
  `ifdef DWC_DDRPHY_BOARD_DELAYS 	  
          for (rank_no=0; rank_no<pNO_OF_LRANKS; rank_no=rank_no+1) begin
    `ifdef SDRAMx4
            chip_no = dwc_byte*8/`SDRAM_DATA_WIDTH;
            dqs_no  = 0;
    `else
            chip_no = dwc_byte/`SDRAM_BYTE_WIDTH;
            dqs_no  = dwc_byte%`SDRAM_BYTE_WIDTH;
    `endif
            // For the "IN" direction only
            for (dly_dir=1; dly_dir<2; dly_dir=dly_dir+1) begin
              
              if (dly_dir==1) begin
                //`TB.u_ddr_board_cfg.config_delay("dqs" ,dly_dir, rank_no, chip_no,   dqs_no, `RAM_PROBE(dwc_dim,dwc_rnk,dwc_chip).board_delay_model.dqs_di_sdram_dly [dwc_dly] + dqs_to_clk_shift);
                `TB.u_ddr_board_cfg.config_delay("dqs" ,dly_dir, rank_no, chip_no,   dqs_no, dqs_to_clk_shift);
                `TB.u_ddr_board_cfg.config_delay("dqsn",dly_dir, rank_no, chip_no,   dqs_no, dqs_to_clk_shift);
                `TB.u_ddr_board_cfg.config_delay("dm"  ,dly_dir, rank_no, chip_no,   dqs_no, dqs_to_clk_shift);

    `ifdef SDRAMx4
                `TB.u_ddr_board_cfg.config_delay("dqs" ,dly_dir, rank_no, chip_no+1, dqs_no, dqs_to_clk_shift);
                `TB.u_ddr_board_cfg.config_delay("dqsn",dly_dir, rank_no, chip_no+1, dqs_no, dqs_to_clk_shift);
                `TB.u_ddr_board_cfg.config_delay("dm"  ,dly_dir, rank_no, chip_no+1, dqs_no, dqs_to_clk_shift);
    `endif
                for ( bit_no=0; bit_no<`SDRAM_DATA_WIDTH; bit_no=bit_no+1) begin
                  `TB.u_ddr_board_cfg.config_delay("dq"  ,dly_dir, rank_no, chip_no, bit_no, dqs_to_clk_shift);
                end
              end // if (dly_dir==1) 
              
            end // for dly_dir
          end // for rank_no

          #1;
          `TB.u_ddr_board_cfg.set_board_cfg ;
  `endif
          // since the signals have been shifted, DQS gating will be re-trained - generate the expected status for
          // trained bytes - TBD!
//           sys_lat = dqs_to_clk_shift/tPRD_ps;
//           dqs_sel = (dqs_to_clk_shift - (sys_lat*tPRD_ps))/(tPRD_ps/4);
//           for (rank_no=0; rank_no<`DWC_NO_OF_RANKS; rank_no=rank_no+1) begin
//             bubbles_sys_lat[rank_no][0] = sys_lat;
//             bubbles_dqs_sel[rank_no][0] = dqs_sel;
//            end
`endif
      end
    end
  endgenerate
  
`endif // `ifndef GATE_LEVEL_SIM
  
  //----------------------------------------------------------------------------
  // Routines to print board delays
  //----------------------------------------------------------------------------
`ifndef DWC_DDRPHY_EMUL_XILINX // Not needed in Xilinx's emulation mode

  `ifdef DWC_DDRPHY_BOARD_DELAYS
    wire [32 - 1 : 0]  dbg_dqs_do_sdram_dly  [pNO_OF_LRANKS - 1 : 0][`DWC_NO_OF_BYTES - 1 : 0];
    wire [32 - 1 : 0]  dbg_dqs_di_sdram_dly  [pNO_OF_LRANKS - 1 : 0][`DWC_NO_OF_BYTES - 1 : 0];
    wire [32 - 1 : 0]  dbg_dqsn_do_sdram_dly [pNO_OF_LRANKS - 1 : 0][`DWC_NO_OF_BYTES - 1 : 0];
    wire [32 - 1 : 0]  dbg_dqsn_di_sdram_dly [pNO_OF_LRANKS - 1 : 0][`DWC_NO_OF_BYTES - 1 : 0];
    wire [32 - 1 : 0]  dbg_dm_do_sdram_dly   [pNO_OF_LRANKS - 1 : 0][`DWC_NO_OF_BYTES - 1 : 0];
    wire [32 - 1 : 0]  dbg_dm_di_sdram_dly   [pNO_OF_LRANKS - 1 : 0][`DWC_NO_OF_BYTES - 1 : 0];
    wire [32 - 1 : 0]  dbg_dq_di_sdram_dly   [pNO_OF_LRANKS - 1 : 0][`DWC_NO_OF_BYTES - 1 : 0][8 - 1 : 0];
    wire [32 - 1 : 0]  dbg_dq_do_sdram_dly   [pNO_OF_LRANKS - 1 : 0][`DWC_NO_OF_BYTES - 1 : 0][8 - 1 : 0];
  
    // Build easy access to board delay instances and values
    generate
      //genvar gen_rank_no;
      genvar           gen_bit_no;
      for(dwc_dim=0;dwc_dim<`DWC_NO_OF_DIMMS;dwc_dim=dwc_dim+1) begin : print_dbg_dqs_dlys 
        for(dwc_rnk=0;dwc_rnk<`DWC_RANKS_PER_DIMM;dwc_rnk=dwc_rnk+1) begin : print_dbg_dqs_brd_dl
          //`ifdef SDRAMx4
          //  for(dwc_dly=0;dwc_dly<(`SDRAM_DATA_WIDTH/4);dwc_dly=dwc_dly+1) begin : print_dbg_dqs_brd_dly
          //`else
          //  for(dwc_dly=0;dwc_dly<(`SDRAM_DATA_WIDTH/8);dwc_dly=dwc_dly+1) begin : print_dbg_dqs_brd_dly
          //`endif     
          for(dwc_byte=0;dwc_byte<`DWC_NO_OF_BYTES;dwc_byte=dwc_byte+1) begin : print_dbg_dqs_brd_dly
            `ifdef DWC_USE_SHARED_AC
              `ifdef SDRAMx4
                for(dwc_chip=0;dwc_chip<( `CH0_DX8_BYTE_WIDTH + (`DWC_NO_OF_BYTES % 2)*(dwc_dim % 2) )*2;dwc_chip=dwc_chip+1) begin : print_dbg_chip_sdram_cfg
              `else
                for(dwc_chip=0;dwc_chip<( `CH0_DX8_BYTE_WIDTH + (`DWC_NO_OF_BYTES % 2)*(dwc_dim % 2) )/(`SDRAM_DATA_WIDTH/8);dwc_chip=dwc_chip+1) begin : print_dbg_chip_sdram_cfg
              `endif
            `else
              `ifdef SDRAMx4
                for(dwc_chip=0;dwc_chip<`DWC_NO_OF_BYTES*2;dwc_chip=dwc_chip+1) begin : u_chip_sdram_cfg
              `else
                for(dwc_chip=0;dwc_chip<`DWC_NO_OF_BYTES/(`SDRAM_DATA_WIDTH/8);dwc_chip=dwc_chip+1) begin : print_dbg_chip_sdram_cfg
              `endif
             `endif
                assign dbg_dqs_di_sdram_dly [dwc_dim*`DWC_RANKS_PER_DIMM+dwc_rnk][dwc_byte] = `RAM_PROBE(dwc_dim,dwc_rnk,dwc_chip).board_delay_model.dqs_di_sdram_dly [dwc_byte%`SDRAM_BYTE_WIDTH];
                assign dbg_dqs_do_sdram_dly [dwc_dim*`DWC_RANKS_PER_DIMM+dwc_rnk][dwc_byte] = `RAM_PROBE(dwc_dim,dwc_rnk,dwc_chip).board_delay_model.dqs_do_sdram_dly [dwc_byte%`SDRAM_BYTE_WIDTH];
                assign dbg_dqsn_di_sdram_dly[dwc_dim*`DWC_RANKS_PER_DIMM+dwc_rnk][dwc_byte] = `RAM_PROBE(dwc_dim,dwc_rnk,dwc_chip).board_delay_model.dqsn_di_sdram_dly[dwc_byte%`SDRAM_BYTE_WIDTH];
                assign dbg_dqsn_do_sdram_dly[dwc_dim*`DWC_RANKS_PER_DIMM+dwc_rnk][dwc_byte] = `RAM_PROBE(dwc_dim,dwc_rnk,dwc_chip).board_delay_model.dqsn_do_sdram_dly[dwc_byte%`SDRAM_BYTE_WIDTH];
                assign dbg_dm_di_sdram_dly  [dwc_dim*`DWC_RANKS_PER_DIMM+dwc_rnk][dwc_byte] = `RAM_PROBE(dwc_dim,dwc_rnk,dwc_chip).board_delay_model.dm_di_sdram_dly  [dwc_byte%`SDRAM_BYTE_WIDTH];
                assign dbg_dm_do_sdram_dly  [dwc_dim*`DWC_RANKS_PER_DIMM+dwc_rnk][dwc_byte] = `RAM_PROBE(dwc_dim,dwc_rnk,dwc_chip).board_delay_model.dm_do_sdram_dly  [dwc_byte%`SDRAM_BYTE_WIDTH];
                for (gen_bit_no = 0; gen_bit_no < 8; gen_bit_no = gen_bit_no + 1) begin : genblk_dbg_dly_bit
                  assign dbg_dq_di_sdram_dly[dwc_dim*`DWC_RANKS_PER_DIMM+dwc_rnk][dwc_byte][gen_bit_no] = `RAM_PROBE(dwc_dim,dwc_rnk,dwc_chip).board_delay_model.dq_di_sdram_dly[dwc_byte%`SDRAM_BYTE_WIDTH];
                  assign dbg_dq_do_sdram_dly[dwc_dim*`DWC_RANKS_PER_DIMM+dwc_rnk][dwc_byte][gen_bit_no] = `RAM_PROBE(dwc_dim,dwc_rnk,dwc_chip).board_delay_model.dq_do_sdram_dly[dwc_byte%`SDRAM_BYTE_WIDTH];
                end
              //end
            end
          end
        end 
      end
    endgenerate 
  
  
    // Delay table printing routine
    task print_table;
      input reg [100 * 8 : 0] data_type;
      input reg [300 * 8 : 0] table_hdr;
    
        reg     [600 * 8 : 0] table_line_str;
        reg     [600 * 8 : 0] table_row_hdr;
        reg     [600 * 8 : 0] table_row_str;
        reg                   print_dq_bits;
        integer               byte_no;
        integer               bit_no;
        integer               rank_no;
    
      begin
          if ((data_type == "DQ_DOUT_DLY") || (data_type == "DQ_DIN_DLY"))
            print_dq_bits = 1;
          else
            print_dq_bits = 0;
          // Build horizontal line
          $sformat(table_line_str,  "+-------------+");
          for (byte_no = 0; byte_no < `DWC_NO_OF_LRANKS; byte_no = byte_no + 1) begin
            $sformat(table_line_str, "%0s-----------------+", table_line_str);
          end
          // Display top of table
          $display("");
          $display("\t%0s", table_line_str);
          $display("\t|      %0s ", table_hdr);
          $display("\t%0s", table_line_str);
          // Build header row
          $sformat(table_row_hdr, "|  Rank       |");
          for (rank_no = 0; rank_no < pNO_OF_LRANKS; rank_no = rank_no + 1) begin
            $sformat(table_row_hdr, "%0s %8d        |", table_row_hdr, rank_no);
          end
          // Display header rows
          $display("\t%0s", table_row_hdr);
          $display("\t%0s", table_line_str);
          // Build table rows
          for (byte_no = 0; byte_no < `DWC_NO_OF_BYTES; byte_no = byte_no + 1) begin
            $sformat(table_row_str, "|   Byte %0d    |", byte_no);
            if (print_dq_bits) begin
              for (rank_no = 0; rank_no < pNO_OF_LRANKS; rank_no = rank_no + 1) begin
                $sformat(table_row_str, "%0s                 |", table_row_str);
              end
              // Display table row
              $display("\t%0s", table_row_str);
              for (bit_no = 0; bit_no < 8; bit_no = bit_no + 1) begin
                $sformat(table_row_str, "|      Bit %0d  |", bit_no);
                for (rank_no = 0; rank_no < pNO_OF_LRANKS; rank_no = rank_no + 1) begin
                  case (data_type)
                    "DQ_DIN_DLY" : $sformat(table_row_str, "%0s    %6d       |", table_row_str, dbg_dq_di_sdram_dly [rank_no][byte_no][bit_no] );
                    "DQ_DOUT_DLY": $sformat(table_row_str, "%0s    %6d       |", table_row_str, dbg_dq_do_sdram_dly [rank_no][byte_no][bit_no] );
                    default : $display("Error: [1] unknown data_type %0s", data_type);
                  endcase
                end
                // Display table row
                $display("\t%0s", table_row_str);
              end
            end
            else begin
              for (rank_no = 0; rank_no < pNO_OF_LRANKS; rank_no = rank_no + 1) begin
                case (data_type)
                  "DQS_DOUT_DLY" : $sformat(table_row_str, "%0s    %6d       |", table_row_str, dbg_dqs_do_sdram_dly [rank_no][byte_no] );
                  "DQS_DIN_DLY"  : $sformat(table_row_str, "%0s    %6d       |", table_row_str, dbg_dqs_di_sdram_dly [rank_no][byte_no] );
                  "DQSN_DOUT_DLY": $sformat(table_row_str, "%0s    %6d       |", table_row_str, dbg_dqsn_do_sdram_dly[rank_no][byte_no] );
                  "DQSN_DIN_DLY" : $sformat(table_row_str, "%0s    %6d       |", table_row_str, dbg_dqsn_di_sdram_dly[rank_no][byte_no] );
                  "DM_DOUT_DLY"  : $sformat(table_row_str, "%0s    %6d       |", table_row_str, dbg_dm_do_sdram_dly  [rank_no][byte_no] );
                  "DM_DIN_DLY"   : $sformat(table_row_str, "%0s    %6d       |", table_row_str, dbg_dm_di_sdram_dly  [rank_no][byte_no] );
                  default : $display("Error: [2] unknown data_type %0s", data_type);
                endcase
              end
              // Display table row
              $display("\t%0s", table_row_str);
            end
          end
          // Display bottom table boundary
          $display("\t%0s", table_line_str);
      end
    endtask
  `endif   // ->> Miguel

`endif //  Not needed in Xilinx's emulation mode

  //----------------------------------------------------------------------------
  // trigger data training and also check the expected data training status - the expected
  // status is already set up by the testcase or calling task
  //----------------------------------------------------------------------------
  task data_train_and_check_status;
    integer rank_no;
    integer byte_no;
    reg rank_en;
    reg byte_en;

    begin
      // need to re-train the bytes and read and check the train status registers to make sure
      // training was successful
      dqs_gate_train(pNO_OF_LRANKS, 0);
    end
  endtask // data_train_and_check_status
  
 
    
  //---------------------------------------------------------------------------
  // Initiate PHY INIT, PHYRST, PLLRST, PLLPWRDN, PHYHSRT
  //---------------------------------------------------------------------------
  task phy_init;
    reg [31:0] tmp;
    begin
      @(posedge clk);
      $display("-> %0t: [SYSTEM] PHY Init Start", $time);
      `CFG.read_register_data(`PIR, tmp);
      
      // set INIT, this bit is self clearing
      @(posedge `CFG.clk);
      `CFG.write_register (`PIR, (tmp | 32'h0000_0001));
      `FCOV_REG.set_cov_registers_write(`PIR , (tmp | 32'h0000_0001),`VALUE_REGISTER_DATA);
      `FCOV_REG.set_cov_init_trig_pll_dcal_phy_dram_scenario;
      `FCOV_REG.set_cov_init_trig_wl_dqsg_data_eye_train_scenario;
      repeat(10)@(posedge clk);
      `GRM.pir[0] = 1'b0;

`ifdef DWC_DDRPHY_EMUL_XILINX
`else
      check_cfg_init_done;
`endif
      repeat(10)@(posedge clk);
    end
  endtask // phy_init

  
  task phy_cal;
    reg [31:0] tmp;
    begin
      @(posedge clk);
      $display("-> %0t: [SYSTEM] PHY CALIBRATION Start", $time);
      tmp = `GRM.pir;
      
      // set DCAL bit, this bit is not self clearing
      @(posedge `CFG.clk);
      `CFG.write_register (`PIR, (tmp | 32'h0000_0021));
      `FCOV_REG.set_cov_registers_write(`PIR , (tmp | 32'h0000_0021),`VALUE_REGISTER_DATA);
      `FCOV_REG.set_cov_init_trig_pll_dcal_phy_dram_scenario;
      `FCOV_REG.set_cov_init_trig_wl_dqsg_data_eye_train_scenario;
      repeat(100)@(posedge clk);
      `CFG.write_register (`PIR, (tmp & 32'hFFFF_FFDE));
      `FCOV_REG.set_cov_registers_write(`PIR , (tmp | 32'hFFFF_FFDE),`VALUE_REGISTER_DATA);
      `FCOV_REG.set_cov_init_trig_pll_dcal_phy_dram_scenario;
      `FCOV_REG.set_cov_init_trig_wl_dqsg_data_eye_train_scenario;
      `GRM.pir[5] = 1'b0;

      phy_calib_done = 1'b0;
      check_cfg_calib_done;   
    end
  endtask // phy_cal

  

  task phy_phyrst;
    reg [31:0] tmp;
    begin
      @(posedge clk);
      $display("-> %0t: [SYSTEM] PHY SOFT RESET Start", $time);
      `CFG.read_register_data(`PIR, tmp);
      
      @(posedge `CFG.clk);
      `CFG.write_register (`PIR, (tmp | 32'h0000_0041));
      `FCOV_REG.set_cov_registers_write(`PIR , (tmp | 32'h0000_0041),`VALUE_REGISTER_DATA);
      `FCOV_REG.set_cov_init_trig_pll_dcal_phy_dram_scenario;
      `FCOV_REG.set_cov_init_trig_wl_dqsg_data_eye_train_scenario;
      repeat(20)@(posedge clk);
      `CFG.write_register (`PIR, (tmp & 32'hFFFF_FFBE));
      `FCOV_REG.set_cov_registers_write(`PIR , (tmp | 32'hFFFF_FFBE),`VALUE_REGISTER_DATA);
      `FCOV_REG.set_cov_init_trig_pll_dcal_phy_dram_scenario;
      `FCOV_REG.set_cov_init_trig_wl_dqsg_data_eye_train_scenario;
      repeat(100)@(posedge clk);

      phy_calib_done = 1'b0;
`ifndef DWC_DDRPHY_EMUL_XILINX
      check_cfg_calib_done;   

      check_cfg_init_done;
`endif
    end
  endtask // phy_phyrst

  
  task phy_pll_init;
    reg [31:0] tmp;
    begin
      @(posedge clk);
      $display("-> %0t: [SYSTEM] PHY PLL INIT Start", $time);
      `CFG.read_register_data(`PIR, tmp);
      
      @(posedge `CFG.clk);
      `CFG.write_register (`PIR, (tmp | 32'h0000_0011));
      `FCOV_REG.set_cov_registers_write(`PIR , (tmp | 32'h0000_0011),`VALUE_REGISTER_DATA);
      `FCOV_REG.set_cov_init_trig_pll_dcal_phy_dram_scenario;
      `FCOV_REG.set_cov_init_trig_wl_dqsg_data_eye_train_scenario;
      repeat(20)@(posedge clk);
      `CFG.write_register (`PIR, (tmp & 32'hFFFF_FFEE));
      `FCOV_REG.set_cov_registers_write(`PIR , (tmp | 32'hFFFF_FFEE),`VALUE_REGISTER_DATA);
      `FCOV_REG.set_cov_init_trig_pll_dcal_phy_dram_scenario;
      `FCOV_REG.set_cov_init_trig_wl_dqsg_data_eye_train_scenario;
      repeat(100)@(posedge clk);

`ifndef DWC_DDRPHY_EMUL_XILINX
      check_cfg_pll_lock_done;   
      check_cfg_init_done;
`endif
    end
  endtask // phy_pllrst
   
  
  task phy_mdlen_bit;
    input reg  mdlen;
    reg [31:0] tmp;
    begin
      `CFG.read_register_data(`PGCR1, tmp);
      
      @(posedge `CFG.clk);
      if (mdlen) begin
        $display("-> %0t: [SYSTEM] PHY AC MDL Enabled", $time);
        `CFG.write_register (`PGCR1, (tmp | 32'h0000_0200));
        `FCOV_REG.set_cov_registers_write(`PGCR1 ,`GRM.pgcr1,`VALUE_REGISTER_DATA);
      end
      else begin
        $display("-> %0t: [SYSTEM] PHY AC MDL Disabled", $time);
        `CFG.write_register (`PGCR1, (tmp & 32'hFFFF_FDFF));
        `FCOV_REG.set_cov_registers_write(`PGCR1 ,`GRM.pgcr1,`VALUE_REGISTER_DATA);
      end
    end
  endtask  // phy_mdlen_bit
  
/*
  task phy_phyhsrt;
    reg [31:0] tmp;
    begin
      @(posedge clk);
      $display("-> %0t: [SYSTEM] PHY HIGH SPEED RESET Start", $time);
      `CFG.read_register_data(`PIR, tmp);
      
      @(posedge `CFG.clk);
      `CFG.write_register (`PIR, (tmp & 32'hFFFF_FFBF));
      repeat(20)@(posedge clk);
      `CFG.write_register (`PIR, (tmp | 32'h0000_0040));
      repeat(100)@(posedge clk);

      check_cfg_calib_done;   

      wait (`PUB.phy_init_done == 1'b1);
      check_cfg_init_done;
    end
  endtask    
*/

  // rand_range_div_10
  task rand_range_div_10;
    input integer     start_num;
    input integer     end_num;
    output real       rnum;
    integer           temp;
    begin
      `SYS.RANDOM_RANGE(`SYS.seed_rr, start_num, end_num, temp);
      rnum = temp / 10.0;
    end
  endtask
  
  // rand_range_div_100
  task rand_range_div_100;
    input integer     start_num;
    input integer     end_num;
    output real       rnum;
    integer           temp;
    begin
      `SYS.RANDOM_RANGE(`SYS.seed_rr, start_num, end_num, temp);
      rnum = temp / 100.0;
    end
  endtask


  //---------------------------------------------------------------------------
  // BIST
  //---------------------------------------------------------------------------
  task set_bist_run;
    input [2:0]       binst;      // BIST instruction select
    input             bmode;      // BIST Mode
    input             binf;       // BIST Infinite run
    input [7:0]       nfail;      // BIST no of failures if exceeded, will STOP
    input             bsonf;      // BIST STOP on Nth FAIL
    input             bdxen;      // BIST DATX8 Enable
    input             bacen;      // BIST AC Enable
    input             bdmen;      // BIST DATA Mask Enable
    input [4:0]       bdpat;      // BIST DATA Pattern Select
    input [3:0]       bdxsel;     // BIST DATX8 Select
    input [1:0]       bcksel;     // BIST CK Select
    input [1:0]       bccsel;     // BIST Clock Cycle Select
    
    reg [`REG_DATA_WIDTH-1:0] word;
    reg [2:0] lpddr2_dgsl;
    reg [1:0] lpddr2_dgps;
    integer rank_id;
    begin
      // Ensure any previous run has completed
`ifndef DWC_DDRPHY_EMUL_XILINX
      wait (`PUB.bist_mode == 0);
`endif

      // if running AC loopback, make sure the I/O receivers are not powered down
      if (bacen) begin
        word       = `GRM.aciocr0;
        word[4]     = 1'b0;
        word[13:10] = 4'b0000;
        word[25:22] = 4'b0000; 
        word[28]    = 1'b0;

        if (word != `GRM.aciocr0) begin
          `CFG.write_register(`ACIOCR0, word);
          `FCOV_REG.set_cov_registers_write(`ACIOCR0,`GRM.aciocr0,`VALUE_REGISTER_DATA);           
        end
      end
 
      `GRM.riocr0[27:16] = 12'd0; 
      `CFG.write_register(`RIOCR0, `GRM.riocr0);
      `GRM.riocr1[15:8] = 8'd0;
      `GRM.riocr1[31:24] = 8'd0;
      `CFG.write_register(`RIOCR1, `GRM.riocr1);
     

    
      `ifdef DWC_LOOP_BACK
        @(posedge `CFG.clk);
        if (`GRM.pgcr1[31]) begin
          $display("-> %0t: [SYSTEM] PGCR1.LBMODE is set - this is not meant to be set during BIST.  Clearing bit-field..", $time);
          `GRM.pgcr1[31] = 1'b0;
          `CFG.write_register(`PGCR1, `GRM.pgcr1);
          `FCOV_REG.set_cov_registers_write(`PGCR1,`GRM.pgcr1,`VALUE_REGISTER_DATA);
        end 
      `endif
      
      @(posedge `CFG.clk);
      `GRM.bistrr = {{2{1'b0}}, bccsel, bcksel, bdxsel, bdpat, bdmen, bacen, bdxen, bsonf, nfail, binf, bmode, binst};
      `CFG.write_register(`BISTRR, `GRM.bistrr);
      `FCOV_REG.set_cov_registers_write(`BISTRR,`GRM.bistrr,`VALUE_REGISTER_DATA); 
      // Wait a few cycles until the BIST engine has started up
      repeat (50) @(posedge `SYS.clk);
    end
  endtask // set_bist_run_register


  task set_bist_wc;
    input [15:0]  bwcnt;
    begin
      @(posedge `CFG.clk);
      `GRM.bistwcr = {{16{1'b0}},bwcnt};
      `CFG.write_register(`BISTWCR, `GRM.bistwcr);
      `FCOV_REG.set_cov_registers_write(`BISTWCR,`GRM.bistwcr,`VALUE_REGISTER_DATA);           
    end
  endtask // set_bist_wc

  
  task set_bistar0;
    input integer    bank;
    input integer    row;
    input integer    col;
    reg   [4  -1:0] bbank_field;
    reg   [18 -1:0] brow_field;
    reg   [11:0]    bcol_field;

    begin
      bbank_field = bank;
      brow_field  = row;
      bcol_field  = col;
      @(posedge `CFG.clk);
      `GRM.bistar0        = 32'd0;
      `GRM.bistar0[11: 0] = bcol_field;
      `GRM.bistar0[31:28] = bbank_field;
      `CFG.write_register(`BISTAR0, `GRM.bistar0);
      `FCOV_REG.set_cov_registers_write(`BISTAR0,`GRM.bistar0,`VALUE_REGISTER_DATA);           
      `GRM.bistar3        = 32'd0;
      `GRM.bistar3[17: 0] = brow_field;
      `CFG.write_register(`BISTAR3, `GRM.bistar3);
      `FCOV_REG.set_cov_registers_write(`BISTAR3,`GRM.bistar3,`VALUE_REGISTER_DATA);           
    end
  endtask // set_bistar0


  task set_bistar1;
    input [11:0]  bainc;
    input [1:0]   bmrank;
    input [1:0]   brank;
    begin
      @(posedge `CFG.clk);
      `GRM.bistar1 = {{16{1'b0}}, bainc, bmrank, brank};
      `CFG.write_register(`BISTAR1, `GRM.bistar1);
      `FCOV_REG.set_cov_registers_write(`BISTAR1,`GRM.bistar1,`VALUE_REGISTER_DATA);           
    end
  endtask // set_bistar1

      
  task set_bistar2;
    input integer    bank;
    input integer    row;
    input integer    col;

    reg   [4  -1:0] bmbank_field;
    reg   [18 -1:0] bmrow_field;
    reg   [11:0]    bmcol_field;

    begin
      bmbank_field = bank;
      bmrow_field  = row;
      bmcol_field  = col;
      @(posedge `CFG.clk);
      `GRM.bistar2        = 32'd0;
      `GRM.bistar2[11: 0] = bmcol_field;
      `GRM.bistar2[31:28] = bmbank_field;
      `CFG.write_register(`BISTAR2, `GRM.bistar2);
      `FCOV_REG.set_cov_registers_write(`BISTAR2,`GRM.bistar2,`VALUE_REGISTER_DATA);           
      `GRM.bistar4        = 32'd0;
      `GRM.bistar4[17: 0] = bmrow_field;
      `CFG.write_register(`BISTAR2, `GRM.bistar4);
      `FCOV_REG.set_cov_registers_write(`BISTAR2,`GRM.bistar4,`VALUE_REGISTER_DATA);           
    end
  endtask // set_bistar2


  task set_bistmskr0;
    input [18 - 1  : 0]  amsk;
    input                rasmsk;
    input [12  - 1  : 0]  csmsk;
    begin
      @(posedge `CFG.clk);
      `GRM.bistmskr0 = {csmsk, rasmsk, 1'b0, amsk};
      `CFG.write_register(`BISTMSKR0, `GRM.bistmskr0);
      `FCOV_REG.set_cov_registers_write(`BISTMSKR0,`GRM.bistmskr0,`VALUE_REGISTER_DATA);           
    end
  endtask // set_bistmskr0


  task set_bistmskr1;
    input [4  - 1  : 0]  x4_dmmsk;
    input [4  - 1  : 0]  bamsk;
    input [8  - 1  : 0]  ckemsk;
    input [8  - 1  : 0]  odtmsk;
    input [3  - 1  : 0]  cidmsk;
    input                parmsk;
    input [4  - 1  : 0]  dmmsk;

    begin
      @(posedge `CFG.clk);
      `GRM.bistmskr1        = 32'd0;
      `GRM.bistmskr1[31:28] = dmmsk;
      `GRM.bistmskr1[27]    = parmsk;
      `GRM.bistmskr1[26:24] = cidmsk;
      `GRM.bistmskr1[23:16] = odtmsk;
      `GRM.bistmskr1[15:8]  = ckemsk;
      `GRM.bistmskr1[7: 4]  = bamsk;
      `GRM.bistmskr1[3:0]   = x4_dmmsk;
      `CFG.write_register(`BISTMSKR1, `GRM.bistmskr1);
      `FCOV_REG.set_cov_registers_write(`BISTMSKR1,`GRM.bistmskr1,`VALUE_REGISTER_DATA);           
    end
  endtask // set_bistmskr1


  task set_bistmskr2;
    input [16 - 1  : 0]  dqmsk;
    begin
      @(posedge `CFG.clk);
      `GRM.bistmskr2 = {dqmsk};
      `CFG.write_register(`BISTMSKR2, `GRM.bistmskr2);
      `FCOV_REG.set_cov_registers_write(`BISTMSKR2,`GRM.bistmskr2,`VALUE_REGISTER_DATA);           
    end
  endtask // set_bistmskr2


   // set bistlsr with a 32 bit random number
  task random_bistlsr;
    reg [31:0] word;
    begin
      word = {$random};
      `GRM.bistlsr = word;
      `CFG.write_register(`BISTLSR, word);
      `FCOV_REG.set_cov_registers_write(`BISTLSR,`GRM.bistlsr,`VALUE_REGISTER_DATA);           
    end
  endtask // random_bistlsr

       
  task set_bistudpr;
    input [15:0] budp0;
    input [15:0] budp1;
    begin
      @(posedge `CFG.clk);
      `GRM.bistudpr = {budp1, budp0};
      `CFG.write_register(`BISTUDPR, `GRM.bistudpr);
      `FCOV_REG.set_cov_registers_write(`BISTUDPR,`GRM.bistudpr,`VALUE_REGISTER_DATA);           
    end
  endtask 

      
  task probing_bist_done;
    begin
      // probing into rtl
`ifndef DWC_DDRPHY_EMUL_XILINX
      wait (`PUB.u_DWC_ddrphy_cfg.i_cfg_bistgsr_bdone == 1'b1);
`endif
    end
  endtask // probing_bist_done
  
  
  task polling_bist_done;
    reg [31:0]   tmp;
    begin

      // polling status...
      `CFG.disable_read_compare;
      @(posedge `CFG.clk);
      `CFG.read_register_data(`BISTGSR, tmp);

      while(tmp[0] == 1'b0) begin
        repeat (200) @(posedge clk);
        `CFG.read_register_data(`BISTGSR, tmp);
      end

      $display("-> %0t: [SYSTEM] BISTGSR.BDONE asserted...",$time);
      repeat (2) @(posedge `CFG.clk);      
      `CFG.enable_read_compare;
    end
  endtask // check_bist_done
  

  //---------------------------------------------------------------------------
  // Simulation Control
  //---------------------------------------------------------------------------
  // time format
  // -----------
  // report time in ns with 3-digit precision
  initial
    begin
      // time print format
      $timeformat(-9, 3, " ns", 20);

      // open vector files
`ifdef TESTER_VECTORS
      tester_vec_file_ptr = $fopen(`TC_VEC_FILE);
`endif

`ifdef SVB_VECTORS
      svb_vec_file_ptr = $fopen(`SVB_VEC_FILE);
`endif

`ifdef OPCODE_VECTORS
      opcode_vec_file_ptr = $fopen(`OPCODE_FILE);
`endif

      // the following are enabled after reset is asserted
//`ifdef QIMONDA_DDR
//`else
//      @(negedge rst_b);
//`endif

      // the following are enabled after reset is de-asserted
      @(posedge rst_b);
      // monitors

`ifdef MNT_DDR
      // enable the monitor between the controller and DDR SDRAMs
      rank_cfg_sel = pRANK_MNT_EN;
      -> e_configure_rank;
      #0.001;
`endif 

`ifdef MNT_HOST
      // enable the monitor between the chip logic and the controller
      `CFG_MNT.mnt_en  = 1'b1;
      `HOST_MNT.mnt_en = 1'b1;
  `ifdef DWC_USE_SHARED_AC_TB
      `HOST_MNT1.mnt_en = 1'b1;
  `endif
`endif

`ifdef MNT_DFI
      // enable the monitor of DFI transactions
      `DFI_MNT.mnt_enable = 1'b1;
`endif
      
`ifdef MNT_CHIP
      // enable the monitor on the chip interface bus
      `CHIP_MNT.mnt_en = 1'b1;
`endif 
    end // initial begin


  // undefined value monitor
  // -----------------------
  // disable/enable the monitoring and resulting warning when data have
  // undefined (X/Z) values
  task enable_undefined_warning;
    begin
      `HOST_MNT.undf_mnt_en = 1'b1;
      set_rank_undefined_warning(1);
  `ifdef DWC_USE_SHARED_AC_TB
      `HOST_MNT1.undf_mnt_en = 1'b1;
  `endif
    end
  endtask // enable_undefined_warning

  task disable_undefined_warning;
    begin
      `HOST_MNT.undf_mnt_en = 1'b0;
  `ifdef DWC_USE_SHARED_AC_TB
      `HOST_MNT1.undf_mnt_en = 1'b0;
  `endif
      set_rank_undefined_warning(0);
    end
  endtask // disable_undefined_warning

  task set_rank_undefined_warning;
    input mnt_en;
    begin
      // enable/disbale the monitor between the controller and DDR SDRAMs
`ifdef MNT_DDR
      rank_cfg_sel = (mnt_en) ? pRANK_UNDF_MNT_EN : pRANK_UNDF_MNT_DIS;
      -> e_configure_rank;
      #0.001;
`endif 
    end
  endtask // set_rank_undefined_warning
  

  // end simulation
  // --------------
  task end_simulation;
    input run;
 
    integer max_all_rd_fifo_num_entries;
    integer max_all_gdqs_dly_fifo_num_entries;
    integer max_all_rd_lat_odd_fifo_num_entries;
    integer max_all_wr_lat_odd_fifo_num_entries;
    integer max_all_wl_dly_sel_fifo_num_entries;
    integer bl_idx;

    begin
      // wait a few clocks to allow the last instruction to finish and make
      // sure the controller does not generate extra results
      repeat(100) @(posedge clk);

      // report the status of DCU caches if DCU commands were run
      if (`GRM.dcu_was_run) begin
        `ifdef DWC_DDRPHY_EMUL_XILINX
          // re-enable the refresh on the controller
          `GRM.drr[31] = 1'b1;
          `SYS.precharge_all(`ALL_RANKS);
        `endif
        report_dcu_status;
      end

      // verify that the correct number of read data (qvld) and write tags
      // (wdone) have been received for each port
      verify_number_of_results;

`ifdef SDF_ANNOTATE
`else
/* -----\/----- EXCLUDED -----\/-----
`ifdef DWC_USE_SHARED_AC_TB
      // Check that PHY-update state machines are in their IDLE states
      if ((`PHYDFI.chn[0].dx.phy_ctl.state_phyupd != 0) && (`DFI_MNT.dfi_phyupd_state_mon == `DFI_MNT.pS_DFI_PHYUPD_STATE_IDLE) && check_dfi_fsm) begin
        `SYS.error;
        $display("-> %0t: ERROR: 1.) DFI PHY-update state machine (state_phyupd) not in IDLE state!", $time);
      end
      if (`PHYDFI.chn[0].dx.phy_ctl.state_ctlupd != 0 && check_dfi_fsm) begin
        `SYS.error;
        $display("-> %0t: ERROR: 2.) DFI PHY-update state machine (state_ctlupd) not in IDLE state!", $time);
        $display("-> %0t: `PHYDFI.chn[0].dx.phy_ctl.state_ctlupd = %0d, check_dfi_fsm = %0d", $time, `PHYDFI.chn[0].dx.phy_ctl.state_ctlupd, check_dfi_fsm);
      end
`elsif DWC_SINGLE_CHANNEL
      // Check that PHY-update state machines are in their IDLE states
      if ((`PHYDFI.chn[0].dx.phy_ctl.state_phyupd != 0) && (`DFI_MNT.dfi_phyupd_state_mon == `DFI_MNT.pS_DFI_PHYUPD_STATE_IDLE) && check_dfi_fsm) begin
        `SYS.error;
        $display("-> %0t: ERROR: 1.) DFI PHY-update state machine (state_phyupd) not in IDLE state!", $time);
      end
      if (`PHYDFI.chn[0].dx.phy_ctl.state_ctlupd != 0 && check_dfi_fsm) begin
        `SYS.error;
        $display("-> %0t: ERROR: 2.) DFI PHY-update state machine (state_ctlupd) not in IDLE state!", $time);
        $display("-> %0t: `PHYDFI.chn[0].dx.phy_ctl.state_ctlupd = %0d, check_dfi_fsm = %0d", $time, `PHYDFI.chn[0].dx.phy_ctl.state_ctlupd, check_dfi_fsm);
      end
`else
      // Check that PHY-update state machines are in their IDLE states
      if ((`PHYDFI.chn[0].dx.phy_ctl.state_phyupd != 0) && (`DFI_MNT.dfi_phyupd_state_mon == `DFI_MNT.pS_DFI_PHYUPD_STATE_IDLE) && check_dfi_fsm) begin
        `SYS.error;
        $display("-> %0t: ERROR: DFI PHY-update state machine (state_phyupd) not in IDLE state!", $time);
      end
      if (`PHYDFI.chn[0].dx.phy_ctl.state_ctlupd != 0 && check_dfi_fsm) begin
        `SYS.error;
        $display("-> %0t: ERROR: DFI PHY-update state machine (state_ctlupd) not in IDLE state!", $time);
      end
`endif
 -----/\----- EXCLUDED -----/\----- */
`ifndef DWC_DDRPHY_NO_PZQ
      if (`ZCAL_FSM.io_vt_drift) begin
          `SYS.error;
          $display("-> %0t: ERROR: io_vt_drift is still asserted at end of simulation. A DFI/PHY update is missing", $time);
      end
`endif      
      max_all_rd_fifo_num_entries         = 0;
      max_all_gdqs_dly_fifo_num_entries   = 0;
      max_all_rd_lat_odd_fifo_num_entries = 0;
      max_all_wr_lat_odd_fifo_num_entries = 0;
      max_all_wl_dly_sel_fifo_num_entries = 0;
      for (bl_idx = 0; bl_idx < `DWC_NO_OF_BYTES; bl_idx = bl_idx + 1) begin
        // Read data FIFO
        if (`DFI_MNT.max_rd_fifo_num_entries[bl_idx] > max_all_rd_fifo_num_entries)
          max_all_rd_fifo_num_entries = `DFI_MNT.max_rd_fifo_num_entries[bl_idx];
        // Read gdqs_dly FIFO
        if (`DFI_MNT.max_gdqs_dly_fifo_num_entries[bl_idx] > max_all_gdqs_dly_fifo_num_entries)
          max_all_gdqs_dly_fifo_num_entries = `DFI_MNT.max_gdqs_dly_fifo_num_entries[bl_idx];
        // Read rd_lat_odd FIFO
        if (`DFI_MNT.max_rd_lat_odd_fifo_num_entries[bl_idx] > max_all_rd_lat_odd_fifo_num_entries)
          max_all_rd_lat_odd_fifo_num_entries = `DFI_MNT.max_rd_lat_odd_fifo_num_entries[bl_idx];
        // Read wr_lat_odd FIFO
        if (`DFI_MNT.max_wr_lat_odd_fifo_num_entries[bl_idx] > max_all_wr_lat_odd_fifo_num_entries)
          max_all_wr_lat_odd_fifo_num_entries = `DFI_MNT.max_wr_lat_odd_fifo_num_entries[bl_idx];
        // Read wl_dly_sel FIFO
        if (`DFI_MNT.max_wl_dly_sel_fifo_num_entries[bl_idx] > max_all_wl_dly_sel_fifo_num_entries)
          max_all_wl_dly_sel_fifo_num_entries = `DFI_MNT.max_wl_dly_sel_fifo_num_entries[bl_idx];
      end
      if (verbose > 7) begin
        $display("-> %0t: [SYS] READ  data       FIFO maximum depth utilized = %0d (max_all_rd_fifo_num_entries)", $time, max_all_rd_fifo_num_entries);
        $display("-> %0t: [SYS] READ  gdqs_dly   FIFO maximum depth utilized = %0d (max_gdqs_dly_fifo_num_entries)", $time, max_all_gdqs_dly_fifo_num_entries);
        $display("-> %0t: [SYS] READ  rd_lat_odd FIFO maximum depth utilized = %0d (max_rd_lat_odd_fifo_num_entries)", $time, max_all_rd_lat_odd_fifo_num_entries);
        $display("-> %0t: [SYS] WRITE wr_lat_odd FIFO maximum depth utilized = %0d (max_wr_lat_odd_fifo_num_entries)", $time, max_all_wr_lat_odd_fifo_num_entries);
        $display("-> %0t: [SYS] WRITE wl_dly_sel FIFO maximum depth utilized = %0d (max_wl_dly_sel_fifo_num_entries)", $time, max_all_wl_dly_sel_fifo_num_entries);
      end
`endif

      $display("");
      -> e_end_simulation;
      repeat(1) @(posedge clk);
      $display("");
      
      // end of simulation messages
      message(`SYS_OP, `END_SIM, 0);
      
      if (errors || warnings)
        begin
          $display("\n%s=> %0d errors and %0d warnings <=", ident,
                   errors, warnings);
        end
          
      if (errors || (warnings && fail_on_warning))
        begin
          $display("\n%s   *** Testcase FAILED ***", ident);
        end
      else
        begin
          $display("\n%s   *** Testcase PASSED ***", ident);
        end
      
      $display("\n");

      // close all open files
`ifdef TESTER_VECTORS
      $fclose(tester_vec_file_ptr);
`endif

`ifdef SVB_VECTORS
      $fclose(svb_vec_file_ptr);
`endif

`ifdef OPCODE_VECTORS
      $fclose(opcode_vec_file_ptr);
`endif
      
`ifdef simvision
      $shm_close;
`endif

`ifdef MODELSIM
      $stop;
`else
      $finish;
`endif
    end
  endtask // end_simulation


  
  // stop on error
  //--------------
  reg     stop_err_sim;

  // Track when the number os errors exceeds the maximum tolerable
  always @* begin
    if ((errors >= n_err_max) && !stop_err_sim)
      stop_err_sim = 1;
  end

  // Once the number of errors exceeds our tolerence, end the simulation
  initial begin
    stop_err_sim = 0;
    @(posedge stop_err_sim);
    repeat (5) @(posedge clk);
    // end of simulation messages
    message(`SYS_OP, `END_SIM, 0);
      
    if (errors || warnings) $display("\n%s=> %0d errors and %0d warnings <=", ident, errors, warnings);
         
    if (errors || (warnings && fail_on_warning)) $display("\n%s   *** Testcase FAILED ***", ident);
    else                                         $display("\n%s   *** Testcase PASSED ***", ident);
      
    $display("\n");

    // close all open files
`ifdef TESTER_VECTORS
    $fclose(tester_vec_file_ptr);
`endif

`ifdef SVB_VECTORS
    $fclose(svb_vec_file_ptr);
`endif

`ifdef OPCODE_VECTORS
    $fclose(opcode_vec_file_ptr);
`endif
      
`ifdef simvision
    $shm_close;
`endif

`ifdef MODELSIM
    $stop;
`else
    $finish;
`endif
  end


  // verify number of results
  // ------------------------
  // verifies that the correct number of read data (qvld) and write tags have
  // been received for each port
  task verify_number_of_results;
    reg [31:0] read_cnt;
    reg [31:0] xpctd_read_cnt;
    integer rslt_wait;
    reg     init_chk;
    begin
      rslt_wait = 0;
      
      // configuration port
      init_chk = 1'b1;
      while ((init_chk == 1'b1) || 
             ((read_cnt !== xpctd_read_cnt) && (rslt_wait < MAX_RSLT_WAIT)))
        begin
          if (!init_chk)
            begin
              @(posedge clk);
              rslt_wait = rslt_wait + 1;
            end
          read_cnt       = `GRM.cfg_reads_rxd;
          xpctd_read_cnt = `GRM.cfg_reads_txd;
          init_chk       = 1'b0;
        end
      
      if (read_cnt !== xpctd_read_cnt)
        begin
          `SYS.error_message(`SYS_OP, `RDCNTERR, 
                             {1'b1, read_cnt, xpctd_read_cnt});
        end
      
      // host ports
      init_chk = 1'b1;
      while ((init_chk == 1'b1) || 
             ((read_cnt !== xpctd_read_cnt) && (rslt_wait < MAX_RSLT_WAIT)))
        begin
          if (!init_chk)
            begin
              @(posedge clk);
              rslt_wait = rslt_wait + 1;
            end
          
          // get the amount of read data received on the port
          read_cnt = `GRM.host_reads_rxd;
      
          // generated the expected number based on the number of read/writes
          // issued and the burst length
          // NOTE: don't expect returned data for testcases specific to AC 
          //       loopback
          xpctd_read_cnt = (`SYS.tc_ac_lb_only) ? 0 :
                           (`GRM.host_reads_txd == 0) ? 0 :
                           `GRM.host_reads_txd*(`GRM.ctrl_burst_len) -
                           `GRM.bl4_reads_txd*(2/`CLK_NX);
          init_chk       = 1'b0;
        end
      
      if (read_cnt !== xpctd_read_cnt)
        begin
          `SYS.error_message(`SYS_OP, `RDCNTERR, 
                             {1'b0, read_cnt, xpctd_read_cnt});
        end
    end
  endtask // verify_number_of_results


  // This task random row address for ddr4 mode according to the 
  // sdram config used
  task get_ddr4_rand_row;
    output reg [`SDRAM_ROW_WIDTH-1:0]  row;
    begin
      row  = {$random(`SYS.seed)};
`ifdef DDR4
      // SDRAM_ROW_WIDTH is defined to be 18 for DDR4 mode,
      // but the actual row width for the ddr4 is dependent on the sdram chip used
      // Hence limit the row width when randomizing to be within the DDR4 row address
      // allowable
      if (`SDRAM_ROW_WIDTH > `SDRAM_ROW_CFG_WIDTH)         
        row[`SDRAM_ROW_WIDTH - 1: `SDRAM_ROW_CFG_WIDTH] = {(`SDRAM_ROW_WIDTH -`SDRAM_ROW_CFG_WIDTH){1'b0}};    
`endif
    end
  endtask                      

  // This Random task assume start_range is smaller than stop_range
  // Random Number generator from:
  // The Art of Computer Systems Performance Analysis, R.Jain 1991 (p443)
  //   x(n) := 7^5x(n-1) mod (2^31 - 1)
  //   This has period 2^31 - 2, and it works with odd or even seeds
  //   This code does not overflow for 32 bit integers.
  task RANDOM_RANGE;
    inout  seed;
    input  integer start_range;
    input  integer stop_range;
    output x;

    integer a;
    integer m;
    integer q;
    integer r;
    integer seed;
    real m_real;    

    integer seed_div_q;
    integer seed_mod_q;
    integer new_seed;
    integer x;
    integer i;

    begin

      x = 0;

      a = 16807;         //-- multiplier 7**5
      m = 2147483647;    //-- modulus    2**31 - 1
      q = 127773;        //-- m DIV a
      r = 2836;          //-- m MOD a
      m_real = $itor(m); // = real(M);

      seed_div_q = seed / q;       //-- truncating integer division
      seed_mod_q = seed % q;       //-- modulus
      new_seed = a * seed_mod_q - r * seed_div_q;
      if (new_seed > 0)
        seed = new_seed;
      else
        seed = new_seed + m;
      //     x = $itor / m_real;
      x = seed;

      x = (x%(stop_range -start_range +1)) + start_range;
    end
  endtask // RANDOM_RANGE
  

	function [15:0] random_16b;
	  input       dummy;
	  reg [15:0]  tmp;
	  begin
	    tmp = {$random};
	    random_16b = tmp;
	  end
	endfunction
    
      
  //---------------------------------------------------------------------------
  // Errors and Warnings
  //---------------------------------------------------------------------------

  // log error and warning
  // ---------------------
  task error;
    begin
      if (!stop_on_perr) errors = errors + 1;
    end
  endtask // error

  // alias of error()
  task log_error;
    begin
      error;
    end
  endtask // log_error

  task warning;
    begin
      if (!stop_on_perr) warnings = warnings + 1;
    end
  endtask // warning

  // alias of warning()
  task log_warning;
    begin
      warning;
    end
  endtask // log_warning

  
  // enable/disable the failing of a testcase due to warnings
  task enable_fail_on_warning;
    begin
      fail_on_warning = 1'b1;
    end
  endtask // enable_fail_on_warning
  
  task disable_fail_on_warning;
    begin
      fail_on_warning = 1'b0;
    end
  endtask // disable_fail_on_warning

  // clear errors and warnings
  task clear_errors;
    begin
      errors = 0;
    end
  endtask // clear_errors

  task clear_warnings;
    begin
      warnings = 0;
    end
  endtask // clear_warnings

  
  // error messages
  // --------------
  // logs the error and prints a message
  task error_message;
    input [2:0]   err_grp;
    input [31:0]  err_type;
    input [355:0] parameters;

    reg [31:0]                 op;
    reg [`HOST_TAG_WIDTH-1:0]  tag;
    reg [`DATA_WIDTH-1:0]      data;
    reg [`DWC_ADDR_WIDTH-1:0]  addr;
    reg [5:0]                  pin_id;
    reg                        cfg_port;
    reg [31:0]                 parity;
    reg [31:0]                 xpctd_parity;
    reg [`REG_ADDR_WIDTH-1:0]  cfg_addr;
    reg [`REG_DATA_WIDTH-1:0]  cfg_data;

    begin
      // error message header
      $write("-> %0t: %s*** ", $realtime, ident);
      case (err_grp)
        `CHIP_CTRL:
          begin
            data = parameters;
            $write("[HOST 0] ");
          end
        `CHIP_CFG:   $write("[CFG] ");
        `CTRL_SDRAM: $write("[RANK] ");
        `JTAG_CFG:   $write("[JTAG_CFG] ");
        `CTRL_ACLB:  $write("[ACLB] ");
        `SYS_OP:     $write("[SYS] ");
        `CTRL_RDIMM: $write("[RDIMM] ");
        `CHIP_CTRL_1:
          begin
            data = parameters;
            $write("[HOST 1] ");
          end
      endcase // case(err_grp)
        
      if (|err_type == 'bX)
        begin
          error; // log error
          if (suppress_err_msg)
            $write("INFO: ");
          else
            $write("ERROR: ");
        end
      else if (err_type > `WARN_BASEID)
        begin
          warning; // log warning
          if (suppress_err_msg)
            $write("INFO: ");
          else
            $write("WARNING: ");
        end
      else if (err_type === `QERR || err_type === `CTRLPINERR || err_type === `ACLBERR)
        begin
          error; // log error
          if (suppress_err_msg)
            $write("INFO: Expected ");
          else
            $write("ERROR: Expected ");
        end
      else
        begin
          error; // log error
          if (suppress_err_msg)
            $write("INFO: ");
          else
            $write("ERROR: ");
        end

      // print error message
      case (err_type)
        `QERR:
          begin
            // errors on data read out of the controller
            if (err_grp == `CHIP_CTRL || err_grp == `CHIP_CTRL_1)
              begin
                data = parameters;
                $write("Q = %h", data);
              end
            else
              begin
                {cfg_addr, cfg_data} = parameters;
                $write("Q[");
                print_register(cfg_addr);
                $write("] = %h", cfg_data);
              end
          end
        `ACLBERR:
          begin
            // errors on data read out of the controller
            data = parameters;
            $write("Q = %h", data);
          end
        `DATAXWARN:
          begin
            // signal has has x's or z's
            pin_id = parameters;
            print_pin_name(pin_id);
            $write(" has X's or Z's");
          end
        `RDCNTERR:
          begin
            // a port received less/more read data than expected
            {cfg_port, parity, xpctd_parity} = parameters;
            if (cfg_port)
              begin
                $write("Configuration port");
              end
            else
              begin
                $write("Host");
              end
            $write(" received %0d read data words; expected %0d words",
                   parity, xpctd_parity);
          end
        `INITCMDERR:
          begin
            // initialization command sequence error
            {addr, op} = parameters;
            $write("Wrong initialization command sequence; expected ");
            if (err_grp == `CTRL_RDIMM) begin
              $write("RC%0d <= %h", parameters[3:0], parameters[7:4]);
            end else begin
              case (op)
                `PRECHARGE_ALL: $write("Precharge-all");
                `REFRESH:       $write("Refresh");
                `LOAD_MODE:
                  begin
                    $write("Load Mode Register ");
                    case (addr[1:0])
                      2'b00: print_register(`MR0_REG);                                                              
                      2'b01: print_register(`MR1_REG);                                                              
                      2'b10: print_register(`MR2_REG);                                                              
                      2'b11: print_register(`MR3_REG);
                    endcase                                     
                  end
                default: $write("Unknown (op = %h)", op);
              endcase // case(op)
            end
          end
        `CMDTIMEERR:
          begin
            // wrong command-to-command timing
            op = parameters;
            $write("Wrong command-to-command timing; expected %0d clocks", op);
          end
        `INITDATAERR:
          begin
            // wrong initialization data
            {addr, op[`DWC_BANK_WIDTH-1:0]} = parameters;
            $write("Initialization data (address); expected BA = %h, A = %h", 
                    op[`DWC_BANK_WIDTH-1:0], addr);
          end
        `INITWAITERR:
          begin
            // wrong initialization wait times
            op = parameters[2:0];
            case (op)
              0:
                begin
                  // from reset going high to CKE going high must be at least
                  // 1024 clocks for command-lane PLL to lock plus 80000 clocks
                  // for the SDRAM 200us wait (calculated at 400MHz); maximum
                  // variation 100 clocks is allowed to check controller
                  // functionality
                  $write("Wrong reset to CKE high wait time (clocks); ");
                  $write("expected at least 1024 + 80000 (+100)");
                end
              1:
                begin
                  // from CKE going high to first instruction is expected to
                  // be 400ns or 160 clocks @ 400MHz
                  $write("Wrong CKE to Precharge-all wait time (clocks); ");
                  $write("expected at least 160 (+50)");
                end
              2, 3:
                begin
                  // Atleast 200 clocks must be waited after DLL reset
                  $write("DLL reset to ");
                  case (op)
                    2: $write("Load EMR (OCD Default)");
                    3: $write("initialization done");
                  endcase // case(op)
                  $write(" is expected to be at least 200 (+25)");
                end
            endcase // case(op)
          end
        `RFSHCMDERR:
          begin
            // auto-refresh command sequence error
            {addr, op} = parameters;
            $write("Wrong auto-refresh command sequence; expected ");
            case (op)
              `PRECHARGE_ALL: $write("Precharge-all");
              `REFRESH:       $write("Refresh");
              default:        $write("Unknown (op = %h)", op);
            endcase // case(op)
          end
        `RFSHNEVER:
          begin
            if (err_grp == `CTRL_RDIMM) begin
              $write("Wrong RDIMM buffer chip initialization; expected %0d RCn register writes, got %0d",
                     parameters[3:0], parameters[7:4]);
            end else begin
              // refresh never happens
              op = parameters;
              $write("Initial refresh never happened, expected it at %0d clocks", op);
            end
          end
        `RFSHPRDERR:
          begin
            // wrong refresh period
            op = parameters;
            $write("Wrong refresh period; expected %0d clocks (+-200)", op);
          end
        `ODTERR:
          begin
            // ODT error
            op = parameters;
            $write("ODT timing is incorrect");
          end
        `UNKNOWN_BANKS:
          begin
            $write("Undefined bank selected for read or write");
          end
        `UNDFND_DDRRW:
          begin
            $write("Undefined DDR read or write command");
          end
        `UNDFND_REGRW:
          begin
            $write("Undefined controller register read or write command");
          end
        `WLERR: $write("Write leveling error");
        `PARERR:
          begin
            parity = parameters[31:0];
            case (parity)
              0: $write("Expected some parity errors but got none");
              1: $write("Parity error");
              2: $write("The dfi_parity_error signal is not correctly synchronized from RDIMM ERROR_B signal");
            endcase
          end
        `BADSTIMULI: $write("Bad testcase stimuli");
        `UNKNOWN_REG: $write("Illegal register selection");
        `CONCUR_DDRREG: $write("Concurrent DDR and register access");
        `RDIMM3CS: $write("RDIMM register write has 3 CS# bits asserted");
      endcase // case(err_type)
      
      $write("\n"); // end-of-line
    end
  endtask // error_message

  // report error
  // this is just an alias of error_message()
  task report_error;
    input [2:0]   err_grp;
    input [31:0]  err_type;
    input [355:0] parameters;    
    begin
      error_message(err_grp, err_type, parameters);
    end
  endtask // report_error
  
          
  //---------------------------------------------------------------------------
  // Messages
  //---------------------------------------------------------------------------
  // simulation messages
  task message;
    input [3:0]   msg_grp;
    input [31:0]  msg_type;
    input [400:0] parameters; // concatenate all parameters into one

    // chip logic to controller interface
    reg [`HOST_ADDR_WIDTH-1:0] a;
    reg [`HOST_DQS_WIDTH-1:0]  dm;
    reg [`DATA_WIDTH-1:0]      d;
    reg [`DATA_WIDTH-1:0]      q;
                               
    reg [`SDRAM_BANK_WIDTH-1:0]  bank;
    reg [`SDRAM_ROW_WIDTH-1:0] row;
    reg [`SDRAM_COL_WIDTH-1:0] col;
    reg [pRANK_WIDTH-1:0]      rank;
                               
    reg [`DDR_RANK_WIDTH-1:0]  mapped_rank;
    reg [`DWC_BANK_WIDTH-1:0]  mapped_bank;
    reg [`DDR_ROW_WIDTH-1:0]   mapped_row;
    reg [`DDR_COL_WIDTH-1:0]   mapped_col;
                               
    reg [`ADDR_WIDTH-1:0]      addr;
    reg [`DATA_WIDTH-1:0]      data;
    reg [`CMD_WIDTH:0]         op;
    reg [5:0]                  pin_id;
                               
    reg [`REG_ADDR_WIDTH-1:0]  cfg_a;
    reg [`REG_DATA_WIDTH-1:0]  cfg_d;
    reg [`REG_DATA_WIDTH-1:0]  cfg_q;
                               
    reg                        nop_rpt;
    reg [31:0]                 nop_cnt;
                               
    real                       op_time;

    begin

      // message header
      if (msg_type != `DATA_IN)
        begin
          op_time = $realtime;
          
          // DDR transactions are reported delayed - use actual time
          if (msg_grp == `CTRL_SDRAM)
            begin
              op_time = op_time - `DDR_MNT.rw_len*tCLK_PRD;
            end

          if (msg_type == `CTRL_NOP)
            begin
              if (msg_grp == `CTRL_SDRAM)
                begin
                  {nop_rpt, nop_cnt, rank} = parameters;
                end
              else
                begin
                  {nop_rpt, nop_cnt} = parameters;
                end
            end
          else
            begin
              nop_rpt = 1'b0;
            end
          
          if (msg_type != `CTRL_NOP || nop_rpt === 1'b0)
            begin
              // current time is the operation time
              `ifndef QUIET_MESSAGES   $write("-> %0t: ", op_time);
              `else
              if ( (msg_grp==`CHIP_CFG) || (msg_grp==`SYS_OP) )
              $write("-> %0t: ", op_time);
              `endif
            end
          else
            begin
              // belated reporting of NOPs
              `ifndef QUIET_MESSAGES $write("-> %0t: ", op_time - tCLK_PRD*nop_cnt);
              `else
              if ( (msg_grp==`CHIP_CFG) || (msg_grp==`SYS_OP) )
              $write("-> %0t: ", op_time - tCLK_PRD*nop_cnt);
              `endif
            end
        end

      // extract parameters and tag message prefix on some transactions
      case (msg_grp)
        `CHIP_CTRL:
          begin
            // transactions between chip and controller
            {d, dm, a} = parameters;
            {bank, row, col} = a;
            `ifndef QUIET_MESSAGES $write("[HOST 0] ");   
            `else $write("H");  `endif
          end
        `CHIP_CTRL_1:
          begin
            // transactions between chip and controller
            {d, dm, a} = parameters;
            {bank, row, col} = a;
            `ifndef QUIET_MESSAGES $write("[HOST 1] ");   
            // Removing this as it causes issues with regression post processing due
            // to the no newline character added to the `else $write().
            // `else $write("H");
            `endif
          end
        `CHIP_CFG:
          begin
            // transactions between chip and controller configuration
            {cfg_d, cfg_a} = parameters;
            $write("[CFG] ");
          end
        `CTRL_SDRAM:
          begin
            // transactions between controller and SDRAM
            {d, dm, addr, bank, rank} = parameters;
            {row, col} = addr;
            `ifndef QUIET_MESSAGES $write("[RANK %0d] ", rank);
            `else $write(""); /*$write("M");*/   `endif
          end
        `SYS_OP:
          begin
            // system transactions
            data = parameters;
            $write("[SYS] ");
          end
        `JTAG_CFG:
          begin
            // transaction between chip and JTAG bfm
           {cfg_d, cfg_a} = parameters;
            `ifndef QUIET_MESSAGES $write("[JTAG_CFG] ");   `endif
          end
        `CTRL_RDIMM:
          begin
            // RDIMM transactions
            a    = parameters[3:0];
            data = parameters[7:4];
            $write("[RDIMM] ");
          end
        default:
          begin
            data = parameters;
          end
      endcase // case(msg_grp)

      
      // messages
      case (msg_type)
      `ifndef QUIET_MESSAGES   
        // transactions between chip logic and controller
        `SELF_REFRESH:  $display("Self refresh");
        `REFRESH:       $display("Refresh");
        `PRECHARGE:     $display("Precharge bank %0d", bank);
        `PRECHARGE_ALL: $display("Precharge all banks");
        `ACTIVATE:      $display("Activate bank %0d, row %0d", bank, row);
        `ZQCAL_SHORT,
        `READ_MODE:begin
          if (`GRM.lpddr2_mode || `GRM.lpddr3_mode) begin
            $display("Read Mode");
          end else begin
            $display("ZQ calibration short");
          end
        end
        `ZQCAL_LONG,
        `TERMINATE:begin
           if (`GRM.lpddr2_mode || `GRM.lpddr3_mode) begin
             $display("Burst terminate");
           end else begin
             $display("ZQ calibration long");
           end
        end
        `DESELECT:      $display("Device deselect");
        `POWER_DOWN:
          begin
            if (addr[0] == 1'b1)
              $display("Precharge power down");
            else
              $display("Active power down");
          end
        `SDRAM_NOP:     $display("SDRAM NOP");
      `endif
      `ifndef QUIET_MESSAGES
        `SDRAM_WRITE,
        `WRITE_BRST,
        `WRITE_PRECHG,
        `WRITE_PRECHG_BRST:
          begin
            case (msg_type)
              `SDRAM_WRITE: $write("Write ");
              `WRITE_BRST:$write("      ");
              `WRITE_PRECHG:$write("Write w/AP ");
              `WRITE_PRECHG_BRST:$write("           ");
            endcase // case(msg_type)

            if (msg_grp == `CHIP_CTRL || msg_grp == `CHIP_CTRL_1)
              begin
                $write("MEM[%0d,%0d,%0d] <= %h", bank[`SDRAM_BANK_WIDTH-1:0], row, col, d);
              end
            else
              begin
                $write("MEM[%0d,%0d,%0d] <= %h", bank, row, col, 
                       d[2*`DWC_DATA_WIDTH-1:0]);
              end
            
            if (msg_grp == `CHIP_CTRL || msg_grp == `CHIP_CTRL_1)
              begin
                $display(", DM = %h", dm);
              end
            else
              begin
                $display(", DM = %h", dm[2*`DWC_NO_OF_BYTES*`DWC_DX_NO_OF_DQS-1:0]);
              end
          end     `endif

        `ifndef QUIET_MESSAGES 

        `SDRAM_READ:
          begin
            if (msg_grp == `CHIP_CTRL || msg_grp == `CHIP_CTRL_1)
              begin
                $display("Read  MEM[%0d,%0d,%0d]", bank[`SDRAM_BANK_WIDTH-1:0], row, col);
              end
            else
              begin
                if (`GRM.mpr_en)
                  $display("Read  MEM[MPR] => %h", d[2*`DWC_DATA_WIDTH-1:0]);
                else
                  $display("Read  MEM[%0d,%0d,%0d] => %h", bank, row, col,
                           d[2*`DWC_DATA_WIDTH-1:0]);
              end
          end
        `READ_BRST:
          begin
            if (msg_grp == `CHIP_CTRL || msg_grp == `CHIP_CTRL_1)
              begin
                $display("      MEM[%0d,%0d,%0d]", bank[`SDRAM_BANK_WIDTH-1:0], row, col);
              end
            else
              begin
                if (`GRM.mpr_en)
                  $display("      MEM[MPR] => %h", d[2*`DWC_DATA_WIDTH-1:0]);
                else
                  $display("      MEM[%0d,%0d,%0d] => %h", bank, row, col,
                           d[2*`DWC_DATA_WIDTH-1:0]);
              end
          end
        `READ_PRECHG:
          begin
            if (msg_grp == `CHIP_CTRL || msg_grp == `CHIP_CTRL_1)
              $display("Read w/AP MEM[%0d,%0d,%0d]", bank[`SDRAM_BANK_WIDTH-1:0], row, col);
            else
              $display("Read w/AP MEM[%0d,%0d,%0d] => %h", bank, row, col,
                       d[2*`DWC_DATA_WIDTH-1:0]);
          end
        `READ_PRECHG_BRST:
          begin
            if (msg_grp == `CHIP_CTRL || msg_grp == `CHIP_CTRL_1)
              $display("          MEM[%0d,%0d,%0d]", bank[`SDRAM_BANK_WIDTH-1:0], row, col);
            else
              $display("          MEM[%0d,%0d,%0d] => %h", bank, row, col,
                       d[2*`DWC_DATA_WIDTH-1:0]);
          end   `endif
        `DATA_OUT:
          begin
            if ((msg_grp == `CHIP_CFG) || (msg_grp == `JTAG_CFG))
              begin
                cfg_q = parameters;
                `ifndef QUIET_MESSAGES  $display("Data out: Q = %h", cfg_q); `endif
              end
            else
              begin
                q = parameters;
                `ifndef QUIET_MESSAGES  $display("Data out: Q = %h", q);   `endif
              end
          end
        `DATA_OUT_BRST:
          begin
            q = parameters;
            `ifndef QUIET_MESSAGES  $display("          Q = %h", q);  `endif
          end
        `CFG_REG_WRITE:
          begin
            $write("Write register ");
            print_register(cfg_a);
            $write(" <= %h\n", cfg_d);
          end
        `CFG_REG_READ:
          begin
            $write("Read register ");
            print_register(cfg_a);
            $write("\n");
          end
        `JTAG_REG_WRITE:
          begin
            $write("Write register ");
            print_register(cfg_a);
            $write(" <= %h\n", cfg_d);
          end
        `JTAG_REG_READ:
          begin
            $write("Read register ");
            print_register(cfg_a);
            $write("\n");
          end
        `RDIMM_REG_WRITE:
          begin
            $write("Write register RC%0d", a);
            $write(" <= %h\n", data[3:0]);
          end
        `LOAD_MODE:
          begin
            $write("Load mode register ");
            if (`GRM.lpddr2_mode || `GRM.lpddr3_mode) begin
              print_lpddrx_mode_register(msg_grp, addr, row, 1);
            end else begin
              case (bank)
                4'b0000: print_register(`MR0_REG);                                                              
                4'b0001: print_register(`MR1_REG);                                                              
                4'b0010: print_register(`MR2_REG);                                                              
                4'b0011: print_register(`MR3_REG);
                4'b0100: print_register(`MR4_REG);                                                              
                4'b0101: print_register(`MR5_REG);                                                              
                4'b0110: print_register(`MR6_REG);                                                              
                4'b0111: print_register(`MR7_REG);                                                              
              endcase                                     

              `ifndef QUIET_MESSAGES  
              if (msg_grp == `CTRL_SDRAM)
                $write(" <= %h\n", addr[`MR_DATA_WIDTH-1:0]);
              else
                $write(" <= %h\n", row);
              `endif
            end
          end
       `ifndef QUIET_MESSAGES
        `POWER_DWN_EXIT:  $display("Power down exit");
        `SELF_RFSH_EXIT:  $display("Self refresh exit");
        `SPECIAL_CMD:
          begin
            case (col[3:0])
              4'b1110: $display("Write RDIMM register RC%0d <= %h",
                                a[7:4], a[11:8]);
              4'b1111: $display("Exit power-down/self-refresh");
            endcase // case(col[2:0])
          end   `endif
`ifndef QUIET_MESSAGES 
        // miscellaneous transactions
        `CTRL_NOP:
          begin
            if (nop_cnt === 1)
              begin
                $display("NOP");
              end
            else
              begin
                $display("%0d NOPs", nop_cnt);
              end
          end
        `BAD_MEM_OP: $display("Illegal memory operation");
`endif        
        `SYS_RST,
        `SYS_TRST:
          begin
            if (msg_type == `SYS_RST)
              begin
                $write("SYSTEM RESET ");
              end
            else
              begin
                $write("CONFIGURATION RESET ");

              end
              
            if (data[0] === 1'b0)
              $display("ASSERTED");
            else if (data[0] === 1'b1)
              $display("DE-ASSERTED");
            else
              $display("DRIVEN TO INVALID VALUE (%b)", data[0]);
          end        
        `SYS_TRAIN_DONE: $display("PUB training is done");
        `SYS_WLDONE: $display("Write leveling done");
        `END_INIT: $display("END OF INITIALIZATION\n");
        `END_SIM:  $display("END OF SIMULATION");
`ifdef QUIET_MESSAGES
        `BAD_MEM_OP, `CTRL_NOP, `POWER_DWN_EXIT, `SELF_RFSH_EXIT, `SPECIAL_CMD,
        `READ_PRECHG_BRST, `READ_PRECHG, `READ_BRST, `SDRAM_READ,
        `WRITE_PRECHG_BRST, `WRITE_PRECHG, `WRITE_BRST, `SDRAM_WRITE,
        `SELF_REFRESH, `REFRESH, `PRECHARGE, `PRECHARGE_ALL, `ACTIVATE,
        `ZQCAL_SHORT, `ZQCAL_LONG, `DESELECT, `POWER_DOWN, `SDRAM_NOP,          
        `CTRL_PIN, `MISC_OP, `CHIP_FLAG, `CHIP_DIN, `CHIP_CMD  : begin end
`endif
        default:
          begin
            $write("Unknown operation at (msg_type=0x%0h [%0d])", msg_type, msg_type);
            op_time = $realtime;
            
            // DDR transactions are reported delayed - use actual time
            if (msg_grp == `CTRL_SDRAM)
              begin
                op_time = op_time - `DDR_MNT.rw_len*tCLK_PRD;
              end
  
            if (msg_type == `CTRL_NOP)
              begin
                if (msg_grp == `CTRL_SDRAM)
                  begin
                    {nop_rpt, nop_cnt, rank} = parameters;
                  end
                else
                  begin
                    {nop_rpt, nop_cnt} = parameters;
                  end
              end
            else
              begin
                nop_rpt = 1'b0;
              end

            if (msg_type != `CTRL_NOP || nop_rpt === 1'b0)
              begin
                // current time is the operation time
              `ifndef QUIET_MESSAGES   
                $display("-> %0t: ", op_time);
              `else
                if ( (msg_grp==`CHIP_CFG) || (msg_grp==`SYS_OP) )
                  $display("-> %0t: ", op_time);
              `endif
              end
            else
              begin
                // belated reporting of NOPs
             `ifndef QUIET_MESSAGES 
                $display("-> %0t: ", op_time - tCLK_PRD*nop_cnt);
             `else
                if ( (msg_grp==`CHIP_CFG) || (msg_grp==`SYS_OP) )
                  $display("-> %0t: ", op_time - tCLK_PRD*nop_cnt);
             `endif
              end
          end
      endcase // case(msg_type)
      
    end
  endtask // message


  // print register
  // --------------
  // prints the name of the register being accessed
  task print_register;
    input [`REG_ADDR_WIDTH-1:0] reg_addr;
    integer i;
    reg     unknown_reg;
    begin
      case (reg_addr)
         `RIDR     : $write("RIDR");
         `PIR      : $write("PIR");
`ifdef DWC_PUB_CLOCK_GATING
         `CGCR     : $write("CGCR");
`endif
         `CGCR1    : $write("CGCR1");
         `PGCR0    : $write("PGCR0");
         `PGCR1    : $write("PGCR1");
         `PGCR2    : $write("PGCR2");
         `PGCR3    : $write("PGCR3");
         `PGCR4    : $write("PGCR4");
         `PGCR5    : $write("PGCR5");
         `PGCR6    : $write("PGCR6");
         `PGCR7    : $write("PGCR7");
         `PGCR8    : $write("PGCR8");
         `PGSR0    : $write("PGSR0");
         `PGSR1    : $write("PGSR1");
`ifdef DWC_DDRPHY_PLL_TYPEB
         `PLLCR0   : $write("PLLCR0");
         `PLLCR1   : $write("PLLCR1");
         `PLLCR2   : $write("PLLCR2");
         `PLLCR3   : $write("PLLCR3");
         `PLLCR4   : $write("PLLCR4");
         `PLLCR5   : $write("PLLCR5");
`else
         `PLLCR    : $write("PLLCR");
`endif
         `PTR0     : $write("PTR0");
         `PTR1     : $write("PTR1");
         `PTR2     : $write("PTR2");
         `PTR3     : $write("PTR3");
         `PTR4     : $write("PTR4");
         `PTR5     : $write("PTR5");
         `PTR6     : $write("PTR6");
         `ACMDLR0  : $write("ACMDLR0");
         `ACMDLR1  : $write("ACMDLR1");
         `ACLCDLR  : $write("ACLCDLR");
         `ACBDLR0  : $write("ACBDLR0");
         `ACBDLR1  : $write("ACBDLR1");
         `ACBDLR2  : $write("ACBDLR2");
         `ACBDLR3  : $write("ACBDLR3");
         `ACBDLR4  : $write("ACBDLR4");
         `ACBDLR5  : $write("ACBDLR5");
         `ACBDLR6  : $write("ACBDLR6");
         `ACBDLR7  : $write("ACBDLR7");
         `ACBDLR8  : $write("ACBDLR8");
         `ACBDLR9  : $write("ACBDLR9");
         `ACBDLR10 : $write("ACBDLR10");	 
         `ACBDLR11 : $write("ACBDLR11");	 
         `ACBDLR12 : $write("ACBDLR12");	 
         `ACBDLR13 : $write("ACBDLR13");	 
         `ACBDLR14 : $write("ACBDLR14");	
         `RANKIDR  : $write("RANKIDR");
         `RIOCR0   : $write("RIOCR0");
         `RIOCR1   : $write("RIOCR1");
         `RIOCR2   : $write("RIOCR2");
         `RIOCR3   : $write("RIOCR3");
         `RIOCR4   : $write("RIOCR4");
         `RIOCR5   : $write("RIOCR5");
         `ACIOCR0  : $write("ACIOCR0");
         `ACIOCR1  : $write("ACIOCR1");
         `ACIOCR2  : $write("ACIOCR2");
         `ACIOCR3  : $write("ACIOCR3");
         `ACIOCR4  : $write("ACIOCR4");
         `ACIOCR5  : $write("ACIOCR5");
         `DXCCR    : $write("DXCCR");
         `DSGCR    : $write("DSGCR");
         `DCR      : $write("DCR");
         `DTPR0    : $write("DTPR0");
         `DTPR1    : $write("DTPR1");
         `DTPR2    : $write("DTPR2");
         `DTPR3    : $write("DTPR3");
         `DTPR4    : $write("DTPR4");
         `DTPR5    : $write("DTPR5");
         `DTPR6    : $write("DTPR6");
         `SCHCR0   : $write("SCHCR0");
         `SCHCR1   : $write("SCHCR1");
         `MR0_REG  : $write("MR0");
         `MR1_REG  : $write("MR1");
         `MR2_REG  : $write("MR2");
         `MR3_REG  : $write("MR3");
         `MR4_REG  : $write("MR4");
         `MR5_REG  : $write("MR5");
         `MR6_REG  : $write("MR6");
         `MR7_REG  : $write("MR7");
         `MR11_REG : $write("MR11");
         `ODTCR    : $write("ODTCR");
         `DTCR0     : $write("DTCR0");
         `DTCR1    : $write("DTCR1");
         `DTAR0    : $write("DTAR0");
         `DTAR1    : $write("DTAR1");
         `DTAR2    : $write("DTAR2");
         `DTDR0    : $write("DTDR0");
         `DTDR1    : $write("DTDR1");
         `UDDR0    : $write("UDDR0");
         `UDDR1    : $write("UDDR1");
         `DTEDR0   : $write("DTEDR0");
         `DTEDR1   : $write("DTEDR1");
         `DTEDR2   : $write("DTEDR2");
         `VTDR     : $write("VTDR");
                   
         `RDIMMGCR0: $write("RDIMMGCR0");
         `RDIMMGCR1: $write("RDIMMGCR1");
         `RDIMMGCR2: $write("RDIMMGCR2");
         `RDIMMCR0 : $write("RDIMMCR0");
         `RDIMMCR1 : $write("RDIMMCR1");
         `RDIMMCR2 : $write("RDIMMCR2");
         `RDIMMCR3 : $write("RDIMMCR3");
         `RDIMMCR4 : $write("RDIMMCR4");

         `DCUAR    : $write("DCUAR");
         `DCUDR    : $write("DCUDR");
         `DCURR    : $write("DCURR");
         `DCULR    : $write("DCULR");
         `DCUGCR   : $write("DCUGCR");
         `DCUTPR   : $write("DCUTPR");
         `DCUSR0   : $write("DCUSR0");
         `DCUSR1   : $write("DCUSR1");
                               
         `BISTRR   : $write("BISTRR");
         `BISTMSKR0: $write("BISTMSKR0");
         `BISTMSKR1: $write("BISTMSKR1");
         `BISTMSKR2: $write("BISTMSKR2");
         `BISTWCR  : $write("BISTWCR");
         `BISTLSR  : $write("BISTLSR");
         `BISTAR0  : $write("BISTAR0");
         `BISTAR1  : $write("BISTAR1");
         `BISTAR2  : $write("BISTAR2");
         `BISTAR3  : $write("BISTAR3");
         `BISTAR4  : $write("BISTAR4");
         `BISTUDPR : $write("BISTUDPR");
         `BISTGSR  : $write("BISTGSR");
         `BISTWER0 : $write("BISTWER0");
         `BISTWER1 : $write("BISTWER1");
         `BISTBER0 : $write("BISTBER0");
         `BISTBER1 : $write("BISTBER1");
         `BISTBER2 : $write("BISTBER2");
         `BISTBER3 : $write("BISTBER3");
         `BISTBER4 : $write("BISTBER4");
         `BISTBER5 : $write("BISTBER5");
         `BISTWCSR : $write("BISTWCSR");
         `BISTFWR0 : $write("BISTFWR0");
         `BISTFWR1 : $write("BISTFWR1");
         `BISTFWR2 : $write("BISTFWR2");
         `IOVCR0   : $write("IOVCR0");
         `IOVCR1   : $write("IOVCR1");
         `VTCR0    : $write("VTCR0");
         `VTCR1    : $write("VTCR1");
         `GPR0     : $write("GPR0");
         `GPR1     : $write("GPR1");
         `CATR0    : $write("CATR0");
         `CATR1    : $write("CATR1");
         `DQSDR0   : $write("DQSDR0");
         `DQSDR1   : $write("DQSDR1");
         `DQSDR2   : $write("DQSDR2");
         `ZQCR     : $write("ZQCR");
         `ZQ0PR    : $write("ZQ0PR");
         `ZQ0DR    : $write("ZQ0DR");
         `ZQ0SR    : $write("ZQ0SR");
         `ZQ1PR    : $write("ZQ1PR");
         `ZQ1DR    : $write("ZQ1DR");
         `ZQ1SR    : $write("ZQ1SR");
         `ZQ2PR    : $write("ZQ2PR");
         `ZQ2DR    : $write("ZQ2DR");
         `ZQ2SR    : $write("ZQ2SR");
         `ZQ3PR    : $write("ZQ3PR");
         `ZQ3DR    : $write("ZQ3DR");
         `ZQ3SR    : $write("ZQ3SR");
         `AACR     : $write("AACR");
         `VTCR1    : $write("VTCR1");
        default:
          begin
            // DATX8 registers
            unknown_reg = 1'b1;
            for (i=0; i<9; i=i+1)
              begin
                if (reg_addr == (`DX0GCR0    + `DX_REG_RANGE*i))
                  begin
                    unknown_reg = 1'b0;
                    $write("DX%0dGCR0", i);
                  end
                if (reg_addr == (`DX0GCR1    + `DX_REG_RANGE*i))
                  begin
                    unknown_reg = 1'b0;
                    $write("DX%0dGCR1", i);
                  end
                if (reg_addr == (`DX0GCR2    + `DX_REG_RANGE*i))
                  begin
                    unknown_reg = 1'b0;
                    $write("DX%0dGCR2", i);
                  end
                if (reg_addr == (`DX0GCR3    + `DX_REG_RANGE*i))
                  begin
                    unknown_reg = 1'b0;
                    $write("DX%0dGCR3", i);
                  end
                if (reg_addr == (`DX0GCR4    + `DX_REG_RANGE*i))
                  begin
                    unknown_reg = 1'b0;
                    $write("DX%0dGCR4", i);
                  end
                if (reg_addr == (`DX0GCR5    + `DX_REG_RANGE*i))
                  begin
                    unknown_reg = 1'b0;
                    $write("DX%0dGCR5", i);
                  end
                if (reg_addr == (`DX0GCR6    + `DX_REG_RANGE*i))
                  begin
                    unknown_reg = 1'b0;
                    $write("DX%0dGCR6", i);
                  end
                if (reg_addr == (`DX0GCR7    + `DX_REG_RANGE*i))
                  begin
                    unknown_reg = 1'b0;
                    $write("DX%0dGCR7", i);
                  end

                if (reg_addr == (`DX0GCR8    + `DX_REG_RANGE*i))
                  begin
                    unknown_reg = 1'b0;
                    $write("DX%0dGCR8", i);
                  end

                if (reg_addr == (`DX0GCR9    + `DX_REG_RANGE*i))
                  begin
                    unknown_reg = 1'b0;
                    $write("DX%0dGCR9", i);
                  end

                if (reg_addr == (`DX0GSR0  + `DX_REG_RANGE*i))
                  begin
                    unknown_reg = 1'b0;
                    $write("DX%0dGSR0", i);
                  end
                if (reg_addr == (`DX0GSR1  + `DX_REG_RANGE*i))
                  begin
                    unknown_reg = 1'b0;
                    $write("DX%0dGSR1", i);
                  end
                if (reg_addr == (`DX0GSR2  + `DX_REG_RANGE*i))
                  begin
                    unknown_reg = 1'b0;
                    $write("DX%0dGSR2", i);
                  end
                if (reg_addr == (`DX0GSR3  + `DX_REG_RANGE*i))
                  begin
                    unknown_reg = 1'b0;
                    $write("DX%0dGSR3", i);
                  end
                if (reg_addr == (`DX0GSR4  + `DX_REG_RANGE*i))
                  begin
                    unknown_reg = 1'b0;
                    $write("DX%0dGSR4", i);
                  end
                if (reg_addr == (`DX0GSR5  + `DX_REG_RANGE*i))
                  begin
                    unknown_reg = 1'b0;
                    $write("DX%0dGSR5", i);
                  end
                if (reg_addr == (`DX0GSR6  + `DX_REG_RANGE*i))
                  begin
                    unknown_reg = 1'b0;
                    $write("DX%0dGSR6", i);
                  end
                if (reg_addr == (`DX0RSR0  + `DX_REG_RANGE*i))
                  begin
                    unknown_reg = 1'b0;
                    $write("DX%0dRSR0", i);
                  end
                if (reg_addr == (`DX0RSR1  + `DX_REG_RANGE*i))
                  begin
                    unknown_reg = 1'b0;
                    $write("DX%0dRSR1", i);
                  end
                 if (reg_addr == (`DX0RSR2  + `DX_REG_RANGE*i))
                  begin
                    unknown_reg = 1'b0;
                    $write("DX%0dRSR2", i);
                  end
                 if (reg_addr == (`DX0RSR3  + `DX_REG_RANGE*i))
                  begin
                    unknown_reg = 1'b0;
                    $write("DX%0dRSR3", i);
                  end
                 if (reg_addr == (`DX0BDLR0  + `DX_REG_RANGE*i))
                  begin
                    unknown_reg = 1'b0;
                    $write("DX%0dBDLR0", i);
                  end
                if (reg_addr == (`DX0BDLR1  + `DX_REG_RANGE*i))
                  begin
                    unknown_reg = 1'b0;
                    $write("DX%0dBDLR1", i);
                  end
                if (reg_addr == (`DX0BDLR2  + `DX_REG_RANGE*i))
                  begin
                    unknown_reg = 1'b0;
                    $write("DX%0dBDLR2", i);
                  end
                if (reg_addr == (`DX0BDLR3  + `DX_REG_RANGE*i))
                  begin
                    unknown_reg = 1'b0;
                     $write("DX%0dBDLR3", i);
                  end
                if (reg_addr == (`DX0BDLR4  + `DX_REG_RANGE*i))
                  begin
                    unknown_reg = 1'b0;
                    $write("DX%0dBDLR4", i);
                  end
                if (reg_addr == (`DX0BDLR5  + `DX_REG_RANGE*i))
                  begin
                    unknown_reg = 1'b0;
                    $write("DX%0dBDLR5", i);
                  end
                if (reg_addr == (`DX0BDLR6  + `DX_REG_RANGE*i))
                  begin
                    unknown_reg = 1'b0;
                    $write("DX%0dBDLR6", i);
                  end
                if (reg_addr == (`DX0BDLR7  + `DX_REG_RANGE*i))
                  begin
                    unknown_reg = 1'b0;
                    $write("DX%0dBDLR7", i);
                  end
                if (reg_addr == (`DX0BDLR8  + `DX_REG_RANGE*i))
                  begin
                    unknown_reg = 1'b0;
                    $write("DX%0dBDLR8", i);
                  end
                if (reg_addr == (`DX0BDLR9  + `DX_REG_RANGE*i))
                  begin
                    unknown_reg = 1'b0;
                    $write("DX%0dBDLR9", i);
                  end
                if (reg_addr == (`DX0LCDLR0 + `DX_REG_RANGE*i))
                  begin
                    unknown_reg = 1'b0;
                    $write("DX%0dLCDLR0", i);
                  end
                if (reg_addr == (`DX0LCDLR1 + `DX_REG_RANGE*i))
                  begin
                    unknown_reg = 1'b0;
                    $write("DX%0dLCDLR1", i);
                  end
                if (reg_addr == (`DX0LCDLR2 + `DX_REG_RANGE*i))
                  begin
                    unknown_reg = 1'b0;
                    $write("DX%0dLCDLR2", i);
                  end
                if (reg_addr == (`DX0LCDLR3 + `DX_REG_RANGE*i))
                  begin
                    unknown_reg = 1'b0;
                    $write("DX%0dLCDLR3", i);
                  end
                if (reg_addr == (`DX0LCDLR4 + `DX_REG_RANGE*i))
                  begin
                    unknown_reg = 1'b0;
                    $write("DX%0dLCDLR4", i);
                  end
                if (reg_addr == (`DX0LCDLR5 + `DX_REG_RANGE*i))
                  begin
                    unknown_reg = 1'b0;
                    $write("DX%0dLCDLR5", i);
                  end
                if (reg_addr == (`DX0MDLR0 + `DX_REG_RANGE*i))
                  begin
                    unknown_reg = 1'b0;
                    $write("DX%0dMDLR0", i);
                  end
                if (reg_addr == (`DX0MDLR1 + `DX_REG_RANGE*i))
                  begin
                    unknown_reg = 1'b0;
                    $write("DX%0dMDLR1", i);
                  end
                if (reg_addr == (`DX0GTR0 + `DX_REG_RANGE*i))
                  begin
                    unknown_reg = 1'b0;
                    $write("DX%0dGTR0", i);
                  end
              end // for (i=0; i<`DWC_NO_OF_BYTES; i=i+1)

            if (unknown_reg)
              begin
                $write("%0d", reg_addr);
                if (!xpct_illegal)
                  begin
                    $write("\n");
                    error_message(`SYS_OP, `UNKNOWN_REG, 0);
                  end
              end
          end
      endcase // case(reg_addr)
    end
  endtask // print_register
  
  // prints the name of the controller (dummy) register being accessed
  task print_controller_register;
    input [`REG_ADDR_WIDTH-1:0] reg_addr;
    begin
      case (reg_addr)
        `CDCR:    $write("CDCR");
        `DRR:     $write("DRR");
        `RSLR0:   $write("RSLR0");
        `RSLR1:   $write("RSLR1");
        `RSLR2:   $write("RSLR2");
        `RSLR3:   $write("RSLR3");
        `RDGR0:   $write("RDGR0");
        `RDGR1:   $write("RDGR1");
        `RDGR2:   $write("RDGR2");
        `RDGR3:   $write("RDGR3");
        default:
          begin
            $write("%0d", reg_addr);
            if (!xpct_illegal)
              begin
                $write("\n");
                error_message(`SYS_OP, `UNKNOWN_REG, 0);
              end
          end
      endcase // case(reg_addr)
    end
  endtask // print_controller_register


  // prints LPDDRX mode register
  task print_lpddrx_mode_register;
    input [2:0]                  msg_grp;
    input [`ADDR_WIDTH-1:0]      addr;
    input [`SDRAM_ROW_WIDTH-1:0] row;
    input                        mr_write;
    begin
      $write ("MR%0d", addr[7:0]);
      if (mr_write) begin
        if (msg_grp == `CTRL_SDRAM)
          $write(" <= %h", addr[15:8]);
        else
          $write(" <= %h", row);

        case (addr[7:0])
          8'h0A: begin
            case (addr[15:8])
              8'hFF:  $write(" (ZQ Calibration after initialization)");
              8'hAB:  $write(" (ZQ calibration long)");
              8'h56:  $write(" (ZQ calibration short)");
              8'hC3:  $write(" (ZQ reset)");
            endcase
          end
          8'h3F: $write(" (Reset)");
        endcase
      end
      $write("\n");
    end
  endtask // print_lpddrx_mode_register


  // print pin name
  // --------------
  // prints the name of a pin
  task print_pin_name;
    input [5:0] pin_id;
    begin
      $write("Pin ");
      case (pin_id)
        `CK_PIN   : $write("CK");
        `CKb_PIN  : $write("CKb");
        `CKE_PIN  : $write("CKE");
        `ODT_PIN  : $write("ODT");
        `CSb_PIN  : $write("CSb");
        `RASb_PIN : $write("RASb");
        `CASb_PIN : $write("CASb");
        `WEb_PIN  : $write("WEb");
        `BA_PIN   : $write("BA");
        `A_PIN    : $write("A");
        `DM_PIN   : $write("DM");
        `DQS_PIN  : $write("DQS");
        `DQSb_PIN : $write("DQSb");
        `DQ_PIN   : $write("DQ");
        
        `RQVLD_PIN: $write("RQVLD");
        `CMD_PIN  : $write("CMD");
        `RWBA_PIN : $write("RWBA");
        `RWA_PIN  : $write("RWA");
        `D_PIN    : $write("D");
        `RQACK_PIN: $write("RQACK");
        `QVLD_PIN : $write("QVLD");
        `Q_PIN    : $write("Q");
        `TAG_PIN  : $write("TAG");
        `QTAG_PIN : $write("QTAG");
        `WTAG_PIN : $write("WTAG");

        `JTAG_RQVLD_PIN: $write("JTAG_RQVLD");
        `JTAG_CMD_PIN  : $write("JTAG_CMD");
        `JTAG_D_PIN    : $write("JTAG_D");
        `JTAG_A_PIN    : $write("JTAG_A");
        `JTAG_QVLD_PIN : $write("JTAG_QVLD");
        `JTAG_Q_PIN    : $write("JTAG_Q");

      endcase // case(pin_id)
    end
  endtask // print_pin_name

  // JTAG pin enable/disable 
  // --------------------
  // Enables alternate pinout 
  task enable_test_pinout;
    begin
      jtag_en = 1'b1;
    end
   endtask  // enable_test_pinout

  task disable_test_pinout;
    begin
      jtag_en = 1'b0;
    end
   endtask  // enable_test_pinout

  // Control whether reset is executed as part of power-up or not
  // ------------------------------------------------------------
  task enable_reset_in_power_up;
    begin
      reset_in_power_up = 1'b1;
    end
   endtask

  task disble_reset_in_power_up;
    begin
      reset_in_power_up = 1'b0;
    end
   endtask


  //---------------------------------------------------------------------------
  // Configuration Reports
  //---------------------------------------------------------------------------
  // report SDRAM configuration (including a few key timing parameters)
  task report_sdram_configuration;
    integer j;
    begin
      $display("");
      $display("=====================================================================");
      case (`GRM.ddr_mode)
        `LPDDR2_MODE:begin
          $display("  BL  CL  WL  AL  WR  tRP  tRCD  tRC  tRAS  tRRD  tWTR  tRTP  tRFC  ");
        end
        `LPDDR3_MODE:begin
          $display("  BL  CL  WL  AL  WR  tRP  tRCD  tRC  tRAS  tRRD  tWTR  tRTP  tRFC  ");
        end
        `DDR3_MODE:begin
          $display("  BL  CL  CWL  AL  WR  tRP  tRCD  tRC  tRAS  tRRD  tWTR  tRTP  tRFC  ");
        end
        `DDR2_MODE:begin
          $display("  BL  CL  WL  AL  WR  tRP  tRCD  tRC  tRAS  tRRD  tWTR  tRTP  tRFC  ");
        end
        `DDR4_MODE:begin
          $display("  BL  CL  CWL  AL  WR  tRP  tRCD  tRC  tRAS  tRRD  tWTR  tRTP  tRFC  ");
        end
        default:begin
          `SYS.error;
          $display("ERROR: Unknown ddr_mode");
        end
      endcase
      $display("=====================================================================");

      for (j=0; j<13; j=j+1)
        begin
          $write("  ");
          case (`GRM.ddr_mode)
            `LPDDR2_MODE,`DDR4_MODE,`DDR3_MODE,`DDR2_MODE,`LPDDR3_MODE:begin
              case (j)
                0:
                  begin
                    if (`GRM.ddr3_blotf) 
                      $write("V ");
                    else
                      print_number(`GRM.t_bl,       2); // BL
                  end
                1:  print_number(`GRM.t_cl,         2); // CL
                2:  print_number(`GRM.t_cwl,        3); // CWL
                3:  print_number(`GRM.t_al,         2); // AL
                4:  print_number(`GRM.t_wr,         2); // WR
                5:  print_number(`GRM.t_rp,         3); // tRP
                6:  print_number(`GRM.t_rcd,        4); // tRCD
                7:  print_number(`GRM.t_rc,         3); // tRC
                8:  print_number(`GRM.t_ras,        4); // tRAS
                9:  print_number(`GRM.t_rrd,        4); // tRRD
                10: print_number(`GRM.t_wtr,        4); // tWTR
                11: print_number(`GRM.t_rtp,        4); // tRTP
                12: print_number(`GRM.t_rfc,        4); // tRFC
              endcase // case(j)
            end
            default: begin
              `SYS.error;
              $display("ERROR: Unknown ddr_mode");
            end
          endcase
          if (j == 12) $write("\n");
        end
      $display("---------------------------------------------------------------------");
      $display("");
      `FCOV.set_cov_cl_nrcd_nrp(`GRM.t_cl,`GRM.dtpr0[15:12],`GRM.dtpr0[11:8]);       
    end
  endtask // report_sdram_configuration


  // report Address/Command Pin Mapping
  task report_add_cmd_pin_mapping;
    begin   
      $display("Address/Command Pin Mapping (CS_N, ODT, CKE and CID)");   
      $display("=========================================================");
      case (`DWC_RCD_MODE)                                                           
        0: $display("DWC_RCD_MODE         = %d -> No RCD Mode", `DWC_RCD_MODE);            
        1: $display("DWC_RCD_MODE         = %d -> Direct DualCS Mode", `DWC_RCD_MODE);     
        2: $display("DWC_RCD_MODE         = %d -> Direct QuadCS Mode", `DWC_RCD_MODE);     
        3: $display("DWC_RCD_MODE         = %d -> Encoded QuadCS Mode", `DWC_RCD_MODE);    
      endcase 
      $display("DWC_NO_OF_RCD        = %d", `DWC_NO_OF_RCD);  
      $display("DWC_NO_OF_3DS_STACKS = %d", `NUM_3DS_STACKS);   
      $display("DWC_NO_OF_RANKS      = %d", `DWC_NO_OF_RANKS);   
      $display("DWC_NO_OF_LRANKS     = %d", `DWC_NO_OF_LRANKS); 
      $display("DWC_RCD_CS_N_WIDTH   = %d", `DWC_RCD_CS_N_WIDTH);
      $display("DWC_RCD_ODT_WIDTH    = %d", `DWC_RCD_ODT_WIDTH);
      $display("DWC_RCD_CKE_WIDTH    = %d", `DWC_RCD_CKE_WIDTH);
      $display("DWC_CID_WIDTH        = %d", `DWC_CID_WIDTH);      
      `ifdef DWC_DDRPHY_ACX48 
        $display("ACx48"); 
      `else 
        $display("ACPHY");
      `endif                                                                     
      $display("=========================================================");
      $display("CS_N");
      $display("DWC_AC_CS_N0_PNUM    = %d", `DWC_AC_CS_N0_PNUM);
      $display("DWC_AC_CS_N1_PNUM    = %d", `DWC_AC_CS_N1_PNUM);
      $display("DWC_AC_CS_N2_PNUM    = %d", `DWC_AC_CS_N2_PNUM);
      $display("DWC_AC_CS_N3_PNUM    = %d", `DWC_AC_CS_N3_PNUM);
      $display("DWC_AC_CS_N4_PNUM    = %d", `DWC_AC_CS_N4_PNUM);
      $display("DWC_AC_CS_N5_PNUM    = %d", `DWC_AC_CS_N5_PNUM);
      $display("DWC_AC_CS_N6_PNUM    = %d", `DWC_AC_CS_N6_PNUM);
      $display("DWC_AC_CS_N7_PNUM    = %d", `DWC_AC_CS_N7_PNUM);
      $display("DWC_AC_CS_N8_PNUM    = %d", `DWC_AC_CS_N8_PNUM);
      $display("DWC_AC_CS_N9_PNUM    = %d", `DWC_AC_CS_N9_PNUM);
      $display("DWC_AC_CS_N10_PNUM   = %d", `DWC_AC_CS_N10_PNUM);
      $display("DWC_AC_CS_N11_PNUM   = %d", `DWC_AC_CS_N11_PNUM);
      $display("---------------------------------------------");      
      $display("ODT");
      $display("DWC_AC_ODT0_PNUM     = %d", `DWC_AC_ODT0_PNUM);
      $display("DWC_AC_ODT1_PNUM     = %d", `DWC_AC_ODT1_PNUM);
      $display("DWC_AC_ODT2_PNUM     = %d", `DWC_AC_ODT2_PNUM);
      $display("DWC_AC_ODT3_PNUM     = %d", `DWC_AC_ODT3_PNUM);
      $display("DWC_AC_ODT4_PNUM     = %d", `DWC_AC_ODT4_PNUM);
      $display("DWC_AC_ODT5_PNUM     = %d", `DWC_AC_ODT5_PNUM);
      $display("DWC_AC_ODT6_PNUM     = %d", `DWC_AC_ODT6_PNUM);
      $display("DWC_AC_ODT7_PNUM     = %d", `DWC_AC_ODT7_PNUM);
      $display("---------------------------------------------");      
      $display("CKE");
      $display("DWC_AC_CKE0_PNUM     = %d", `DWC_AC_CKE0_PNUM);
      $display("DWC_AC_CKE1_PNUM     = %d", `DWC_AC_CKE1_PNUM);
      $display("DWC_AC_CKE2_PNUM     = %d", `DWC_AC_CKE2_PNUM);
      $display("DWC_AC_CKE3_PNUM     = %d", `DWC_AC_CKE3_PNUM);
      $display("DWC_AC_CKE4_PNUM     = %d", `DWC_AC_CKE4_PNUM);
      $display("DWC_AC_CKE5_PNUM     = %d", `DWC_AC_CKE5_PNUM);
      $display("DWC_AC_CKE6_PNUM     = %d", `DWC_AC_CKE6_PNUM);
      $display("DWC_AC_CKE7_PNUM     = %d", `DWC_AC_CKE7_PNUM);
      $display("---------------------------------------------");      
      $display("CID");
      $display("DWC_AC_CID0_PNUM     = %d", `DWC_AC_CID0_PNUM);
      $display("DWC_AC_CID1_PNUM     = %d", `DWC_AC_CID1_PNUM);
      $display("DWC_AC_CID2_PNUM     = %d", `DWC_AC_CID2_PNUM);
      $display("=============================================");
      $display("");   
      $display("");  
    end
  endtask // report_add_cmd_pin_mapping

  
  // print tb environment setup
  task report_environment_configuration;
   begin

      $display("");
      $display("");
      $display("=====================================================================");
      $display("HDR_MODE        = %0d",   `GRM.hdr_mode);  
      $display("RR_MODE         = %0d",   `GRM.rr_mode);  
      $display("NUM_PHYS_RANKS  = %0d",   pNO_OF_PRANKS);
      $display("NUM_LOG_RANKS   = %0d",   pNO_OF_LRANKS);
      $display("PHY_WIDTH       = %0d",   `DWC_NO_OF_BYTES);
      $display("TCK_PERIOD      = %f ns", tCLK_PRD);
      $display("DDR2_MODE       = %0d",   ddr2_mode); 
      $display("SEED            = %0d",   seed);
      $display("CLK_PRD         = %f ns", `CLK_PRD);
      $display("CLK_NX          = %0d",   `CLK_NX);
      $display("=====================================================================");
      $display("");
    end 
  endtask // report_environment_configuration

  
  // prints a number in the specified field
  task print_number;
    input [31:0] val;
    input [31:0] field_width;

    integer left_spaces;
    integer right_spaces;
    integer total_spaces;
    integer i;
    begin
      if      (val < 10)    total_spaces = field_width - 1; // 0 t0 9
      else if (val < 100)   total_spaces = field_width - 2; // 10 to 99
      else if (val < 1000)  total_spaces = field_width - 3; // 100 to 999
      else if (val < 10000) total_spaces = field_width - 4; // 1000 to 9999
      else                  total_spaces = field_width - 5; // 10000 to 99999

      left_spaces  = total_spaces/2;
      right_spaces = total_spaces - left_spaces;

      for (i=0; i<left_spaces; i=i+1) $write(" ");
      $write("%0d", val);
      for (i=0; i<right_spaces; i=i+1) $write(" ");
    end
  endtask // print_number


  //---------------------------------------------------------------------------
  // DCU Command Unit (DCU) Status Reports
  //---------------------------------------------------------------------------
  task report_dcu_status;
    begin
      report_dcu_caches;

      // read status DCU registers
      $display("=> Reading DCU status registers ...\n");
      `CFG.read_register(`DCUSR0);
      if (dcu_skip_dcusr1_chk) begin
        $display("-> %t: [SYS] NOTE Skipping read/check of DCUSR1", $realtime);
        dcu_skip_dcusr1_chk = 1;     // Check/read register next time
      end
      else 
        `CFG.read_register(`DCUSR1);
    end
  endtask // report_dcu_status

  // reports the values in the DCU caches, both actual (inside the design) and
  // expected (inside the GRM)
  task report_dcu_caches;
    reg [1                  :0] cache_sel;
    reg [4                  :0] cache_depth;
    reg [8                  :0] cache_width;
    reg [3                  :0] cache_slices;
    integer word_addr;
    begin
      // read all the caches
      for (cache_sel=`DCU_CCACHE; cache_sel<=`DCU_RCACHE; cache_sel=cache_sel+1) begin
        read_dcu_cache(cache_sel);
      end

      // report the contents of the DCU caches + expected values
      $display("\n\n     *** DCU Caches (xCACHE[Address] = Actual Data   Expected Data) ***\n");

      for (cache_sel=`DCU_CCACHE; cache_sel<=`DCU_RCACHE; cache_sel=cache_sel+1) begin
        // get cache design parameters
        `GRM.get_cache_parameters(cache_sel, cache_depth, cache_width, cache_slices);
        
        for (word_addr=0; word_addr<cache_depth; word_addr=word_addr+1) begin
          case (cache_sel)
            `DCU_CCACHE: $write("   CCACHE");
            `DCU_ECACHE: $write("   ECACHE");
            `DCU_RCACHE: $write("   RCACHE");
          endcase // case (cache_sel)             

          if (word_addr < 10) begin
            $write("[ %0d]  =  ", word_addr);
          end else begin
            $write("[%0d]  =  ", word_addr);
          end
          case (cache_sel)
            `DCU_CCACHE: $display("%h   %h", ccache[word_addr], `GRM.ccache[word_addr]);
            `DCU_ECACHE: $display("%h   %h", ecache[word_addr], `GRM.ecache[word_addr]);
            `DCU_RCACHE: $display("%h   %h", rcache[word_addr], `GRM.rcache[word_addr]);
          endcase // case (cache_sel)
        end
       // print the actual expected data words
        if (cache_sel == `DCU_ECACHE) begin
          for (word_addr=0; word_addr<16; word_addr=word_addr+1) begin
            if (word_addr < 10) begin
              $write("   ECACHE[ %0d]  =  `h", word_addr);
            end else begin
              $write("   ECACHE[%0d]  =  `h", word_addr);
            end
            $write("%h   %h", ecache[0][word_addr*`PUB_DATA_TYPE_WIDTH +: `PUB_DATA_TYPE_WIDTH], 
                         `GRM.ecache[0][word_addr*`PUB_DATA_TYPE_WIDTH +: `PUB_DATA_TYPE_WIDTH]);
             case (`GRM.ecache[0][word_addr*`PUB_DATA_TYPE_WIDTH +: `PUB_DATA_TYPE_WIDTH])
              `PUB_DATA_0000_0000   : $display("  =>  0000_0000   ");
              `PUB_DATA_FFFF_FFFF   : $display("  =>  FFFF_FFFF   ");
              `PUB_DATA_5555_5555   : $display("  =>  5555_5555   ");
              `PUB_DATA_AAAA_AAAA   : $display("  =>  AAAA_AAAA   ");
              `PUB_DATA_0000_5500   : $display("  =>  0000_5500   ");
              `PUB_DATA_5555_0055   : $display("  =>  5555_0055   ");
              `PUB_DATA_0000_AA00   : $display("  =>  0000_AA00   ");
              `PUB_DATA_AAAA_00AA   : $display("  =>  AAAA_00AA   ");
              `PUB_DATA_DTDR0       : $display("  =>  DTDR0       ");
              `PUB_DATA_DTDR1       : $display("  =>  DTDR1       ");
              `PUB_DATA_UDDR0       : $display("  =>  UDDR0       ");
              `PUB_DATA_UDDR1       : $display("  =>  UDDR1       ");
              `PUB_DATA_WALKING_1   : $display("  =>  WALKING_1   ");
              `PUB_DATA_WALKING_0   : $display("  =>  WALKING_0   ");
              `PUB_DATA_USER_PATTERN: $display("  =>  USER_PATTERN");
              `PUB_DATA_LFSR        : $display("  =>  LFSR        ");
              `PUB_DATA_SCHCR0      : $display("  =>  SCHCR0      ");
              `PUB_DATA_FF00_FF00   : $display("  =>  FF00_FF00   ");
              `PUB_DATA_FFFF_0000   : $display("  =>  FFFF_0000   ");
              `PUB_DATA_0000_FF00   : $display("  =>  0000_FF00   ");
              `PUB_DATA_FFFF_00FF   : $display("  =>  FFFF_00FF   ");
              `PUB_DATA_00FF_00FF   : $display("  =>  00FF_00FF   ");
              `PUB_DATA_F0F0_F0F0   : $display("  =>  F0F0_F0F0   ");
              `PUB_DATA_0F0F_0F0F   : $display("  =>  0F0F_0F0F   ");
`ifdef DWC_DDRPHY_EMUL_XILINX
              `PUB_DATA_AA55EE11   : $display("  =>  AA55EE1X EMUL PATTERN   ");
`endif
              default               : $display("  =>  0000_0000   ");
            endcase // case (i_data_gen_type)
          end                      
        end  
        $display("\n");
      end // for (cache_sel=`DCU_CCACHE; cache_sel<=`DCU_RCACHE; cache_sel=cache_sel+1)
    end
  endtask // report_dcu_caches
  
  // reads all the contents of DCU cache
  task read_dcu_cache;
    input [1:0] cache_sel;

    reg [4                  :0] cache_depth;
    reg [8                  :0] cache_width;
    reg [3                  :0] cache_slices;
    reg [`CFG_DATA_WIDTH  -1:0] reg_data;
    reg [512              -1:0] cache_word;
    integer word_addr;
    integer slice_addr;
    integer slice_start_bit;
    integer slice_end_bit;
    integer bit_no;
    begin
      case (cache_sel)
        `DCU_CCACHE: $display("\n=> Reading DCU command cache ...\n");
        `DCU_ECACHE: $display("\n=> Reading DCU expected data cache ...\n");
        `DCU_RCACHE: $display("\n=> Reading DCU read data cache ...\n");
      endcase // case (cache_sel)
      
      // get cache design parameters
      `GRM.get_cache_parameters(cache_sel, cache_depth, cache_width, cache_slices);
      
      // load DCUAR to set up read from selected cache
      `GRM.dcuar      = {32{1'b0}};
      `GRM.dcuar[9:8] = cache_sel; // cache select
      `GRM.dcuar[10]  = 1'b1;      // increment address
      `GRM.dcuar[11]  = 1'b1;      // read access
      `CFG.write_register(`DCUAR, `GRM.dcuar);
      `FCOV_REG.set_cov_registers_write(`DCUAR,`GRM.dcuar,`VALUE_REGISTER_DATA);           
      
      // Allow DCUAR to update (cfg_clk -> ctl_clk domain)
`ifdef DWC_DDRPHY_APB
      repeat (`DWC_CDC_SYNC_STAGES + 4) @(posedge `PUB.pclk);
`else                      
      repeat (`DWC_CDC_SYNC_STAGES + 4) @(posedge `PUB.cfg_clk);
`endif
      // read from the cache
      for (word_addr=0; word_addr<cache_depth; word_addr=word_addr+1) begin
        for (slice_addr=0; slice_addr<cache_slices; slice_addr=slice_addr+1) begin
          // read a single slice
          `CFG.read_register_data(`DCUDR, reg_data);

          // write the read data into the cache memory slice
          slice_start_bit = `CFG_DATA_WIDTH*slice_addr;
          slice_end_bit   = `CFG_DATA_WIDTH+slice_start_bit;
          
          if (slice_end_bit >= cache_width) begin
            slice_end_bit = cache_width - 1;
          end
          
          for (bit_no=slice_start_bit; bit_no<=slice_end_bit; bit_no=bit_no+1) begin
            cache_word[bit_no] = reg_data[bit_no-slice_start_bit];
          end
`ifdef DWC_DDRPHY_APB
          repeat ((`DWC_CDC_SYNC_STAGES<3)? 6*`DWC_CDC_SYNC_STAGES:
                                            4*`DWC_CDC_SYNC_STAGES) @(posedge `PUB.pclk);
`else                      
          repeat ((`DWC_CDC_SYNC_STAGES<3)? 6*`DWC_CDC_SYNC_STAGES:
                                            4*`DWC_CDC_SYNC_STAGES) @(posedge `PUB.cfg_clk);
`endif
        end
        
        // update the cache word    
        case (cache_sel)
          `DCU_CCACHE: ccache[word_addr] = cache_word[`CCACHE_DATA_WIDTH-1:0];
          `DCU_ECACHE: ecache[word_addr] = cache_word[`ECACHE_DATA_WIDTH-1:0];
          `DCU_RCACHE: rcache[word_addr] = cache_word[`RCACHE_DATA_WIDTH-1:0];
        endcase // case (cache_sel)
      end
    end
  endtask // read_dcu_cache

  //---------------------------------------------------------------------------
  // Monitor scheduler activity outside of PUB mode
  //---------------------------------------------------------------------------
`ifndef GATE_LEVEL_SIM
  initial begin
    sch_pub_mode_dtp_chk_en = 1'b1;
  end

  always @(negedge `PUB.ctl_clk) begin
    if (sch_pub_mode_dtp_chk_en) begin
      // For no_sra option, look also at the counter from no_sra_t_dtp_cntr, and check the cntr_on to see if dtp is actively
      // sending and counting for any outgoing commands.
      if (`PUB.u_DWC_ddrphy_scheduler.no_sra_i) begin
        if ((`PUB.u_DWC_ddrphy_scheduler.pub_mode == 1'b0) && 
            ((`PUB.u_DWC_ddrphy_scheduler.t_dtp_cntr != 0        && (`PUB.u_DWC_ddrphy_scheduler.t_dtp_cntr_on == 1)) ||
             (`PUB.u_DWC_ddrphy_scheduler.no_sra_t_dtp_cntr != 0 && (`PUB.u_DWC_ddrphy_scheduler.no_sra_t_dtp_cntr_on == 1)) )) begin
          `SYS.error;
          $display("-> %0t: ==> ERROR: In no_sra mode, pub_mode is deasserted but scheduler timer counter (%0d) has not expired! ", $realtime, `PUB.u_DWC_ddrphy_scheduler.t_dtp_cntr);
        end
      end
      else begin
        if ((`PUB.u_DWC_ddrphy_scheduler.pub_mode == 1'b0) && (`PUB.u_DWC_ddrphy_scheduler.t_dtp_cntr != 0)) begin
          `SYS.error;
          $display("-> %0t: ==> ERROR: pub_mode is deasserted but scheduler timer counter (%0d) has not expired! ", $realtime, `PUB.u_DWC_ddrphy_scheduler.t_dtp_cntr);
        end
      end

    end
  end

`ifndef DWC_DDRPHY_EMUL_XILINX
  //---------------------------------------------------------------------------
  // Monitor number of refresh from each burst of refresh
  // The goal is to check within a burst of refresh command to see if DTCR0.RFSHDT
  //---------------------------------------------------------------------------
  initial begin
    rfsh_cmd_from_pub_mnt_en = 1'b1;
    rfsh_cmd_tx = 0;
    rfsh_rqst_vld_cnt  = 0;
    init_rfsh_rqst_vld_cnt  = 0;
    disable_rfsh_cnt_check = 1'b0;
  end

  task disable_and_reset_rfsh_cmd_from_pub_mnt;
    begin
      rfsh_cmd_from_pub_mnt_en = 1'b0;
      rfsh_cmd_tx = 0;
      rfsh_rqst_vld_cnt  = 0;
      init_rfsh_rqst_vld_cnt  = 0;
    end
  endtask // disable_and_reset_rfsh_cmd_from_pub_mnt


`ifdef DDR2
  // For DDR2 mode, the sdram initialization sequence will sent two refresh
  // temporary disable the rfsh monitor at this stage
  always @(e_sys_reset) begin
    rfsh_cmd_from_pub_mnt_en = 1'b0;
  end
  
  always @(e_sdram_init_done) begin
    rfsh_cmd_from_pub_mnt_en = 1'b1;
  end
`endif  

  always @(negedge `PUB.ctl_clk) begin
    if (`DWC_NO_SRA==0) begin
      if (`PUB.u_DWC_ddrphy_scheduler.auto_cmd != `SDRAM_NOP) begin
        if (`PUB.u_DWC_ddrphy_scheduler.auto_cmd == `REFRESH) begin
          -> e_auto_cmd_is_refresh;
        end
      end
    end
    else begin
      // `DWC_NO_SRA==1
      if (`PUB.u_DWC_ddrphy_scheduler.no_sra_cmd == `SDRAM_NOP ||
          `PUB.u_DWC_ddrphy_scheduler.no_sra_cmd == `REFRESH) begin
        if (`PUB.u_DWC_ddrphy_scheduler.rfsh_cmd == `TRUE) begin
          -> e_auto_cmd_is_refresh;
        end
      end
    end
  end


  // The refresh timer might sent out one or more burst during train_init in DWC_ddrphy_train.train_state. 
  // During that state, there are no other commands going thru the schedule when debug step is
  // also enabled. Hence use the rfsh_rqst_vld_cnt to count how many burst we expected to see.
  always @(posedge `PUB.u_DWC_ddrphy_train.u_DWC_ddrphy_train_data_eye.rfsh_rqst_vld_reg) begin
    if (rfsh_cnt_en && `GRM.dtcr0[20] &&
        (`PUB.u_DWC_ddrphy_train.u_DWC_ddrphy_train_data_eye.dt_cmd_state == `PUB.u_DWC_ddrphy_train.u_DWC_ddrphy_train_data_eye.DT_CMD_CHK_REFRESH)) 
      rfsh_rqst_vld_cnt = rfsh_rqst_vld_cnt +1;
  end
 
  always @(posedge `PUB.u_DWC_ddrphy_train.u_DWC_ddrphy_train_data_eye.rfsh_rqst_vld_reg) begin
    if (rfsh_cnt_en && `GRM.dtcr0[20] && (`PUB.u_DWC_ddrphy_train.u_DWC_ddrphy_train_data_eye.refresh_done == 1'b1) &&
        (`PUB.u_DWC_ddrphy_train.u_DWC_ddrphy_train_data_eye.dt_cmd_state == `PUB.u_DWC_ddrphy_train.u_DWC_ddrphy_train_data_eye.DT_CMD_REFRESH_ENTRY)) 
      init_rfsh_rqst_vld_cnt = init_rfsh_rqst_vld_cnt +1;
  end
 
  // new command coming in auto cmd
  always @ (`PUB.u_DWC_ddrphy_scheduler.auto_cmd or negedge `PUB.u_DWC_ddrphy_train.u_DWC_ddrphy_train_data_eye.train_init_en) begin

    if (`DWC_NO_SRA==0) begin
      // ignore SDRAM_NOP coming in
      if (`PUB.u_DWC_ddrphy_scheduler.auto_cmd != `SDRAM_NOP) begin
        if (`PUB.u_DWC_ddrphy_scheduler.auto_cmd == `REFRESH) begin
          rfsh_cnt_en  = `TRUE;
          rfsh_cmd_tx  = rfsh_cmd_tx + 1;
        end
        else begin
          // when curr auto_cmd is not refresh and rfsh_cnt_en was true, check expect refresh burst count
          if (rfsh_rqst_vld_cnt>0) begin
            if (rfsh_cmd_tx != (`GRM.dtcr0[31:28] * (rfsh_rqst_vld_cnt + 1))  && rfsh_cnt_en == `TRUE && rfsh_cmd_from_pub_mnt_en && (!disable_rfsh_cnt_check)) begin
              `SYS.error;
              $display("-> %0t: [SYSTEM] ==> ERROR: REFRESH COUNT MISMATCH, Expected %0d  got  %0d", $realtime, (`GRM.dtcr0[31:28] * (rfsh_rqst_vld_cnt + 1)), rfsh_cmd_tx);
            end
            else begin
              if (rfsh_cmd_tx == (`GRM.dtcr0[31:28] * (rfsh_rqst_vld_cnt + 1)) && rfsh_cnt_en == `TRUE && rfsh_cmd_from_pub_mnt_en) begin
                -> e_refresh_burst_match_dtcr_rfshdt;
              end
            end
          end
          if (init_rfsh_rqst_vld_cnt>0) begin
            if (rfsh_cmd_tx != (`GRM.dtcr0[31:28] * (init_rfsh_rqst_vld_cnt + 1))  && rfsh_cnt_en == `TRUE && rfsh_cmd_from_pub_mnt_en && (!disable_rfsh_cnt_check)) begin
              `SYS.error;
              $display("-> %0t: [SYSTEM] ==> ERROR: INIT REFRESH COUNT MISMATCH, Expected %0d  got  %0d", $realtime, (`GRM.dtcr0[31:28] * (init_rfsh_rqst_vld_cnt + 1)), rfsh_cmd_tx);
            end
            else begin
              if (rfsh_cmd_tx == (`GRM.dtcr0[31:28] * (init_rfsh_rqst_vld_cnt + 1)) && rfsh_cnt_en == `TRUE && rfsh_cmd_from_pub_mnt_en) begin
                -> e_refresh_burst_match_dtcr_rfshdt;
              end
            end
          end
          // reset refresh count and enable
          rfsh_cnt_en  = `FALSE;
          rfsh_cmd_tx  = 0;
          rfsh_rqst_vld_cnt  = 0;
          init_rfsh_rqst_vld_cnt  = 0;
        end
      end
    end
  end 

  // no_sra==1
  always @ (`PUB.u_DWC_ddrphy_scheduler.rfsh_cmd or `PUB.u_DWC_ddrphy_scheduler.no_sra_cmd) begin

    if (`DWC_NO_SRA==1) begin
      // For no_sra mode,  allow rfsh_cmd to be counted when
      // either auto_cmd or no_sra_cmd is in REFRESH or rfsh_last_burst is still asserted for the very last refresh rqst
      if (`PUB.u_DWC_ddrphy_scheduler.auto_cmd == `REFRESH    ||
          `PUB.u_DWC_ddrphy_scheduler.no_sra_cmd == `REFRESH   ||
          `PUB.u_DWC_ddrphy_scheduler.rfsh_last_burst) begin
        if (`PUB.u_DWC_ddrphy_scheduler.rfsh_cmd == `TRUE) begin
          rfsh_cnt_en  = `TRUE;
          rfsh_cmd_tx  = rfsh_cmd_tx + 1;
        end
        else begin
          if (`PUB.u_DWC_ddrphy_scheduler.rfsh_cmd == `FALSE) begin
            // do nothing.. dont increment count
          end
        end
      end // not `PUB.u_DWC_ddrphy_scheduler.no_sra_cmd != `SDRAM_NOP or `REFRESH
      else begin
        // no_sra_cmd is no longer in REFRESH...
        // when curr no_sra_cmd is not refresh and rfsh_cnt_en was true, check expect refresh burst count
        if (rfsh_rqst_vld_cnt>0) begin
          if (rfsh_cmd_tx != (`GRM.dtcr0[31:28] * (rfsh_rqst_vld_cnt + 1) * pNO_OF_LRANKS)  && rfsh_cnt_en == `TRUE && rfsh_cmd_from_pub_mnt_en) begin
            `SYS.error;
            $display("-> %0t: [SYSTEM] ==> ERROR: REFRESH COUNT MISMATCH, Expected %0d  got  %0d", $realtime, (`GRM.dtcr0[31:28] * (rfsh_rqst_vld_cnt + 1) * pNO_OF_LRANKS), rfsh_cmd_tx);
          end
          else begin
            if (rfsh_cmd_tx == (`GRM.dtcr0[31:28] * (rfsh_rqst_vld_cnt + 1) * pNO_OF_LRANKS) && rfsh_cnt_en == `TRUE && rfsh_cmd_from_pub_mnt_en) begin
              -> e_refresh_burst_match_dtcr_rfshdt;
            end
          end
        end
        // no_sra_cmd is no longer in REFRESH...
        // when curr no_sra_cmd is not refresh and rfsh_cnt_en was true, check expect refresh burst count
        if (init_rfsh_rqst_vld_cnt>0) begin
          if (rfsh_cmd_tx != (`GRM.dtcr0[31:28] * (init_rfsh_rqst_vld_cnt + 1) * pNO_OF_LRANKS)  && rfsh_cnt_en == `TRUE && rfsh_cmd_from_pub_mnt_en) begin
            `SYS.error;
            $display("-> %0t: [SYSTEM] ==> ERROR: INIT REFRESH COUNT MISMATCH, Expected %0d  got  %0d", $realtime, (`GRM.dtcr0[31:28] * (init_rfsh_rqst_vld_cnt + 1) * pNO_OF_LRANKS), rfsh_cmd_tx);
          end
          else begin
            if (rfsh_cmd_tx == (`GRM.dtcr0[31:28] * (init_rfsh_rqst_vld_cnt + 1) * pNO_OF_LRANKS) && rfsh_cnt_en == `TRUE && rfsh_cmd_from_pub_mnt_en) begin
              -> e_refresh_burst_match_dtcr_rfshdt;
            end
          end
        end
        // reset refresh count and enable
        rfsh_cnt_en  = `FALSE;
        rfsh_cmd_tx  = 0;
        rfsh_rqst_vld_cnt  = 0;
        init_rfsh_rqst_vld_cnt  = 0;
      end
    end  
  end // always @ (`PUB.u_DWC_ddrphy_scheduler.rfsh_cmd or `PUB.u_DWC_ddrphy_scheduler.no_sra_cmd)
`endif  
`endif
  
  `ifdef DWC_DDRPHY_EMUL_XILINX
  // Emulation setup of read borad delay
  // --------------------------
  task set_read_brd_dly_emul;
    integer rank_no,byte_no,brd_dly;
    begin
      `SYS.disable_undefined_warning;
      for (byte_no=0; byte_no<pNUM_LANES; byte_no=byte_no+1) begin : apply_byte_rd_dly_emulation
        for (rank_no=0; rank_no < pNO_OF_LRANKS; rank_no=rank_no+1) begin : apply_rank_rd_dly_emulation
          // Random read borad delay
          `SYS.disable_undefined_warning;
          RANDOM_RANGE(seed_rr, 0, 700, brd_dly);       
          set_read_board_delay(rank_no, byte_no, brd_dly);  
        end
      end
    end
  endtask // set_read_brd_dly_emul
  
  // report and update GRM when necessary
  // --------------------------
  task rpt_dqs_train_emul;
    reg [31:0] reg_word;
    integer byte_no;
    begin
      $display("\n=> Reporting the result of DQS training ...\n");  
      `CFG.disable_read_compare;
      // Update the GRM.
      for (byte_no=0; byte_no<`DWC_NO_OF_BYTES; byte_no=byte_no+1) begin 
        `CFG.read_register_data(`DX0BDLR5+byte_no*`DX_REG_RANGE, reg_word);
        `GRM.dxnbdlr5[byte_no] = reg_word;
        `CFG.read_register_data(`DX0BDLR6+byte_no*`DX_REG_RANGE, reg_word);
        `GRM.dxnbdlr6[byte_no] = reg_word;
`ifdef DWC_DDRPHY_X4MODE
        `CFG.read_register_data(`DX0BDLR8+byte_no*`DX_REG_RANGE, reg_word);
        `GRM.dxnbdlr8[byte_no] = reg_word;
        `CFG.read_register_data(`DX0BDLR9+byte_no*`DX_REG_RANGE, reg_word);
        `GRM.dxnbdlr9[byte_no] = reg_word;
`endif
      end
      $display("\n=> Reporting DQS training Status [Byte]...\n");  
      // Update the status register
      for (byte_no=0; byte_no<`DWC_NO_OF_BYTES; byte_no=byte_no+1) begin 
        `CFG.read_register_data(`DX0GSR0+byte_no*`DX_REG_RANGE, reg_word);
        `GRM.dxngsr0[byte_no] = (reg_word);
        `CFG.read_register_data(`DX0GSR1+byte_no*`DX_REG_RANGE, reg_word);
        `GRM.dxngsr1[byte_no] = (reg_word);
`ifdef DWC_DDRPHY_X4MODE
        `CFG.read_register_data(`DX0GSR4+byte_no*`DX_REG_RANGE, reg_word);
        `GRM.dxngsr4[byte_no] = (reg_word);
`endif
      end
      // Update pgsr0
      $display("\n => Reporting DQS training Status Global  ...\n");  
      `CFG.read_register_data(`PGSR0, reg_word);
      `GRM.pgsr0 = reg_word;
      
      if (exp_dqs_gate_train_err === `FALSE) begin
        
        for (byte_no = 0; byte_no < pNUM_LANES; byte_no = byte_no + 1) begin
           if (`DWC_DX_NO_OF_DQS == 1)
             begin
                `CFG.read_register_data(`DX0GSR0 + (`DX_REG_RANGE * byte_no), tmp);
                if (tmp[29:26] != 4'b0000) begin
                   `SYS.error;
                   $display("-> %0t: [SYSTEM] ERROR: Expect DX%0dGSR0 [29:26] = %0h got %0h", $time, byte_no, 4'h0, tmp[29:26]);
                end
             end
           else
             begin
                if (byte_no % 2 == 0)
                  begin
                     `CFG.read_register_data(`DX0GSR0 + (`DX_REG_RANGE * (byte_no/2)), tmp);
                     if (tmp[29:26] != 4'b0000) begin
                        `SYS.error;
                        $display("-> %0t: [SYSTEM] ERROR: Expect DX%0dGSR0 [29:26] = %0h got %0h", $time, byte_no/2, 4'h0, tmp[29:26]);
                     end
                  end
                else
                  begin
                     `CFG.read_register_data(`DX0GSR4 + (`DX_REG_RANGE * ((byte_no-1)/2)), tmp);
                     if (tmp[29:26] != 4'b0000) begin
                        `SYS.error;
                        $display("-> %0t: [SYSTEM] ERROR: Expect DX%0dGSR4 [29:26] = %0h got %0h", $time, (byte_no-1)/2, 4'h0, tmp[29:26]);
                     end
                  end // else: !if(byte_no%2 == 0)
             end // else: !if(`DWC_DX_NO_OF_DQS == 1)
        end
      end else begin
        $display("-> %0t: [SYSTEM] : Need to find out in testcase which rank and lane has err!!", $time);
      end

      if ({`GRM.pgsr0[22], `GRM.pgsr0[6]} != {exp_dqs_gate_train_err,`TRUE}) begin
        `SYS.error;
        $display("-> %0t: [SYSTEM] ERROR: Expect PGSR0 [22,6] = %0h got %0h", $time, {exp_dqs_gate_train_err,`TRUE}, {`GRM.pgsr0[22], `GRM.pgsr0[6]});
      end
      
      repeat (10) @(posedge `CFG.clk);
      `CFG.enable_read_compare;
      repeat (10) @(posedge `CFG.clk);
    end
  endtask // rpt_dqs_train_emul

  `ifdef DWC_DDRPHY_EMUL_CFGFILE // run with config file (-cfgfile)
  `else
    
                
  // Emulation Load the DQS gating training pre-default value accorind to the speed grade
  // These pre-default values are legit when there is no board delay introduced.
  task load_dqs_gate_DT_val_emul;
    //input       reg_rand;
    integer     i;
    reg [4 : 0] dly;
    reg [3 : 0] qvld_even;
    reg [3 : 0] qvld_odd;
    reg [1 : 0] eo_even;
    reg [1 : 0] eo_odd;
    reg [31: 0] reg_word;
    integer rd_lat, rnk_idx;
    begin
      // write a value to the DQS gating register so that it is correctly
      //Calculate the EVEN ODD Case due to CL, AL
      `ifndef LPDDRX
        rd_lat = `GRM.cl + `tDQSCK;
      `elsif DDR2
        rd_lat = `GRM.al + `GRM.cl + `DWC_RDIMM;
      `elsif DDR4 
        rd_lat = `GRM.al + `GRM.cl + (`GRM.mr5[0][2:0] == 3'b001) ? 4 :  // DDR4 CA Parity Latency
                                     (`GRM.mr5[0][2:0] == 3'b010) ? 5 :
                                     (`GRM.mr5[0][2:0] == 3'b011) ? 6 :
                                     (`GRM.mr5[0][2:0] == 3'b100) ? 8 : 0;
      `else //DDR3
         rd_lat = `GRM.al + `GRM.cl;
      `endif
                                      
        // If data trining switching is on, there is no need to load the predefault value.
      `ifndef DWC_RUN_DQS_TRAIN 
// Load default cal values for cfgfile
       `ifndef  DWC_DDRPHY_TB_OVERRIDE
         `define DWC_DXn_RD_EMUL_eo_even0    2'h0
         `define DWC_DXn_RD_EMUL_eo_odd0     2'h2
         `define DWC_DXn_RD_EMUL_qvld_even0  4'h4
         `define DWC_DXn_RD_EMUL_qvld_odd0   4'h4
       `endif
          if(rd_lat%2) begin
      $display("-> %0t: [SYSTEM] ODD Case: %0h  ", $time, rd_lat );
 `ifdef DWC_DDRPHY_EMUL_XV7 
            eo_odd    = `DWC_DXn_RD_EMUL_XV7_eo_even0;
            eo_even   = `DWC_DXn_RD_EMUL_XV7_eo_odd0;
            qvld_odd  = `DWC_DXn_RD_EMUL_XV7_qvld_even0;
            qvld_even = `DWC_DXn_RD_EMUL_XV7_qvld_odd0;
 `else
            eo_odd    = `DWC_DXn_RD_EMUL_eo_even0;
            eo_even   = `DWC_DXn_RD_EMUL_eo_odd0;
            qvld_odd  = `DWC_DXn_RD_EMUL_qvld_even0;
            qvld_even = `DWC_DXn_RD_EMUL_qvld_odd0;
 `endif
          end else begin
      $display("-> %0t: [SYSTEM] EVEN Case: %0h, ", $time, rd_lat );
 `ifdef DWC_DDRPHY_EMUL_XV7
            eo_even   = `DWC_DXn_RD_EMUL_XV7_eo_even0;
            eo_odd    = `DWC_DXn_RD_EMUL_XV7_eo_odd0;
            qvld_even = `DWC_DXn_RD_EMUL_XV7_qvld_even0;
            qvld_odd  = `DWC_DXn_RD_EMUL_XV7_qvld_odd0;
 `else
            eo_even   = `DWC_DXn_RD_EMUL_eo_even0;
            eo_odd    = `DWC_DXn_RD_EMUL_eo_odd0;
            qvld_even = `DWC_DXn_RD_EMUL_qvld_even0;
            qvld_odd  = `DWC_DXn_RD_EMUL_qvld_odd0;
  `endif
          end

        // Load them up into the registers
        for (i=0; i<`DWC_NO_OF_BYTES; i=i+1) begin
          reg_word = {2'b00, eo_even, qvld_even,2'b00,eo_even, qvld_even, 2'b00, eo_even, qvld_even, 2'b00, eo_even, qvld_even};
          `CFG.write_register(`DX0BDLR5+i*`DX_REG_RANGE, reg_word);
          reg_word = {2'b00, eo_odd, qvld_odd, 2'b00, eo_odd, qvld_odd, 2'b00, eo_odd, qvld_odd, 2'b00, eo_odd, qvld_odd};
          `CFG.write_register(`DX0BDLR6+i*`DX_REG_RANGE, reg_word);      

          reg_word = {2'b00, eo_even, qvld_even,2'b00,eo_even, qvld_even, 2'b00, eo_even, qvld_even, 2'b00, eo_even, qvld_even};
          `CFG.write_register(`DX0BDLR8+i*`DX_REG_RANGE, reg_word);
          reg_word = {2'b00, eo_odd, qvld_odd, 2'b00, eo_odd, qvld_odd, 2'b00, eo_odd, qvld_odd, 2'b00, eo_odd, qvld_odd};
          `CFG.write_register(`DX0BDLR9+i*`DX_REG_RANGE, reg_word);      
        end
    `endif
      need_data_train   = 1'b0;
    end
  endtask // load_dqs_gate_DT_val_emul
  `endif
  
  // Emulation setup procedures
  // --------------------------
  task xilinx_emulation_setup;
    reg train_stage1;
    begin
      // Generate a random value of delay on each data byte
      if(`GRM.pir[10])begin
        need_data_train         = 1'b0;
        dqs_train_in_sdram_init = 1'b1;
      end else begin
        `ifdef DWC_RUN_DQS_TRAIN  
          need_data_train   = 1'b1;
        `else
          `ifdef DWC_DDRPHY_BOARD_DELAYS
            need_data_train   = 1'b1;
          `else
            need_data_train   = 1'b0;
          `endif
        `endif
      end
      // Disable refresh check TBD
      //`SYS.disable_refresh_check;
      if      (`DWC_PLL_DIV_CKIN==1 && `DWC_PLL_MF== 6 && `DWC_PLL_DIV_F== 3) `GRM.pllcr[1 :0] = 2'b00;
      else if (`DWC_PLL_DIV_CKIN==1 && `DWC_PLL_MF== 8 && `DWC_PLL_DIV_F== 4) `GRM.pllcr[1 :0] = 2'b00;
      else if (`DWC_PLL_DIV_CKIN==1 && `DWC_PLL_MF==16 && `DWC_PLL_DIV_F== 8) `GRM.pllcr[1 :0] = 2'b01;
      else if (`DWC_PLL_DIV_CKIN==1 && `DWC_PLL_MF==32 && `DWC_PLL_DIV_F==16) `GRM.pllcr[1 :0] = 2'b10;
      else if (`DWC_PLL_DIV_CKIN==1 && `DWC_PLL_MF==64 && `DWC_PLL_DIV_F==32) `GRM.pllcr[1 :0] = 2'b11;
      `GRM.pllcr[3:2] = 0;
      `CFG.write_register(`PLLCR, `GRM.pllcr);
      
      train_stage1 = 1'b0;
      `ifdef DWC_DDRPHY_EMUL_DEBUG
         train_stage1 = 1'b1;
      `endif
      `ifdef BIDIRECTIONAL_SDRAM_DELAYS
         train_stage1 = 1'b1;
      `endif
      `ifdef DWC_DDRPHY_BOARD_DELAYS
         train_stage1 = 1'b1;
      `endif
      `ifdef DWC_RUN_ALL_TRAIN
        train_stage1 = 1'b1;
      `endif
      if(train_stage1) begin
        `GRM.dtcr0[31:28] = 1;  // refresh
        `GRM.dtcr0[20   ] = 1;  // debug
        `GRM.dtcr0[21   ] = 1;  // stage
        `GRM.dtcr0[3 :0 ] = 1;  // repeat read number
        `CFG.write_register(`DTCR0, `GRM.dtcr0);
        need_data_train   = 1'b1;
      end else begin
        `GRM.dtcr0[31:28] = 1;  // refresh
        `GRM.dtcr0[20   ] = 0;  // debug
        `GRM.dtcr0[21   ] = 0;  // stage
        `CFG.write_register(`DTCR0, `GRM.dtcr0); 
      end
      `GRM.dtcr1 [31:16] = 16'hFFFF;
      `ifdef RDIMM_SINGLE_RANK
        `ifdef RDIMM_DUAL_RANK 
            // For RDIMM_SINGLE_RANK, there is only 1 rank per DIMM.
            // to setup for 1 rank  only, use runtc option ranks=2 and turn on RANKEN only for the even rank; one DIMM device
            // to setup for 2 ranks only, use runtc option ranks=4 and turn on RANKEN only for the even rank; two DIMM device
            for (i=0; i<`DWC_NO_OF_LRANKS; i=i+1) begin
              // disable the odd ones
              if (i%2)
                `GRM.dtcr1 [16+i] = 1'b0;
            end
            `CFG.write_register(`DTCR1, `GRM.dtcr1);
        `endif
      `endif        
      `ifdef RDIMM_DUAL_RANK 
            // if run dualcs in a rdimm_quad_rank (DWC_RCD_MODE==2 or 3)
            // only 2 ranks is available as there are 4 CS_N but 2 ODT and 2 CKE available per dimm
            // Hence, disable the upper two ranks in DTCR1
            if (`DWC_RCD_MODE >= 2) begin
              for (i=0; i<`DWC_NO_OF_LRANKS; i=i+1) begin
                if (i%4 >= 2)
                  `GRM.dtcr1 [16+i] = 1'b0;
              end  
              `CFG.write_register(`DTCR1, `GRM.dtcr1);
            end
      `endif
      /*
      `ifdef RDIMM_EQUAD_RANK 
            // if run dualcs in a rdimm_quad_rank (DWC_RCD_MODE==2 or 3)
            // only 2 ranks is available as there are 4 CS_N but 2 ODT and 2 CKE available per dimm
            // Hence, disable the upper two ranks in DTCR1
            if (`DWC_RCD_MODE >= 2) begin
              for (i=0; i<`DWC_NO_OF_LRANKS; i=i+1) begin
                if (i%4 >= 2)
                  `GRM.dtcr1 [16+i] = 1'b0;
              end  
              `CFG.write_register(`DTCR1, `GRM.dtcr1);
            end
      `endif
      */
      `CFG.write_register(`DTCR1, `GRM.dtcr1);
      // Load the refresh counter accordingly
      `GRM.dtdr0 = 32'hAABBCCDD;
      `CFG.write_register(`DTDR0, `GRM.dtdr0); 
    end
  endtask
  
    // Load a phase value to PLL
  task dqs_gate_train_emul_s1;
    begin
      // Enable debug mode
      `GRM.dtcr0[3 : 0] = 1;  // repeated read
      `GRM.dtcr0[31:28] = 1;  // refresh
      `GRM.dtcr0[7    ] = 1;  // debug
      `GRM.dtcr0[22:21] = 1;  // stage
      // Pattern
      `CFG.write_register(`DTCR0, `GRM.dtcr0);
      `GRM.dtdr0 = 32'haabbccdd;
      `CFG.write_register(`DTDR0, `GRM.dtdr0);
      disable_dq_setup_hold_checks;
      disable_undefined_warning;
      $display("\n\n=> Triggering DQS gate training in Stage1...\n");
      `SYS.dqs_gate_train(pNO_OF_LRANKS, 0);
      enable_dq_setup_hold_checks;
      enable_undefined_warning;
      // Disable the debug mode
      `GRM.dtcr0[7    ] = 0;  // debug
      `GRM.dtcr0[22:21] = 0;  // stage
      `CFG.write_register(`DTCR0, `GRM.dtcr0);
    end
  endtask
  
  // Load a phase value to PLL
  task load_phase_2_mmcm_emul;
    input [5:0] phaseValue;
    begin
      $display("\n\n=> Load the phase value: %d to PLL",phaseValue);
      // Load the PLL phase value
      `GRM.pllcr[9:4]=phaseValue; //PLL value here 
      `CFG.write_register(`PLLCR, `GRM.pllcr);
      `GRM.pir[0 ] = 1; // init
      `GRM.pir[20] = 1; // load phase
      `CFG.write_register(`PIR, `GRM.pir);
      repeat (10) @(posedge `CFG.clk);
      `CFG.poll_register(`PGSR0, 0, 0, 1'b1, 100, 3000, "Load PLL phase complete");
    end
  endtask
  
  // Read a register value from PLL
  task read_mmcm_register;
    input [4 :0] addr;
    output[15:0] data;
    begin
      $display("\n\n=> Read MMCM register at address: %d ",addr);
      // Load the PLL phase value
      `GRM.acmdlr0[21]   =1'b0; //read
      `GRM.acmdlr0[20:16]=addr;
      `CFG.write_register(`ACMDLR0, `GRM.acmdlr0);
      `GRM.pir[0 ] = 1; // init
      `GRM.pir[21] = 1; // load phase
      `CFG.write_register(`PIR, `GRM.pir);
      repeat (10) @(posedge `CFG.clk);
      `CFG.poll_register(`PGSR0, 0, 0, 1'b1, 100, 3000, "Read MMCM register complete");
      `CFG.disable_read_compare;
      `CFG.read_register_data(`ACMDLR0, `GRM.acmdlr0);
      data = `GRM.acmdlr0[15:0];
      repeat (5) @(posedge `CFG.clk);
      `CFG.enable_read_compare;
    end
  endtask
  
  // Write a register value from PLL
  task write_mmcm_register;
    input [4 :0] addr;
    input [15:0] data;
    begin
      $display("\n\n=> Write MMCM register at address: %d ",addr);
      // Load the PLL phase value
      `GRM.acmdlr0[21]   =1'b1; //read
      `GRM.acmdlr0[20:16]=addr;
      `GRM.acmdlr0[15: 0]=data;
      `CFG.write_register(`ACMDLR0, `GRM.acmdlr0);
      `GRM.pir[0 ] = 1; // init
      `GRM.pir[21] = 1; // load phase
      `CFG.write_register(`PIR, `GRM.pir);
      repeat (10) @(posedge `CFG.clk);
      `CFG.read_register_data(`ACMDLR0, `GRM.acmdlr0);
      data = `GRM.acmdlr0[15:0];
      `CFG.poll_register(`PGSR0, 0, 0, 1'b1, 100, 3000, "Write MMCM register complete");
    end
  endtask
  
  
  // Add 2 ck clock on write leveling system latency for rdimm dual/quad rank
  task add_2ck_wl_sys_lat_emul;
    integer i,j;
    begin
      for (j=0; j<`DWC_NO_OF_RANKS; j=j+1) begin
        `GRM.rankidr[3 : 0] = j;
        `GRM.rankidr[19:16] = j;
        `CFG.write_register(`RANKIDR, `GRM.rankidr);
        repeat (5) @(posedge `CFG.clk);
        for (i=0; i<`DWC_NO_OF_BYTES; i=i+1) begin
          //if(`GRM.ddr_mode==`DDR3_MODE) begin
            if(j==0 && i==0) $display("\n-> %0t: [SYSTEM] : Add 0.5 ck clock on write leveling system latency", $time);
            `GRM.dxngtr0[j][i][19:16] = 4'b0011;
            `ifdef DWC_DDRPHY_X4MODE
              `GRM.dxngtr0[j][i][23:20] = 4'b0011;
            `endif
          /*end else begin
            if(j==0 && i==0) $display("\n-> %0t: [SYSTEM] : Add 0.5 ck clock on write leveling system latency", $time);
           `GRM.dxngtr0[j][i][19:16] = 4'b0011;
           `ifdef DWC_DDRPHY_X4MODE
              `GRM.dxngtr0[j][i][23:20] = 4'b0011;
            `endif
          end */
          `CFG.write_register(`DX0GTR0+i*`DX_REG_RANGE, `GRM.dxngtr0[j][i]);
        end
      end
      $display("\n");
    end
  endtask

`endif // DWC_DDRPHY_EMUL_XILINX


`ifndef GATE_LEVEL_SIM  
`ifndef DWC_DDRPHY_GATE_SIM_EXCEPT
`ifndef DWC_DDRPHY_EMUL_XILINX  // remove DEBUG signal probing in Emulation
  genvar bl_idx;

  // MIKE... need to update this
/*                      //                     
  // DFI internal FIFOs error monitors
  generate
    for (bl_idx = 0; bl_idx < pNUM_LANES; bl_idx = bl_idx + 1) begin : gen_mnt_dfi
      always @(negedge `PHYDFI.ctl_clk) begin
        if (dfi_fifo_chk_en) begin
          // Read-data FIFO
          if (`PHYDFI.chn[0].dx.dx_ctl.rd.dx[bl_idx].u_dx_rd.u_fifo.O_push_error) begin
            `SYS.error;
            $display("-> %0t: ==> ERROR: FIFO overflow error in read data FIFO %0d", $realtime, bl_idx);
          end
          if (`PHYDFI.chn[0].dx.dx_ctl.rd.dx[bl_idx].u_dx_rd.u_fifo.O_pop_error) begin
            `SYS.error;
            $display("-> %0t: ==> ERROR: FIFO underflow error in read data FIFO %0d", $realtime, bl_idx);
          end
          // Read gdqs_dly FIFO
          if (`PHYDFI.chn[0].dx.dx_ctl.rd.dx[bl_idx].u_dx_rd.u_fifo_gdqs_dly.O_push_error) begin
            `SYS.error;
            $display("-> %0t: ==> ERROR: FIFO overflow error in read gdqs_dly FIFO %0d", $realtime, bl_idx);
          end
          if (`PHYDFI.chn[0].dx.dx_ctl.rd.dx[bl_idx].u_dx_rd.u_fifo_gdqs_dly.O_pop_error) begin
            `SYS.error;
            $display("-> %0t: ==> ERROR: FIFO underflow error in read gdqs_dly FIFO %0d", $realtime, bl_idx);
          end
        end  // if (dfi_fifo_chk_en) ...
      end  // always ...
    end
  endgenerate
*/
 `endif

  //---------------------------------------------------------------------------
  // Debug signals
  //---------------------------------------------------------------------------
  
  localparam                      pDDR4_CMD_LAT_MAX = 8;

  integer                         byte_idx;
  integer                         dx_idx;
  integer                         rank_idx;
  integer                         cidx;

  //// PHY

  reg  [8                  - 1 : 0] dbg_phy_dq       [`DWC_NO_OF_BYTES - 1 : 0];
  reg  [8                  - 1 : 0] dbg_dq_fromsdram [`DWC_NO_OF_BYTES - 1 : 0];
  reg  [(8 * 4)            - 1 : 0] dbg_phy_phy_q    [`DWC_NO_OF_BYTES - 1 : 0];
  wire [7                  - 1 : 0] dbg_phy_sdram_cmd;
  integer                           dbg_phy_sdram_col_addr;
  integer                           dbg_phy_sdram_row_addr;
  integer                           dbg_phy_sdram_bank_addr;
  integer                           dbg_phy_sdram_bg_addr;
  reg  [(8 * 4)            - 1 : 0] dbg_phy_sdram_rank_addr;
  wire [`DWC_ADDR_WIDTH + 3  - 1:0] dbg_phy_sdram_ddr4_row_addr_bus;
  reg  [(8 * 1)            - 1 : 0] rank_idx_str;
  wire                              dbg_phy_sdram_cmd_PRE_1BANK;
  wire                              dbg_phy_sdram_cmd_PRE;
  wire                              dbg_phy_sdram_cmd_ACT;
  wire                              dbg_phy_sdram_cmd_MRS;
  wire                              dbg_phy_sdram_cmd_REF;
  wire                              dbg_phy_sdram_cmd_WR;
  wire                              dbg_phy_sdram_cmd_RD;
  wire                              dbg_phy_sdram_cmd_NOP;
  wire                              dbg_phy_sdram_cmd_DES;
  reg  [3                  - 1 : 0] dbg_phy_sdram_MR_num;
  reg  [(8 * 100)          - 1 : 0] dbg_MRS_decode_fields [12 - 1 : 0];
  reg  [pNO_OF_CSNS        - 1 : 0] dbg_phy_sdram_mr0_bl_otf;
  integer                           dbg_phy_sdram_mr3_cmd_lat [pNO_OF_CSNS  - 1 : 0];
  reg  [pNO_OF_CSNS        - 1 : 0] dbg_phy_sdram_cs_n_pn     [pDDR4_CMD_LAT_MAX - 1 : 0];
  // {BC_n, a[10]/AP, CS_n, ACT_n, RAS_n, CAS_n, WE_n}
  wire [8                  - 1 : 0] dbg_phy_sdram_ddr4_cmd;


  `ifdef DDR4
    assign dbg_phy_sdram_ddr4_row_addr_bus = `PHY.a[17:0];
  
    // Decode PHY command to SDRAM
    // Assumes all ranks programmed to same command latency as rank 0
    // Assumes all ranks programmed to same BL-fixed or on-the-fly
    assign dbg_phy_sdram_ddr4_cmd = {  &dbg_phy_sdram_mr0_bl_otf  // BL on-the-fly
                                     , `PHY.a[12]                 // BC_n
                                     , `PHY.a[10]                 // AP
                                     , (&dbg_phy_sdram_cs_n_pn[dbg_phy_sdram_mr3_cmd_lat[0]])
                                     , `PHY.act_n                 // act_n
                                     , `PHY.a[16]                 // ras_n
                                     , `PHY.a[15]                 // cas_n
                                     , `PHY.a[14]                 // we_n
                                    };
  `else
    `ifdef DWC_CUSTOM_PIN_MAP
    assign dbg_phy_sdram_cmd = {   &dbg_phy_sdram_mr0_bl_otf  // BL on-the-fly
                                 , `PHY.a[12]                 // BC_n
                                 , `PHY.a[10]                 // AP
                                 , (&(`PHY.cs_n))         
                                 // ras_n
                                 , ((`DWC_DDR32_RAS_MAP == `DWC_ACTN_INDX) ? `PHY.act_n  : ( 
                                    (`DWC_DDR32_RAS_MAP == `DWC_BG1_INDX ) ? `PHY.bg[1]  : ( 
                                    (`DWC_DDR32_RAS_MAP == `DWC_A17_INDX ) ? `PHY.a[17]  : ( 
                                    (`DWC_DDR32_RAS_MAP == `DWC_A16_INDX ) ? `PHY.a[16]  : ( 
                                    (`DWC_DDR32_RAS_MAP == `DWC_A15_INDX ) ? `PHY.a[15]  : ( 
                                    (`DWC_DDR32_RAS_MAP == `DWC_A14_INDX ) ? `PHY.a[14]  : 1'b1 ))))))
                                 // cas_n
                                 , ((`DWC_DDR32_CAS_MAP == `DWC_ACTN_INDX) ? `PHY.act_n  : ( 
                                    (`DWC_DDR32_CAS_MAP == `DWC_BG1_INDX ) ? `PHY.bg[1]  : ( 
                                    (`DWC_DDR32_CAS_MAP == `DWC_A17_INDX ) ? `PHY.a[17]  : ( 
                                    (`DWC_DDR32_CAS_MAP == `DWC_A16_INDX ) ? `PHY.a[16]  : ( 
                                    (`DWC_DDR32_CAS_MAP == `DWC_A15_INDX ) ? `PHY.a[15]  : ( 
                                    (`DWC_DDR32_CAS_MAP == `DWC_A14_INDX ) ? `PHY.a[14]  : 1'b1 ))))))
                                 // we_n
                                 , ((`DWC_DDR32_WE_MAP == `DWC_ACTN_INDX)  ? `PHY.act_n  : ( 
                                    (`DWC_DDR32_WE_MAP == `DWC_BG1_INDX )  ? `PHY.bg[1]  : ( 
                                    (`DWC_DDR32_WE_MAP == `DWC_A17_INDX )  ? `PHY.a[17]  : ( 
                                    (`DWC_DDR32_WE_MAP == `DWC_A16_INDX )  ? `PHY.a[16]  : ( 
                                    (`DWC_DDR32_WE_MAP == `DWC_A15_INDX )  ? `PHY.a[15]  : ( 
                                    (`DWC_DDR32_WE_MAP == `DWC_A14_INDX )  ? `PHY.a[14]  : 1'b1 ))))))
                               };

    `else
    assign dbg_phy_sdram_cmd = {   &dbg_phy_sdram_mr0_bl_otf  // BL on-the-fly
                                 , `PHY.a[12]                 // BC_n
                                 , `PHY.a[10]                 // AP
      `ifdef DWC_AC_CS_USE                                 
                                 , (&(`PHY.cs_n))         
      `else                             
                                 , 1'b1
      `endif    
      `ifdef DWC_AC_ACT_USE                                 
                                 , `PHY.act_n                 // ras_n
      `else                             
                                 , 1'b1
      `endif    
                                 , `PHY.a[17]                 // cas_n
                                 , `PHY.a[16]                 // we_n
                               };
    `endif
  `endif //`ifdef DDR4 

  // MIKE, need to update this

  //////////////////////////////////////////////////////////////////////////////
  ////  Probe DRAM models
  //////////////////////////////////////////////////////////////////////////////
  `define DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx) `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[dwc_rnk].sdram_rank.dwc_sdram[gv_dx_idx].xn_dram.u_sdram.sdram
  `define SDRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx) `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[dwc_rnk].sdram_rank.dwc_sdram[gv_dx_idx].xn_dram.u_sdram

  `ifdef SDRAMx16
    `ifdef DWC_USE_SHARED_AC_TB
      localparam pNUM_DRAM_PER_RANK = ((`DWC_NO_OF_BYTES/2)/2 == 0) ? 1 : (`DWC_NO_OF_BYTES/2)/2;
    `else
      localparam pNUM_DRAM_PER_RANK = (`DWC_NO_OF_BYTES/2     == 0) ? 1 : `DWC_NO_OF_BYTES/2;
    `endif 
  `elsif SDRAMx32
    `ifdef DWC_USE_SHARED_AC_TB
      localparam pNUM_DRAM_PER_RANK = ((`DWC_NO_OF_BYTES/4)/2 == 0) ? 1 : (`DWC_NO_OF_BYTES/4)/2;      
    `else
      localparam pNUM_DRAM_PER_RANK = (`DWC_NO_OF_BYTES/4     == 0) ? 1 : `DWC_NO_OF_BYTES/4;
    `endif      
  `elsif SDRAMx8
    `ifdef DWC_USE_SHARED_AC_TB
      localparam pNUM_DRAM_PER_RANK = ((`DWC_NO_OF_BYTES)/2   == 0 )? 1 : (`DWC_NO_OF_BYTES)/2;
    `else
      localparam pNUM_DRAM_PER_RANK = `DWC_NO_OF_BYTES;
    `endif
  `else // SDRAMx4
    `ifdef DWC_USE_SHARED_AC_TB
      // the bytes number should be integer for each channel
      //in channel 0 , the number of ranks is equal to number of bytes -1 when bytes have odd num, in channel 1, the pNUM_DRAM_PER_RANK = `DWC_NO_OF_BYTES +1
      localparam pNUM_DRAM_PER_RANK = (`DWC_NO_OF_DIMMS%2 == 0 ) ? ((`DWC_NO_OF_BYTES/2)*2) : (((`DWC_NO_OF_BYTES/2)+(`DWC_NO_OF_BYTES%2))*2);
    `else
      localparam pNUM_DRAM_PER_RANK = `DWC_NO_OF_BYTES * 2;
    `endif
  `endif
  localparam pNUM_BYTES_PER_DRAM = `DWC_NO_OF_BYTES/pNUM_DRAM_PER_RANK;

  wire [`DWC_ADDR_WIDTH 
                  - 1 : 0] dbg_dram_address            [pNO_OF_LRANKS - 1 : 0][pNUM_DRAM_PER_RANK - 1 : 0];
  wire [`DWC_PHY_BG_WIDTH + `DWC_PHY_BA_WIDTH
                  - 1 : 0] dbg_dram_bank               [pNO_OF_LRANKS - 1 : 0][pNUM_DRAM_PER_RANK - 1 : 0];
  wire [5         - 1 : 0] dbg_dram_ddr4_cmd           [pNO_OF_LRANKS - 1 : 0][pNUM_DRAM_PER_RANK - 1 : 0];
  wire                     dbg_dram_cs_n               [pNO_OF_LRANKS - 1 : 0][pNUM_DRAM_PER_RANK - 1 : 0];
  wire                     dbg_dram_ck_c               [pNO_OF_LRANKS - 1 : 0][pNUM_DRAM_PER_RANK - 1 : 0];
  wire                     dbg_dram_cmd_PRE            [pNO_OF_LRANKS - 1 : 0][pNUM_DRAM_PER_RANK - 1 : 0];
  wire                     dbg_dram_cmd_ACT            [pNO_OF_LRANKS - 1 : 0][pNUM_DRAM_PER_RANK - 1 : 0];
  wire                     dbg_dram_cmd_MRS            [pNO_OF_LRANKS - 1 : 0][pNUM_DRAM_PER_RANK - 1 : 0];
  wire                     dbg_dram_cmd_REF            [pNO_OF_LRANKS - 1 : 0][pNUM_DRAM_PER_RANK - 1 : 0];
  wire                     dbg_dram_cmd_WR             [pNO_OF_LRANKS - 1 : 0][pNUM_DRAM_PER_RANK - 1 : 0];
  wire                     dbg_dram_cmd_RD             [pNO_OF_LRANKS - 1 : 0][pNUM_DRAM_PER_RANK - 1 : 0];
  wire                     dbg_dram_cmd_NOP            [pNO_OF_LRANKS - 1 : 0][pNUM_DRAM_PER_RANK - 1 : 0];
  wire                     dbg_dram_cmd_DES            [pNO_OF_LRANKS - 1 : 0][pNUM_DRAM_PER_RANK - 1 : 0];
  reg  [3         - 1 : 0] dbg_dram_MR_num             [pNO_OF_LRANKS - 1 : 0][pNUM_DRAM_PER_RANK - 1 : 0];
  reg  [(8 * 100) - 1 : 0] dbg_dram_MRS_decode_fields  [pNO_OF_LRANKS - 1 : 0][pNUM_DRAM_PER_RANK - 1 : 0][12 - 1 : 0];
  wire [(pNUM_BYTES_PER_DRAM * 8) - 1 : 0] dbg_dram_dq [pNO_OF_LRANKS - 1 : 0][pNUM_DRAM_PER_RANK - 1 : 0];
  wire [ pNUM_BYTES_PER_DRAM      - 1 : 0] dbg_dram_dqs[pNO_OF_LRANKS - 1 : 0][pNUM_DRAM_PER_RANK - 1 : 0];


  generate
    genvar gv_dx_idx;
    for (dwc_dim = 0; dwc_dim < `DWC_NO_OF_DIMMS; dwc_dim = dwc_dim + 1) begin : proc_dbg_dram
    for (dwc_rnk = 0; dwc_rnk < `DWC_RANKS_PER_DIMM; dwc_rnk = dwc_rnk + 1) begin : proc_dbg_dram_2
      for (gv_dx_idx = 0; gv_dx_idx < pNUM_DRAM_PER_RANK; gv_dx_idx = gv_dx_idx + 1) begin
        `ifdef DDR4
          `ifdef ELPIDA_DDR
            `ifdef SDRAMx16
            assign dbg_dram_dqs  [dwc_dim+dwc_rnk][gv_dx_idx] = {  `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).dqsu_t
                                                             , `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).dqsl_t
                                                            };
            `else
            assign dbg_dram_dqs  [dwc_dim+dwc_rnk][gv_dx_idx] =    `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).dqsl_t;
            `endif // `ifdef SDRAMx16
          `else
            assign dbg_dram_dqs  [dwc_dim+dwc_rnk][gv_dx_idx] = {  `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).dqs};
          `endif // `ifdef ELPIDA_DDR                      
        `endif // `ifdef DDR4

                      
        assign dbg_dram_dq     [dwc_dim+dwc_rnk][gv_dx_idx] = `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).dq;
        assign dbg_dram_cs_n   [dwc_dim+dwc_rnk][gv_dx_idx] = `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).cs_n;

        `ifdef DDR4
          `ifdef ELPIDA_DDR
          assign dbg_dram_address[dwc_dim+dwc_rnk][gv_dx_idx] = `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a;
          assign dbg_dram_ck_c   [dwc_dim+dwc_rnk][gv_dx_idx] = `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).ck_c;
          `else                     
          assign dbg_dram_address[dwc_dim+dwc_rnk][gv_dx_idx] = `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).addr;
          assign dbg_dram_ck_c   [dwc_dim+dwc_rnk][gv_dx_idx] = `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).ck_n;
          `endif // `ifdef ELPIDA_DDR
          assign dbg_dram_bank[dwc_dim+dwc_rnk][gv_dx_idx] = {  `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).bg
                                                          , `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).ba
                                                         };
          `ifdef ELPIDA_DDR 
          assign dbg_dram_ddr4_cmd[dwc_dim]
                                  [gv_dx_idx]   = { `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).cs_n
                                                   , `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).act_n  // act_n
                                                   , `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[16]  // ras_n
                                                   , `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[15]  // cas_n
                                                   , `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[14]  // we_n
                                                  };
          `else
            assign dbg_dram_ddr4_cmd[dwc_dim]
                                    [gv_dx_idx] = { `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).cs_n
                                                   ,`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).ras_n
                                                   ,`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).cas_n
                                                   ,`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).we_n
                                                  };  
          `endif // `ifdef ELPIDA_DDR
                      
          assign dbg_dram_cmd_MRS[dwc_dim+dwc_rnk][gv_dx_idx] = (dbg_dram_ddr4_cmd[dwc_dim+dwc_rnk][gv_dx_idx][4:0] == 5'b0_1000);
          assign dbg_dram_cmd_PRE[dwc_dim+dwc_rnk][gv_dx_idx] = (dbg_dram_ddr4_cmd[dwc_dim+dwc_rnk][gv_dx_idx][4:0] == 5'b0_1010);
          assign dbg_dram_cmd_ACT[dwc_dim+dwc_rnk][gv_dx_idx] = (dbg_dram_ddr4_cmd[dwc_dim+dwc_rnk][gv_dx_idx][4:3] == 2'b0_0);
          assign dbg_dram_cmd_MRS[dwc_dim+dwc_rnk][gv_dx_idx] = (dbg_dram_ddr4_cmd[dwc_dim+dwc_rnk][gv_dx_idx][4:0] == 5'b0_1000);
          assign dbg_dram_cmd_REF[dwc_dim+dwc_rnk][gv_dx_idx] = (dbg_dram_ddr4_cmd[dwc_dim+dwc_rnk][gv_dx_idx][4:0] == 5'b0_1001);
          assign dbg_dram_cmd_WR [dwc_dim+dwc_rnk][gv_dx_idx] = (dbg_dram_ddr4_cmd[dwc_dim+dwc_rnk][gv_dx_idx][4:0] == 5'b0_1100);
          assign dbg_dram_cmd_RD [dwc_dim+dwc_rnk][gv_dx_idx] = (dbg_dram_ddr4_cmd[dwc_dim+dwc_rnk][gv_dx_idx][4:0] == 5'b0_1101);
          assign dbg_dram_cmd_NOP[dwc_dim+dwc_rnk][gv_dx_idx] = (dbg_dram_ddr4_cmd[dwc_dim+dwc_rnk][gv_dx_idx][4:0] == 5'b0_0111);
          assign dbg_dram_cmd_DES[dwc_dim+dwc_rnk][gv_dx_idx] = (dbg_dram_ddr4_cmd[dwc_dim+dwc_rnk][gv_dx_idx][3]   == 1'b1);

          always @* begin : proc_dbg_dram_MR_num
            if (dbg_dram_cmd_MRS[dwc_dim+dwc_rnk][gv_dx_idx] == 1'b1) 
              dbg_dram_MR_num[dwc_dim+dwc_rnk][gv_dx_idx] = {  `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).bg[0]
                                                         , `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).ba[1:0]
                                                        };
            else
              dbg_dram_MR_num[dwc_dim+dwc_rnk][gv_dx_idx] = 3'bzzz;
          end
        `else
          //dbg_dram_bank[dwc_dim+dwc_rnk][gv_dx_idx] = `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).ba;

        `endif // `ifdef DDR4

      `ifdef ELPIDA_DDR
        `ifndef LPDDRX
        //// Decode MRS commands
        always @* begin : proc_dbg_dram_mrs_fields
          integer mrs_f_idx;
      
          if (dbg_dram_cmd_MRS[dwc_dim+dwc_rnk][gv_dx_idx] == 1'b1) begin
            for (mrs_f_idx = 0; mrs_f_idx < 12; mrs_f_idx = mrs_f_idx + 1)
              dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][mrs_f_idx] = "";
            case (dbg_dram_MR_num[dwc_dim+dwc_rnk][gv_dx_idx])
              3'd0 : begin
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][0] = (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[1:0] == 2'b00) ? "BL: 8 (fixed)"             :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[1:0] == 2'b01) ? "BL: BC4 or 8 (on-the-fly)" :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[1:0] == 2'b10) ? "BL: BC4 (fixed)"           :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[1:0] == 2'b11) ? "BL: Reserved"              : 
                                                                                                                                              "Unknown";
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][1] = (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[3]   == 1'b0) ? "Read Burst Type: Nibble Sequential" :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[3]   == 1'b1) ? "Read Burst Type: Interleave"        :
                                                                                                                                             "Unknown";
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][2] = (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[7]   == 1'b0) ? "Mode: Normal" :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[7]   == 1'b1) ? "Mode: Test"   :
                                                                                                                                             "Unknown";
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][3] = (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[8]   == 1'b0) ? "DLL Reset: No"  :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[8]   == 1'b1) ? "DLL Reset: Yes" :
                                                                                                                                             "Unknown";
          `ifdef DDR4
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][4] = ({`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[6], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[5], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[4], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2]} == 4'b0000) ? "CAS Latency: 9"        :
                                                                                   ({`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[6], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[5], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[4], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2]} == 4'b0001) ? "CAS Latency: 10"       :
                                                                                   ({`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[6], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[5], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[4], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2]} == 4'b0010) ? "CAS Latency: 11"       :
                                                                                   ({`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[6], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[5], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[4], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2]} == 4'b0011) ? "CAS Latency: 12"       :
                                                                                   ({`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[6], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[5], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[4], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2]} == 4'b0100) ? "CAS Latency: 13"       :
                                                                                   ({`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[6], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[5], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[4], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2]} == 4'b0101) ? "CAS Latency: 14"       :
                                                                                   ({`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[6], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[5], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[4], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2]} == 4'b0110) ? "CAS Latency: 15"       :
                                                                                   ({`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[6], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[5], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[4], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2]} == 4'b0111) ? "CAS Latency: 16"       :
                                                                                   ({`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[6], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[5], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[4], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2]} == 4'b1000) ? "CAS Latency: 18"       :
                                                                                   ({`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[6], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[5], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[4], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2]} == 4'b1001) ? "CAS Latency: 20"       :
                                                                                   ({`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[6], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[5], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[4], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2]} == 4'b1010) ? "CAS Latency: 22"       :
                                                                                   ({`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[6], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[5], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[4], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2]} == 4'b1011) ? "CAS Latency: 24"       :
                                                                                   ({`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[6], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[5], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[4], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2]} == 4'b1100) ? "CAS Latency: Reserved" :
                                                                                   ({`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[6], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[5], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[4], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2]} == 4'b1101) ? "CAS Latency: 17"       :
                                                                                   ({`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[6], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[5], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[4], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2]} == 4'b1110) ? "CAS Latency: 19"       :
                                                                                   ({`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[6], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[5], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[4], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2]} == 4'b1111) ? "CAS Latency: 21"       :
                                                                                                                                                                                                                                                                                       "Unknown";
          `else
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][4] = ({`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[6], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[5], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[4], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2]} == 4'b0000) ? "CAS Latency: Reserved" :
                                                                                   ({`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[6], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[5], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[4], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2]} == 4'b0010) ? "CAS Latency: 5"        :
                                                                                   ({`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[6], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[5], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[4], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2]} == 4'b0100) ? "CAS Latency: 6"        :
                                                                                   ({`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[6], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[5], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[4], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2]} == 4'b0110) ? "CAS Latency: 7"        :
                                                                                   ({`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[6], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[5], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[4], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2]} == 4'b1000) ? "CAS Latency: 8"        :
                                                                                   ({`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[6], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[5], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[4], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2]} == 4'b1010) ? "CAS Latency: 9"        :
                                                                                   ({`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[6], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[5], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[4], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2]} == 4'b1100) ? "CAS Latency: 10"       :
                                                                                   ({`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[6], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[5], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[4], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2]} == 4'b1110) ? "CAS Latency: 11"       :
                                                                                   ({`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[6], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[5], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[4], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2]} == 4'b0001) ? "CAS Latency: 12"       :
                                                                                   ({`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[6], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[5], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[4], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2]} == 4'b0011) ? "CAS Latency: 13"       :
                                                                                   ({`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[6], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[5], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[4], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2]} == 4'b0101) ? "CAS Latency: 14"       :
                                                                                   ({`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[6], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[5], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[4], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2]} == 4'b0111) ? "CAS Latency: 15"       :
                                                                                   ({`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[6], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[5], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[4], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2]} == 4'b1001) ? "CAS Latency: 16"       :
                                                                                   ({`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[6], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[5], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[4], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2]} == 4'b1011) ? "CAS Latency: Reserved" :
                                                                                   ({`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[6], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[5], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[4], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2]} == 4'b1101) ? "CAS Latency: Reserved" :
                                                                                   ({`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[6], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[5], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[4], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2]} == 4'b1111) ? "CAS Latency: Reserved" :
                                                                                                                                                                                                                                                                                       "Unknown";
          `endif //`ifdef DDR4 
          `ifdef DDR4
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][5] = (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[pDBG_A_BIT_11:9] == 3'b000) ? "Write Recovery: 10"       :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[pDBG_A_BIT_11:9] == 3'b001) ? "Write Recovery: 12"       :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[pDBG_A_BIT_11:9] == 3'b010) ? "Write Recovery: 14"       :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[pDBG_A_BIT_11:9] == 3'b011) ? "Write Recovery: 16"       :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[pDBG_A_BIT_11:9] == 3'b100) ? "Write Recovery: 18"       :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[pDBG_A_BIT_11:9] == 3'b101) ? "Write Recovery: 20"       :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[pDBG_A_BIT_11:9] == 3'b110) ? "Write Recovery: 24"       :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[pDBG_A_BIT_11:9] == 3'b111) ? "Write Recovery: Reserved" :
                                                                                                                                                           "Unknown";
          `else
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][5] = (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[pDBG_A_BIT_11:9] == 3'b000) ? "Write Recovery: 16" :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[pDBG_A_BIT_11:9] == 3'b001) ? "Write Recovery: 5"  :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[pDBG_A_BIT_11:9] == 3'b010) ? "Write Recovery: 6"  :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[pDBG_A_BIT_11:9] == 3'b011) ? "Write Recovery: 7"  :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[pDBG_A_BIT_11:9] == 3'b100) ? "Write Recovery: 8"  :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[pDBG_A_BIT_11:9] == 3'b101) ? "Write Recovery: 10" :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[pDBG_A_BIT_11:9] == 3'b110) ? "Write Recovery: 12" :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[pDBG_A_BIT_11:9] == 3'b111) ? "Write Recovery: 14" :
                                                                                                                                                           "Unknown";
          `endif //`ifdef DDR4 
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][6] = (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[pDBG_A_BIT_12]   == 1'b0) ? "DLL Control: Slow Exit (DLL off)"  :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[pDBG_A_BIT_12]   == 1'b1) ? "DLL Control: Fast Exit (DLL on)" :
                                                                                                                                                         "Unknown";
         
                     end
              3'd1 : begin
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][0] = (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[0] == 1'b0) ? "DLL Enable"  :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[0] == 1'b1) ? "DLL Disable" :
                                                                                                                                           "Unknown";
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][1] = ({`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[5], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[1]} == 2'b00) ? "Output Driver Zcntl: RZQ/6"   :
                                                                                   ({`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[5], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[1]} == 2'b01) ? "Output Driver Zcntl: RZQ/7"   :
                                                                                   ({`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[5], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[1]} == 2'b10) ? "Output Driver Zcntl: RZQ/TBD" :
                                                                                   ({`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[5], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[1]} == 2'b11) ? "Output Driver Zcntl: RZQ/TBD" :
                                                                                                                                                                                           "Unknown";
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][2] = ({`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[9], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[6], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2]} == 3'b000) ? "Rtt_Nom: Disabled" :
                                                                                   ({`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[9], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[6], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2]} == 3'b001) ? "Rtt_Nom: RZQ/4"    :
                                                                                   ({`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[9], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[6], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2]} == 3'b010) ? "Rtt_Nom: RZQ/2"    :
                                                                                   ({`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[9], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[6], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2]} == 3'b011) ? "Rtt_Nom: RZQ/6"    :
                                                                                   ({`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[9], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[6], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2]} == 3'b100) ? "Rtt_Nom: RZQ/12"   :
                                                                                   ({`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[9], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[6], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2]} == 3'b101) ? "Rtt_Nom: RZQ/8"    :
                                                                                   ({`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[9], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[6], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2]} == 3'b110) ? "Rtt_Nom: Reserved" :
                                                                                   ({`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[9], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[6], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2]} == 3'b111) ? "Rtt_Nom: Reserved" :
                                                                                                                                                                                                                                         "Unknown";
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][3] = ({`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[4], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[3]} == 2'b00) ? "AL: 0"         :
                                                                                   ({`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[4], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[3]} == 2'b01) ? "AL: CL - 1"    :
                                                                                   ({`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[4], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[3]} == 2'b10) ? "AL: CL - 2"    :
                                                                                   ({`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[4], `DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[3]} == 2'b11) ? "AL: Reserved " :
                                                                                                                                                                                           "Unknown";
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][4] = (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[7]  == 1'b1) ? "Write Leveling Enable"  :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[7]  == 1'b0) ? "Write Leveling Disable" :
                                                                                                                                            "Unknown";
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][5] = (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[pDBG_A_BIT_11] == 1'b0) ? "TDQS Disable"  :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[pDBG_A_BIT_11] == 1'b1) ? "TDQS Enable" :
                                                                                                                                                       "Unknown";
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][6] = (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[pDBG_A_BIT_12] == 1'b0) ? "Output buffer Enable"  :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[pDBG_A_BIT_12] == 1'b1) ? "Output buffer Disable" :
                                                                                                                                                       "Unknown";
      
                     end
              3'd2 : begin
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][0] = (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2:0] == 3'b000) ? "Partial Array Self-Refresh: Full Array"   :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2:0] == 3'b001) ? "Partial Array Self-Refresh: Half Array (000, ...)"   :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2:0] == 3'b010) ? "Partial Array Self-Refresh: Quarter Array (000, 001)"   :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2:0] == 3'b011) ? "Partial Array Self-Refresh: 1/8th Array (000)"   :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2:0] == 3'b100) ? "Partial Array Self-Refresh: 3/4th Array (010, ...)"   :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2:0] == 3'b101) ? "Partial Array Self-Refresh: Half Array (100, ...)"   :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2:0] == 3'b110) ? "Partial Array Self-Refresh: Quarter Array (110, 111)"   :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2:0] == 3'b111) ? "Partial Array Self-Refresh: 1/8th Array (111)"   :
                                                                                                                                               "Unknown";
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][1] = (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[5:3] == 3'b000) ? "CWL: 5"  :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[5:3] == 3'b001) ? "CWL: 6"  :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[5:3] == 3'b010) ? "CWL: 7"  :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[5:3] == 3'b011) ? "CWL: 8"  :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[5:3] == 3'b100) ? "CWL: 9"  :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[5:3] == 3'b101) ? "CWL: 10" :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[5:3] == 3'b110) ? "CWL: 11" :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[5:3] == 3'b111) ? "CWL: 12" :
                                                                                                                                               "Unknown";
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][2] = (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[6] == 1'b0) ? "Auto Self-Refresh: Manual"  :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[6] == 1'b1) ? "Auto Self-Refresh: Enable"  :
                                                                                                                                           "Unknown";
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][3] = (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[7] == 1'b0) ? "Self-Refresh Temp Range: Normal"   :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[7] == 1'b1) ? "Self-Refresh Temp Range: Extended" :
                                                                                                                                           "Unknown";
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][4] = (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[pDBG_A_BIT_10:9] == 2'b00) ? "Rtt_WR: Dynamic ODT" :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[pDBG_A_BIT_10:9] == 2'b01) ? "Rtt_WR: RZQ/4"       :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[pDBG_A_BIT_10:9] == 2'b10) ? "Rtt_WR: RZQ/2"       :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[pDBG_A_BIT_10:9] == 2'b11) ? "Rtt_WR: Reserved"    :
                                                                                                                                                          "Unknown";
                     end
              3'd3 : begin
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][0] = (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[1:0] == 2'b00) ? "MPR: Predefined pattern" :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[1:0] == 2'b00) ? "MPR: RFU"                :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[1:0] == 2'b10) ? "MPR: RFU"                :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[1:0] == 2'b11) ? "MPR: RFU"                :
                                                                                                                                              "Unknown";
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][1] = (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2]   == 1'b0)  ? "MPR: Normal operation"   :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2]   == 1'b1)  ? "MPR: Dataflow from MPR"  :
                                                                                                                                              "Unknown";
          `ifdef DDR4
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][2] = (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[3]   == 1'b0)  ? "Geardown Mode: 1/2 Rate" :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[3]   == 1'b1)  ? "Geardown Mode: 1/4 Rate" :
                                                                                                                                              "Unknown";
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][3] = (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[4]   == 1'b0)  ? "Per DRAM Addressability: Disable" :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[4]   == 1'b1)  ? "Per DRAM Addressability: Enable"  :
                                                                                                                                              "Unknown";
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][4] = (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[5]   == 1'b0)  ? "Temp Sensor Readout: Disable" :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[5]   == 1'b1)  ? "Temp Sensor Readout: Enable"  :
                                                                                                                                              "Unknown";
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][5] = (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[8:6] == 3'b000) ? "Fine Granularity Refresh Mode: Normal (Fixed 1x)"    :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[8:6] == 3'b001) ? "Fine Granularity Refresh Mode: Fixed 2x"             :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[8:6] == 3'b010) ? "Fine Granularity Refresh Mode: Fixed 4x"             :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[8:6] == 3'b011) ? "Fine Granularity Refresh Mode: Reserved"             :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[8:6] == 3'b100) ? "Fine Granularity Refresh Mode: Reserved"             :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[8:6] == 3'b101) ? "Fine Granularity Refresh Mode: Enable on-the-fly 2x" :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[8:6] == 3'b110) ? "Fine Granularity Refresh Mode: Enable on-the-fly 4x" :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[8:6] == 3'b111) ? "Fine Granularity Refresh Mode: Reserved"             :
                                                                                                                                               "Unknown";
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][6] = (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[10:9] == 2'b00) ? "Write CMD Latency (DM Enabled): 4nCK" :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[10:9] == 2'b01) ? "Write CMD Latency (DM Enabled): 5nCK" :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[10:9] == 2'b10) ? "Write CMD Latency (DM Enabled): 6nCK" :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[10:9] == 2'b11) ? "Write CMD Latency (DM Enabled): RFU"  :
                                                                                                                                               "Unknown";
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][7] = (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[12:11] == 2'b00) ? "MPR Read Format: Serial"    :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[12:11] == 2'b01) ? "MPR Read Format: Parallel"  :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[12:11] == 2'b10) ? "MPR Read Format: Staggered" :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[12:11] == 2'b11) ? "MPR Read Format: Reserved"  :
                                                                                                                                                "Unknown";
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][8] = (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[13]    == 1'b0)  ? "RFU" :
                                                                                                                                                "Unknown";
          `endif //`ifdef DDR4 
                     end
              3'd4 : begin
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][0]  = (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[0] == 1'b0) ? "RFU" :
                                                                                                                                            "Unknown";
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][1]  = (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[1] == 1'b0) ? "Maximum Power Down Mode: Disable" :
                                                                                    (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[1] == 1'b1) ? "Maximum Power Down Mode: Enable"  :
                                                                                                                                            "Unknown";
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][2]  = (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2] == 1'b0) ? "Temperature Controlled Refresh Range: Normal"   :
                                                                                    (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2] == 1'b1) ? "Temperature Controlled Refresh Range: Extended" :
                                                                                                                                            "Unknown";
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][3]  = (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[3] == 1'b0) ? "Temperature Controlled Refresh Mode: Disable" :
                                                                                    (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[3] == 1'b1) ? "Temperature Controlled Refresh Mode: Enable"  :
                                                                                                                                            "Unknown";
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][4]  = (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[4] == 1'b0) ? "Internal Vref Monitor: Disable" :
                                                                                    (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[4] == 1'b1) ? "Internal Vref Monitor: Enable"  :
                                                                                                                                            "Unknown";
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][5]  = (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[5] == 1'b0) ? "RFU" :
                                                                                                                                            "Unknown";
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][6]  = (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[8:6] == 3'b000) ? "CS to CMD/ADDR Latency Mode: Disable"  :
                                                                                    (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[8:6] == 3'b001) ? "CS to CMD/ADDR Latency Mode: 3"        :
                                                                                    (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[8:6] == 3'b010) ? "CS to CMD/ADDR Latency Mode: 4"        :
                                                                                    (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[8:6] == 3'b011) ? "CS to CMD/ADDR Latency Mode: 5"        :
                                                                                    (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[8:6] == 3'b100) ? "CS to CMD/ADDR Latency Mode: 6"        :
                                                                                    (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[8:6] == 3'b101) ? "CS to CMD/ADDR Latency Mode: 8"        :
                                                                                    (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[8:6] == 3'b110) ? "CS to CMD/ADDR Latency Mode: Reserved" :
                                                                                    (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[8:6] == 3'b111) ? "CS to CMD/ADDR Latency Mode: Reserved" :
                                                                                                                                                "Unknown";
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][7]  = (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[9]  == 1'b0) ? "Self Refresh Abort: Disable" :
                                                                                    (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[9]  == 1'b1) ? "Self Refresh Abort: Enable"  :
                                                                                                                                             "Unknown";
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][8]  = (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[10] == 1'b0) ? "Read Preamble Training Mode: Disable" :
                                                                                    (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[10] == 1'b1) ? "Read Preamble Training Mode: Enable"  :
                                                                                                                                             "Unknown";
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][9]  = (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[11] == 1'b0) ? "Read Preamble: 1nCK" :
                                                                                    (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[11] == 1'b1) ? "Read Preamble: 2nCK" :
                                                                                                                                             "Unknown";
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][10] = (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[11] == 1'b0) ? "Write Preamble: 1nCK" :
                                                                                    (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[11] == 1'b1) ? "Write Preamble: 2nCK" :
                                                                                                                                             "Unknown";
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][11] = (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[13] == 1'b0) ? "RFU" :
                                                                                                                                             "Unknown";
                     end
              3'd5 : begin
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][0] = (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2:0] == 3'b000) ? "CA Parity Latency Mode: Disable"  :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2:0] == 3'b001) ? "CA Parity Latency Mode: 4"        :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2:0] == 3'b010) ? "CA Parity Latency Mode: 5"        :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2:0] == 3'b011) ? "CA Parity Latency Mode: 6"        :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2:0] == 3'b100) ? "CA Parity Latency Mode: 8"        :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2:0] == 3'b101) ? "CA Parity Latency Mode: Reserved" :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2:0] == 3'b110) ? "CA Parity Latency Mode: Reserved" :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[2:0] == 3'b111) ? "CA Parity Latency Mode: Reserved" :
                                                                                                                                              "Unknown";
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][1] = (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[3]   == 1'b0)  ? "CRC Error Clear: Clear"  :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[3]   == 1'b1)  ? "CRC Error Clear: Error"  :
                                                                                                                                              "Unknown";
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][2] = (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[4]   == 1'b0)  ? "C/A Parity Error Status: Clear"  :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[4]   == 1'b1)  ? "C/A Parity Error Status: Error"  :
                                                                                                                                              "Unknown";
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][3] = (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[5]   == 1'b0)  ? "ODT Input Buffer for Power Down: Disable" :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[5]   == 1'b1)  ? "ODT Input Buffer for Power Down: Enable"  :
                                                                                                                                              "Unknown";
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][4] = (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[8:6] == 3'b000) ? "RTT_PARK: Disable" :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[8:6] == 3'b000) ? "RTT_PARK: RZQ/4"   :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[8:6] == 3'b010) ? "RTT_PARK: RZQ/2"   :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[8:6] == 3'b011) ? "RTT_PARK: RZQ/6"   :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[8:6] == 3'b100) ? "RTT_PARK: RZQ/1"   :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[8:6] == 3'b101) ? "RTT_PARK: RZQ/5"   :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[8:6] == 3'b110) ? "RTT_PARK: RZQ/3"   :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[8:6] == 3'b111) ? "RTT_PARK: RZQ/7"   :
                                                                                                                                               "Unknown";
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][5] = (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[9]   == 1'b0)  ? "CA parity Persistent Error: Disable" :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[9]   == 1'b1)  ? "CA parity Persistent Error: Enable"  :
                                                                                                                                              "Unknown";
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][6] = (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[10]  == 1'b0)  ? "Data Mask: Disable" :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[10]  == 1'b1)  ? "Data Mask: Enable"  :
                                                                                                                                              "Unknown";
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][7] = (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[11]  == 1'b0)  ? "Write DBI: Disable" :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[11]  == 1'b1)  ? "Write DBI: Enable"  :
                                                                                                                                              "Unknown";
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][8] = (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[12]  == 1'b0)  ? "Read DBI: Disable" :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[12]  == 1'b1)  ? "Read DBI: Enable"  :
                                                                                                                                              "Unknown";
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][9] = (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[13]  == 1'b0)  ? "RFU"             :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[13]  == 1'b1)  ? "RFU: Must be 0"  :
                                                                                                                                              "Unknown";
                     end
              3'd6 : begin
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][0] = (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[5:0] >= 6'b110011) ? "Reserveed" :
                                                                                                                                                  "VrefDQ Training Value: TBD";
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][1] = (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[6]     == 1'b0)    ? "VrefDQ Training: Range 1" :
                                                                                                                                                  "VrefDQ Training: Range 2";
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][2] = (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[7]     == 1'b0)    ? "VrefDQ Training Disable" :
                                                                                                                                                  "VrefDQ Training Enable";
                       dbg_dram_MRS_decode_fields[dwc_dim+dwc_rnk][gv_dx_idx][3] = (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[12:10] == 3'b000)  ? "tCCD_L: 4" :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[12:10] == 3'b001)  ? "tCCD_L: 5" :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[12:10] == 3'b010)  ? "tCCD_L: 6" :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[12:10] == 3'b011)  ? "tCCD_L: 7" :
                                                                                   (`DRAM_MODEL(dwc_dim,dwc_rnk,gv_dx_idx).a[12:10] == 3'b100)  ? "tCCD_L: 8" :
                                                                                                                                                  "tCCD_L: Reserved";
                     end
              default : begin
                        end
            endcase
          end // if (dbg_dram_cmd_MRS[dwc_dim][gv_dx_idx] == 1'b1)
        end // block: proc_dbg_dram_mrs_fields
                      
        `endif //  `ifndef LPDDRX
      `endif //  `ifdef ELPIDA_DDR
      end // for (gv_dx_idx = 0; gv_dx_idx < pNUM_DRAM_PER_RANK; gv_dx_idx = gv_dx_idx + 1)
      end // for (gv_dx_idx = 0; gv_dx_idx < pNUM_DRAM_PER_RANK; gv_dx_idx = gv_dx_idx + 1)
    end // block: proc_dbg_dram    
  endgenerate

  initial begin
    dbg_phy_sdram_mr0_bl_otf = 0;
    for (rank_idx = 0; rank_idx < pNO_OF_PRANKS; rank_idx = rank_idx + 1)
      dbg_phy_sdram_mr3_cmd_lat[rank_idx] = 0;
  end

`ifdef DWC_AC_CS_USE    
  always @* begin
    dbg_phy_sdram_cs_n_pn[0] = `PHY.cs_n;
  end
`endif  

`ifdef DWC_DEBUGGING_SIGNALS
  always @(posedge `PHY.ck[0]) begin
    // Keep pipelined copies of cs_n
    for (cidx = 1; cidx < pDDR4_CMD_LAT_MAX; cidx = cidx + 1)
      dbg_phy_sdram_cs_n_pn[cidx] <= dbg_phy_sdram_cs_n_pn[cidx - 1];
    for (rank_idx = 0; rank_idx < pNO_OF_CSNS; rank_idx = rank_idx + 1) begin
      // Decode on-the-fly burst length setting to any DRAM
`ifdef DWC_AC_CS_USE    
      if (    (`PHY.cs_n[rank_idx] == 1'b0)            // Chip select
`else
      if ( 1'b1
`endif  
`ifdef DDR4
           && (dbg_phy_sdram_ddr4_cmd[3:0] == 4'b1000)  // MR write
`else
           && (dbg_phy_sdram_cmd     [2:0] == 3'b000)  // MR write
`endif
`ifdef DWC_AC_BG_USE
`ifdef DWC_AC_BA_USE    
           && ({`PHY.bg[0], `PHY.ba[1:0]} == 3'd0)     // MR0
`else 
           && 1'b1
`endif   // DWC_AC_BA_USE
`else 
           && 1'b1
`endif // DWC_AC_BG_USE   
         )
        dbg_phy_sdram_mr0_bl_otf[rank_idx] = (`PHY.a[1:0] == 2'b10);
      // Decode command latency
`ifdef DWC_AC_CS_USE    
      if (    (`PHY.cs_n[rank_idx] == 1'b0)             // Chip select
`else
      if ( 1'b1
`endif  
           && (dbg_phy_sdram_ddr4_cmd[3:0] == 4'b1000)  // MR write
`ifdef DWC_AC_BG_USE
`ifdef DWC_AC_BA_USE    
           && ({`PHY.bg[0], `PHY.ba[1:0]} == 3'd4)      // MR4
`else 
           && 1'b1
`endif   // DWC_AC_BA_USE
`else 
           && 1'b1
`endif // DWC_AC_BG_USE   
`ifdef DWC_AC_BG_USE
           && ((`DWC_RDIMM == 1) && (`PHY.bg[1] == 1'b0)) // Ignore B-side access for now since the bits may be inverted
`else 
           && 1'b1
`endif   // DWC_AC_BA_USE
         )
        dbg_phy_sdram_mr3_cmd_lat[rank_idx] = (`PHY.a[8:6] == 3'b101) ? 'd8 :
                                              (`PHY.a[8:6] == 3'b000) ? 'd0 :
                                              (`PHY.a[8:6] == 3'b110) ? 'hX :
                                              (`PHY.a[8:6] == 3'b111) ? 'hX : `PHY.a[8:6] + 3'd2;
    end
  end
`endif

`ifdef DDR4  // {BC_n, a[10]/AP, CS_n, ACT_n, RAS_n, CAS_n, WE_n}
  assign dbg_phy_sdram_cmd_PRE = (dbg_phy_sdram_ddr4_cmd[4:0] == 5'b0_1010);
  assign dbg_phy_sdram_cmd_ACT = (dbg_phy_sdram_ddr4_cmd[4:3] == 2'b0_0);
  assign dbg_phy_sdram_cmd_MRS = (dbg_phy_sdram_ddr4_cmd[4:0] == 5'b0_1000);
  assign dbg_phy_sdram_cmd_REF = (dbg_phy_sdram_ddr4_cmd[4:0] == 5'b0_1001);
  assign dbg_phy_sdram_cmd_WR  = (dbg_phy_sdram_ddr4_cmd[4:0] == 5'b0_1100);
  assign dbg_phy_sdram_cmd_RD  = (dbg_phy_sdram_ddr4_cmd[4:0] == 5'b0_1101);
  assign dbg_phy_sdram_cmd_NOP = (dbg_phy_sdram_ddr4_cmd[4:0] == 5'b0_0111);
  assign dbg_phy_sdram_cmd_DES = (dbg_phy_sdram_ddr4_cmd[3]   == 1'b1);
`else       // {BC_n, a[10]/AP, CS_n,         RAS_n, CAS_n, WE_n}
  assign dbg_phy_sdram_cmd_PRE  = (dbg_phy_sdram_cmd[3:0] == 4'b0010);
  assign dbg_phy_sdram_cmd_ACT  = (dbg_phy_sdram_cmd[3:0] == 4'b0011);
  assign dbg_phy_sdram_cmd_MRS  = (dbg_phy_sdram_cmd[3:0] == 4'b0000);
  assign dbg_phy_sdram_cmd_REF  = (dbg_phy_sdram_cmd[3:0] == 4'b0001);
  assign dbg_phy_sdram_cmd_WR   = (dbg_phy_sdram_cmd[3:0] == 4'b0100);
  assign dbg_phy_sdram_cmd_RD   = (dbg_phy_sdram_cmd[3:0] == 4'b0101);
  assign dbg_phy_sdram_cmd_NOP  = (dbg_phy_sdram_cmd[3:0] == 4'b0111);
  assign dbg_phy_sdram_cmd_DES  = (dbg_phy_sdram_cmd[3]   == 1'b1);
`endif

  // Decode rank
  event e_cs_n_negedge;

`ifdef DWC_AC_CS_USE    
  generate
    if (`DWC_PHY_CS_N_WIDTH == 4) begin : proc_dbg_rank_addr
      always @(negedge `PHY.cs_n[3], negedge `PHY.cs_n[2], negedge `PHY.cs_n[1], negedge `PHY.cs_n[0])
        -> e_cs_n_negedge;
    end
    else if (`DWC_PHY_CS_N_WIDTH == 3) begin : proc_dbg_rank_addr
      always @(negedge `PHY.cs_n[2], negedge `PHY.cs_n[1], negedge `PHY.cs_n[0])
        -> e_cs_n_negedge;
    end
    else if (`DWC_PHY_CS_N_WIDTH == 2) begin : proc_dbg_rank_addr
      always @(negedge `PHY.cs_n[1], negedge `PHY.cs_n[0])
        -> e_cs_n_negedge;
    end
    else begin : proc_dbg_rank_addr
      always @(negedge `PHY.cs_n)
        -> e_cs_n_negedge;
    end
  endgenerate
`endif  

  always @(e_cs_n_negedge) begin
    dbg_phy_sdram_rank_addr = "";
    for (rank_idx = 0; rank_idx < `DWC_NO_OF_RANKS; rank_idx = rank_idx + 1) begin
      case (rank_idx)
        0 : rank_idx_str = "0";
        1 : rank_idx_str = "1";
        2 : rank_idx_str = "2";
        3 : rank_idx_str = "3";
        default: rank_idx_str = "-";
      endcase
`ifdef DWC_AC_CS_USE    
      if (`PHY.cs_n[rank_idx] == 1'b0)
        $sformat(dbg_phy_sdram_rank_addr, "%0s%0s", dbg_phy_sdram_rank_addr, rank_idx_str);
`endif  
    end
  end

  // Track single bank precharge
`ifdef LPDDRX
  assign dbg_phy_sdram_cmd_PRE_1BANK = dbg_phy_sdram_cmd_PRE;
`else
  assign dbg_phy_sdram_cmd_PRE_1BANK = dbg_phy_sdram_cmd_PRE && (`PHY.a[10] == 1'b0);
`endif

  // Bank address
`ifdef DWC_AC_BA_USE
  always @(posedge dbg_phy_sdram_cmd_PRE_1BANK, posedge dbg_phy_sdram_cmd_ACT, posedge dbg_phy_sdram_cmd_WR, posedge dbg_phy_sdram_cmd_RD) begin : proc_dbg_bank_addr
      `ifdef DDR4
      `ifdef DWC_AC_BG_USE
          dbg_phy_sdram_bank_addr = `PHY.ba;
          dbg_phy_sdram_bg_addr   = `PHY.bg;
      `endif
      `else
      `ifdef DWC_AC_BG_USE
        if (`DWC_BANK_WIDTH > 2)
          dbg_phy_sdram_bank_addr = {`PHY.bg[0], `PHY.ba};
        else 
      `endif
          dbg_phy_sdram_bank_addr = `PHY.ba;
      `endif
  end
`endif 

  // Row address available during Bank Activate command
  always @(posedge dbg_phy_sdram_cmd_ACT) begin : prov_dbg_row_addr
    `ifdef DDR4
      dbg_phy_sdram_row_addr = dbg_phy_sdram_ddr4_row_addr_bus[17 : 0];
    `else
      dbg_phy_sdram_row_addr = `PHY.a[pDBG_SDRAM_ROW_WIDTH - 1 : 0];
    `endif
  end

  // Track which mode register is being accessed
`ifdef DWC_AC_BA_USE
`ifdef DWC_AC_BG_USE
  always @* begin : proc_dbg_address
    `ifdef DDR4
      if (dbg_phy_sdram_cmd_MRS == 1'b1) dbg_phy_sdram_MR_num = {`PHY.bg[0], `PHY.ba[1:0]};
      else                               dbg_phy_sdram_MR_num = 3'bzzz;
    `else
      if (dbg_phy_sdram_cmd_MRS == 1'b1) dbg_phy_sdram_MR_num = {1'b0, `PHY.ba[1:0]};
      else                               dbg_phy_sdram_MR_num = 3'bzz;
    `endif
  end
`endif
`endif

  // Column address during Write or Read commands
`ifdef DDR4 
  always @(posedge dbg_phy_sdram_cmd_WR, posedge dbg_phy_sdram_cmd_RD)
    dbg_phy_sdram_col_addr = `PHY.a[9:0];
`else
  generate
    if (`SDRAM_COL_WIDTH == 12) begin : gen_dbg_col_addr
      always @(posedge dbg_phy_sdram_cmd_WR, posedge dbg_phy_sdram_cmd_RD)
        dbg_phy_sdram_col_addr = {`PHY.a[pDBG_A_BIT_13], `PHY.a[pDBG_A_BIT_11], `PHY.a[9:0]};
    end
    else if (`SDRAM_COL_WIDTH == 11) begin 
      always @(posedge dbg_phy_sdram_cmd_WR, posedge dbg_phy_sdram_cmd_RD)
        dbg_phy_sdram_col_addr = {`PHY.a[pDBG_A_BIT_11], `PHY.a[9:0]};
    end
    else begin 
      always @(posedge dbg_phy_sdram_cmd_WR, posedge dbg_phy_sdram_cmd_RD)
        dbg_phy_sdram_col_addr = {`PHY.a[9:0]};
    end
  endgenerate
`endif

  integer                             cmd_beat_idx;
  reg  [`DWC_PHY_ADDR_WIDTH  - 1 : 0] dbg_phy_ctl_a_beat        [4  - 1 : 0];  // 4 'beats' of commands
  reg  [8                    - 1 : 0] dbg_phy_ctl_ddr4_cmd_beat [4  - 1 : 0];  // 4 'beats' of commands
  reg  [pNO_OF_CSNS * 4      - 1 : 0] dbg_phy_ctl_cs_n_pn       [pDDR4_CMD_LAT_MAX - 1 : 0];
  reg  [7                    - 1 : 0] dbg_phy_ctl_ddr3_cmd_beat [4  - 1 : 0];  // 4 'beats' of commands

  always @* begin
    for (cmd_beat_idx = 0; cmd_beat_idx < 4; cmd_beat_idx = cmd_beat_idx + 1) begin
      dbg_phy_ctl_a_beat[cmd_beat_idx] = `PHY.ctl_a[(cmd_beat_idx * `DWC_PHY_ADDR_WIDTH) +: `DWC_PHY_ADDR_WIDTH];
    end
  end

`ifdef DDR4
  always @* begin
    dbg_phy_ctl_cs_n_pn[0] = `PHY.ctl_cs_n;
  end

  always @(posedge `PHY.ck[0]) begin
    // Keep pipelined copies of cs_n
    for (cidx = 1; cidx < pDDR4_CMD_LAT_MAX; cidx = cidx + 1)
      dbg_phy_ctl_cs_n_pn[cidx] <= dbg_phy_ctl_cs_n_pn[cidx - 1];
  end

  always @* begin : proc_dbg_phy_ctl_ddr4_cmd
    for (cmd_beat_idx = 0; cmd_beat_idx < 4; cmd_beat_idx = cmd_beat_idx + 1) begin
      dbg_phy_ctl_ddr4_cmd_beat[cmd_beat_idx] = {  &dbg_phy_sdram_mr0_bl_otf
                                                 , `PHY.ctl_a[cmd_beat_idx * `DWC_PHY_ADDR_WIDTH + 12]
                                                 , `PHY.ctl_a[cmd_beat_idx * `DWC_PHY_ADDR_WIDTH + 10]
                                                 , (&(dbg_phy_ctl_cs_n_pn[dbg_phy_sdram_mr3_cmd_lat[0]][cmd_beat_idx * pNO_OF_CSNS +: pNO_OF_CSNS]))
                                                 , `PHY.ctl_act_n[cmd_beat_idx]
                                                 , `PHY.ctl_a[cmd_beat_idx * `DWC_PHY_ADDR_WIDTH + 16]
                                                 , `PHY.ctl_a[cmd_beat_idx * `DWC_PHY_ADDR_WIDTH + 15]
                                                 , `PHY.ctl_a[cmd_beat_idx * `DWC_PHY_ADDR_WIDTH + 14]
                                                };
    end
  end
`endif

`ifdef DDR3
  always @* begin : proc_dbg_phy_ctl_ddr3_cmd
    for (cmd_beat_idx = 0; cmd_beat_idx < 4; cmd_beat_idx = cmd_beat_idx + 1) begin
      dbg_phy_ctl_ddr3_cmd_beat[cmd_beat_idx] = {  &dbg_phy_sdram_mr0_bl_otf
                                                 , `PHY.ctl_a[cmd_beat_idx * `DWC_PHY_ADDR_WIDTH + 12]
                                                 , `PHY.ctl_a[cmd_beat_idx * `DWC_PHY_ADDR_WIDTH + 10]
                                                 , (&(`PHY.ctl_cs_n[cmd_beat_idx * pNO_OF_CSNS +: pNO_OF_CSNS]))
                                                 , `PHY.ctl_act_n[cmd_beat_idx]                          // ras_n
                                                 , `PHY.ctl_a[cmd_beat_idx * `DWC_PHY_ADDR_WIDTH + 17]  // cas_n
                                                 , `PHY.ctl_a[cmd_beat_idx * `DWC_PHY_ADDR_WIDTH + 16]  // we_n
                                                };
    end
  end
`endif

  //--------------------------------------------------------------------------//
  //  DDR4 RDIMM signals
  //--------------------------------------------------------------------------//

`ifdef DDR4
  wire [18                 - 1 : 0] dbg_ddr4rdimm_QA_addr [pNO_OF_PRANKS  - 1 : 0];
  wire [18                 - 1 : 0] dbg_ddr4rdimm_QB_addr [pNO_OF_PRANKS  - 1 : 0];
  wire [18                 - 1 : 0] dbg_ddr4rdimm_D_addr  [pNO_OF_PRANKS  - 1 : 0];
  wire [4                  - 1 : 0] dbg_ddr4rdimm_QA_bank [pNO_OF_PRANKS  - 1 : 0];
  wire [4                  - 1 : 0] dbg_ddr4rdimm_QB_bank [pNO_OF_PRANKS  - 1 : 0];
  wire [4                  - 1 : 0] dbg_ddr4rdimm_D_bank  [pNO_OF_PRANKS  - 1 : 0];
  wire [pNO_OF_PRANKS/2    - 1 : 0] dbg_ddr4rdimm_QA_cs_n [pNO_OF_PRANKS  - 1 : 0];
  wire [pNO_OF_PRANKS/2    - 1 : 0] dbg_ddr4rdimm_QB_cs_n [pNO_OF_PRANKS  - 1 : 0];
  wire [pNO_OF_PRANKS/2    - 1 : 0] dbg_ddr4rdimm_D_cs_n  [pNO_OF_PRANKS  - 1 : 0];
  wire [5                  - 1 : 0] dbg_ddr4rdimm_QA_cmd  [pNO_OF_PRANKS  - 1 : 0];
  wire [5                  - 1 : 0] dbg_ddr4rdimm_QB_cmd  [pNO_OF_PRANKS  - 1 : 0];
  wire [5                  - 1 : 0] dbg_ddr4rdimm_D_cmd   [pNO_OF_PRANKS  - 1 : 0];

  `ifdef DWC_DDR_RDIMM
    `ifdef TI_behave

  // Debug signals are commented out since the structure of the DIMM has changed. 
/* -----\/----- EXCLUDED -----\/-----
    generate
      genvar gv_ridx;
    `ifdef RDIMM_DUAL_RANK 
      for (gv_ridx = 0; gv_ridx < `DWC_NO_OF_RANKS/2; gv_ridx = gv_ridx + 1) begin    
    `else  
      for (gv_ridx = 0; gv_ridx < `DWC_NO_OF_RANKS; gv_ridx = gv_ridx + 1) begin
    `endif  
        assign dbg_ddr4rdimm_QA_addr[gv_ridx] = {  `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QAA17
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QAA16
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QAA15
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QAA14
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QAA13
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QAA12
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QAA11
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QAA10
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QAA9
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QAA8
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QAA7
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QAA6
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QAA5
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QAA4
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QAA3
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QAA2
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QAA1
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QAA0
                                                };
        assign dbg_ddr4rdimm_QB_addr[gv_ridx] = {  `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QBA17
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QBA16
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QBA15
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QBA14
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QBA13
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QBA12
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QBA11
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QBA10
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QBA9
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QBA8
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QBA7
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QBA6
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QBA5
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QBA4
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QBA3
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QBA2
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QBA1
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QBA0
                                                };
        assign dbg_ddr4rdimm_D_addr[gv_ridx]  = {  `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.DA17
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.DA16
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.DA15
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.DA14
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.DA13
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.DA12
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.DA11
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.DA10
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.DA9
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.DA8
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.DA7
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.DA6
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.DA5
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.DA4
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.DA3
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.DA2
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.DA1
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.DA0
                                                };
        assign dbg_ddr4rdimm_QA_bank[gv_ridx] = {  `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QABG1
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QABG0
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QABA1
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QABA0
                                                };
        assign dbg_ddr4rdimm_QB_bank[gv_ridx] = {  `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QBBG1
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QBBG0
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QBBA1
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QBBA0
                                                };
        assign dbg_ddr4rdimm_D_bank[gv_ridx]  = {  `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.DBG1
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.DBG0
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.DBA1
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.DBA0
                                                };
        assign dbg_ddr4rdimm_QA_cmd [gv_ridx] = {  &dbg_ddr4rdimm_QA_cs_n[gv_ridx]
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QAACT_N
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QAA16
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QAA15
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QAA14
                                                };
        assign dbg_ddr4rdimm_QB_cmd [gv_ridx] = {  &dbg_ddr4rdimm_QB_cs_n[gv_ridx]
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QBACT_N
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QBA16
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QBA15
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QBA14
                                                };
        assign dbg_ddr4rdimm_D_cmd [gv_ridx]  = {  &dbg_ddr4rdimm_D_cs_n[gv_ridx]
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.DACT_N
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.DA16
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.DA15
                                                 , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.DA14
                                                };
  
        `ifdef NO_OF_RANKS_4
          assign dbg_ddr4rdimm_QA_cs_n[gv_ridx] = {  `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QACS1_N
                                                   , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QACS0_N
                                                  };
          assign dbg_ddr4rdimm_QB_cs_n[gv_ridx] = {  `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QBCS1_N
                                                   , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QBCS0_N
                                                  };
          assign dbg_ddr4rdimm_D_cs_n[gv_ridx]  = {  `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.DCS1_N
                                                   , `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.DCS0_N
                                                  };
        `else  //  NO_OF_RANKS_2
          assign dbg_ddr4rdimm_QA_cs_n[gv_ridx] =    `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QACS0_N;
          assign dbg_ddr4rdimm_QB_cs_n[gv_ridx] =    `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.QBCS0_N;
          assign dbg_ddr4rdimm_D_cs_n[gv_ridx]  =    `TB.dwc_dimm[dwc_dim].u_ddr_rank.dwc_rank[gv_ridx].u_TOP_CAB4_CORE_A3.DCS0_N;
        `endif
      end
  
    endgenerate
 -----/\----- EXCLUDED -----/\----- */

    `endif
  `endif    // DWC_DDR_RDIMM
`endif    // DDR4

  //--------------------------------------------------------------------------//
  // PHY Gating signals
  //--------------------------------------------------------------------------//

  //// PHY DATX8 common signals of interest (to analyze read DQS gate)
  wire [10               - 1 : 0] dbg_datx8_dqn_rbdl_do_n [`DWC_NO_OF_BYTES - 1 : 0];
  wire [10               - 1 : 0] dbg_datx8_dqn_qs_q      [`DWC_NO_OF_BYTES - 1 : 0];
  wire [2                - 1 : 0] dbg_datx8_dqn_qs_n_q    [`DWC_NO_OF_BYTES - 1 : 0][10  - 1 : 0];  // 8 bits of DQ + 2 bits of DM
  wire [2                - 1 : 0] dbg_datx8_dqn_fifo_q    [`DWC_NO_OF_BYTES - 1 : 0][10  - 1 : 0];
  wire [32               - 1 : 0] dbg_datx8_dqn_phy_q     [`DWC_NO_OF_BYTES - 1 : 0][10  - 1 : 0];

  wire [`DWC_NO_OF_BYTES - 1 : 0] dbg_datx8dqs_qsgs_clk;
  wire [`DWC_NO_OF_BYTES - 1 : 0] dbg_datx8dqs_qsgs_dly_clk;
  wire [`DWC_NO_OF_BYTES - 1 : 0] dbg_datx8dqs_qsgs_qs_clk;
  wire [2                - 1 : 0] dbg_datx8dqs_qsgs_gate_status [`DWC_NO_OF_BYTES - 1 : 0];
  wire [`LCDL_DLY_WIDTH  - 1 : 0] dbg_datx8_qsgs_diff_dly       [`DWC_NO_OF_BYTES - 1 : 0]; // Difference (delay) between sampling gate signals
  wire [9                - 1 : 0] dbg_datx8dqs_rdqs_lcdl_dly    [`DWC_NO_OF_BYTES - 1 : 0];
  wire [9                - 1 : 0] dbg_datx8dqs_rdqs_bdl_dly     [`DWC_NO_OF_BYTES - 1 : 0];
  wire [9                - 1 : 0] dbg_datx8dqs_gdqs_lcdl_dly    [`DWC_NO_OF_BYTES - 1 : 0];
  wire [8                - 1 : 0] dbg_datx8_q                   [`DWC_NO_OF_BYTES - 1 : 0];
  wire [`DWC_NO_OF_BYTES - 1 : 0] dbg_datx8_qm;
  wire [`DWC_NO_OF_BYTES - 1 : 0] dbg_datx8_qs_clk;
  wire [8                - 1 : 0] dbg_datx8_q_rbeats            [`DWC_NO_OF_BYTES - 1 : 0];
  wire [`DWC_NO_OF_BYTES - 1 : 0] dbg_datx8dqs_qs_gate;
  wire [`DWC_NO_OF_BYTES - 1 : 0] dbg_datx8_qs_clk_gated;
  wire [8                - 1 : 0] dbg_datx8_q_fbeats_gated      [`DWC_NO_OF_BYTES - 1 : 0];
  wire [8                - 1 : 0] dbg_datx8_q_rbeats_gated      [`DWC_NO_OF_BYTES - 1 : 0];
  wire [`DWC_NO_OF_BYTES - 1 : 0] dbg_datx8_fifo_in_clk;
  wire [8                - 1 : 0] dbg_datx8_fifo_in             [`DWC_NO_OF_BYTES - 1 : 0][2 - 1 : 0];
  wire [`DWC_NO_OF_BYTES - 1 : 0] dbg_datx8_ctl_clk;
  wire [`DWC_NO_OF_BYTES - 1 : 0] dbg_datx8_phy_qvld;
  wire [32               - 1 : 0] dbg_datx8_fifo_out            [`DWC_NO_OF_BYTES - 1 : 0];
  wire [4                - 1 : 0] dbg_datx8_fifo_out_dm         [`DWC_NO_OF_BYTES - 1 : 0];

  //// PHY DATX4X2 common signals of interest (to analyze read DQS gate)
  wire [pNUM_LANES       - 1 : 0] dbg_lanedqs_qsgs_clk;
  wire [pNUM_LANES       - 1 : 0] dbg_lanedqs_qsgs_dly_clk;
  wire [pNUM_LANES       - 1 : 0] dbg_lanedqs_qsgs_qs_clk;
  wire [2                - 1 : 0] dbg_lanedqs_qsgs_gate_status [pNUM_LANES - 1 : 0];
  wire [`LCDL_DLY_WIDTH  - 1 : 0] dbg_lane_qsgs_diff_dly       [pNUM_LANES - 1 : 0]; // Difference (delay) between sampling gate signals
  wire [8                - 1 : 0] dbg_lanedqs_rdqs_lcdl_dly    [pNUM_LANES - 1 : 0];
  wire [8                - 1 : 0] dbg_lanedqs_gdqs_lcdl_dly    [pNUM_LANES - 1 : 0];
  wire [4                - 1 : 0] dbg_lane_q                   [pNUM_LANES - 1 : 0];
  wire [pNUM_LANES       - 1 : 0] dbg_lane_qm;
  wire [pNUM_LANES       - 1 : 0] dbg_lane_qs_clk;
  wire [4                - 1 : 0] dbg_lane_q_rbeats            [pNUM_LANES - 1 : 0];
  wire [pNUM_LANES       - 1 : 0] dbg_lanedqs_qs_gate;
  wire [pNUM_LANES       - 1 : 0] dbg_lane_qs_clk_gated;
  wire [4                - 1 : 0] dbg_lane_q_fbeats_gated      [pNUM_LANES - 1 : 0];
  wire [4                - 1 : 0] dbg_lane_q_rbeats_gated      [pNUM_LANES - 1 : 0];
  wire [pNUM_LANES       - 1 : 0] dbg_lane_fifo_in_clk;
  wire [4                - 1 : 0] dbg_lane_fifo_in             [pNUM_LANES - 1 : 0][2 - 1 : 0];
  wire [pNUM_LANES       - 1 : 0] dbg_lane_ctl_clk;
  wire [pNUM_LANES       - 1 : 0] dbg_lane_phy_qvld;
  wire [(4 * 4)          - 1 : 0] dbg_lane_fifo_out            [pNUM_LANES - 1 : 0];
  wire [4                - 1 : 0] dbg_lane_fifo_out_dm         [pNUM_LANES - 1 : 0];

  genvar gen_beat_idx;

`ifdef DWC_DDRPHY_EMUL_XILINX
`else

`ifdef GATE_LEVEL_SIM
`else
  // Build internal arrays of refrences to DATX8 DQ signals required to
  // analyze read DQS gating so we can use this later to dereference
  // remapped DQ pins
  generate
    genvar bit_idx;
    genvar lane_idx;

    // Loop through lanes (use dwc_byte as that's used in the DXn macro) 
    for (dwc_byte = 0; dwc_byte < pNUM_LANES; dwc_byte = dwc_byte + 1) begin : dbg_datx8_dq_pins
      for (bit_idx = 0; bit_idx < 10; bit_idx = bit_idx + 1) begin : bit_dq
        case (bit_idx)
          0 : begin
                assign dbg_datx8_dqn_rbdl_do_n[dwc_byte / pNO_OF_DX_DQS][0] = `DXn.datx8_dq_0.rbdl_do_n;
                assign dbg_datx8_dqn_qs_q     [dwc_byte / pNO_OF_DX_DQS][0] = `DXn.datx8_dq_0.qs_q;
                assign dbg_datx8_dqn_qs_n_q   [dwc_byte / pNO_OF_DX_DQS][0] = `DXn.datx8_dq_0.qs_n_q;
                for (gen_beat_idx = 0; gen_beat_idx < 2; gen_beat_idx = gen_beat_idx + 1) begin : fifo_in_beats
                  assign dbg_datx8_dqn_fifo_q[dwc_byte / pNO_OF_DX_DQS][0][gen_beat_idx] = `DXn.datx8_dq_0.fifo_q[gen_beat_idx];
                end
                for (gen_beat_idx = 0; gen_beat_idx < 4; gen_beat_idx = gen_beat_idx + 1) begin : fifo_out_beats
                  assign dbg_datx8_dqn_phy_q [dwc_byte / pNO_OF_DX_DQS][0][gen_beat_idx] = `DXn.datx8_dq_0.phy_q [gen_beat_idx];
                end
              end
          1 : begin
                assign dbg_datx8_dqn_rbdl_do_n[dwc_byte / pNO_OF_DX_DQS][1] = `DXn.datx8_dq_1.rbdl_do_n;
                assign dbg_datx8_dqn_qs_q     [dwc_byte / pNO_OF_DX_DQS][1] = `DXn.datx8_dq_1.qs_q;
                assign dbg_datx8_dqn_qs_n_q   [dwc_byte / pNO_OF_DX_DQS][1] = `DXn.datx8_dq_1.qs_n_q;
                for (gen_beat_idx = 0; gen_beat_idx < 2; gen_beat_idx = gen_beat_idx + 1) begin : fifo_in_beats
                  assign dbg_datx8_dqn_fifo_q[dwc_byte / pNO_OF_DX_DQS][1][gen_beat_idx] = `DXn.datx8_dq_1.fifo_q[gen_beat_idx];
                end
                for (gen_beat_idx = 0; gen_beat_idx < 4; gen_beat_idx = gen_beat_idx + 1) begin : fifo_out_beats
                  assign dbg_datx8_dqn_phy_q [dwc_byte / pNO_OF_DX_DQS][1][gen_beat_idx] = `DXn.datx8_dq_1.phy_q [gen_beat_idx];
                end
              end
          2 : begin
                assign dbg_datx8_dqn_rbdl_do_n[dwc_byte / pNO_OF_DX_DQS][2] = `DXn.datx8_dq_2.rbdl_do_n;
                assign dbg_datx8_dqn_qs_q     [dwc_byte / pNO_OF_DX_DQS][2] = `DXn.datx8_dq_2.qs_q;
                assign dbg_datx8_dqn_qs_n_q   [dwc_byte / pNO_OF_DX_DQS][2] = `DXn.datx8_dq_2.qs_n_q;
                for (gen_beat_idx = 0; gen_beat_idx < 2; gen_beat_idx = gen_beat_idx + 1) begin : fifo_in_beats
                  assign dbg_datx8_dqn_fifo_q[dwc_byte / pNO_OF_DX_DQS][2][gen_beat_idx] = `DXn.datx8_dq_2.fifo_q[gen_beat_idx];
                end
                for (gen_beat_idx = 0; gen_beat_idx < 4; gen_beat_idx = gen_beat_idx + 1) begin : fifo_out_beats
                  assign dbg_datx8_dqn_phy_q [dwc_byte / pNO_OF_DX_DQS][2][gen_beat_idx] = `DXn.datx8_dq_2.phy_q [gen_beat_idx];
                end
              end
          3 : begin
                assign dbg_datx8_dqn_rbdl_do_n[dwc_byte / pNO_OF_DX_DQS][3] = `DXn.datx8_dq_3.rbdl_do_n;
                assign dbg_datx8_dqn_qs_q     [dwc_byte / pNO_OF_DX_DQS][3] = `DXn.datx8_dq_3.qs_q;
                assign dbg_datx8_dqn_qs_n_q   [dwc_byte / pNO_OF_DX_DQS][3] = `DXn.datx8_dq_3.qs_n_q;
                for (gen_beat_idx = 0; gen_beat_idx < 2; gen_beat_idx = gen_beat_idx + 1) begin : fifo_in_beats
                  assign dbg_datx8_dqn_fifo_q[dwc_byte / pNO_OF_DX_DQS][3][gen_beat_idx] = `DXn.datx8_dq_3.fifo_q[gen_beat_idx];
                end
                for (gen_beat_idx = 0; gen_beat_idx < 4; gen_beat_idx = gen_beat_idx + 1) begin : fifo_out_beats
                  assign dbg_datx8_dqn_phy_q [dwc_byte / pNO_OF_DX_DQS][3][gen_beat_idx] = `DXn.datx8_dq_3.phy_q [gen_beat_idx];
                end
              end
          4 : begin
                assign dbg_datx8_dqn_rbdl_do_n[dwc_byte / pNO_OF_DX_DQS][4] = `DXn.datx8_dq_4.rbdl_do_n;
                assign dbg_datx8_dqn_qs_q     [dwc_byte / pNO_OF_DX_DQS][4] = `DXn.datx8_dq_4.qs_q;
                assign dbg_datx8_dqn_qs_n_q   [dwc_byte / pNO_OF_DX_DQS][4] = `DXn.datx8_dq_4.qs_n_q;
                for (gen_beat_idx = 0; gen_beat_idx < 2; gen_beat_idx = gen_beat_idx + 1) begin : fifo_in_beats
                  assign dbg_datx8_dqn_fifo_q[dwc_byte / pNO_OF_DX_DQS][4][gen_beat_idx] = `DXn.datx8_dq_4.fifo_q[gen_beat_idx];
                end
                for (gen_beat_idx = 0; gen_beat_idx < 4; gen_beat_idx = gen_beat_idx + 1) begin : fifo_out_beats
                  assign dbg_datx8_dqn_phy_q [dwc_byte / pNO_OF_DX_DQS][4][gen_beat_idx] = `DXn.datx8_dq_4.phy_q [gen_beat_idx];
                end
              end
          5 : begin
                assign dbg_datx8_dqn_rbdl_do_n[dwc_byte / pNO_OF_DX_DQS][5] = `DXn.datx8_dq_5.rbdl_do_n;
                assign dbg_datx8_dqn_qs_q     [dwc_byte / pNO_OF_DX_DQS][5] = `DXn.datx8_dq_5.qs_q;
                assign dbg_datx8_dqn_qs_n_q   [dwc_byte / pNO_OF_DX_DQS][5] = `DXn.datx8_dq_5.qs_n_q;
                for (gen_beat_idx = 0; gen_beat_idx < 2; gen_beat_idx = gen_beat_idx + 1) begin : fifo_in_beats
                  assign dbg_datx8_dqn_fifo_q[dwc_byte / pNO_OF_DX_DQS][5][gen_beat_idx] = `DXn.datx8_dq_5.fifo_q[gen_beat_idx];
                end
                for (gen_beat_idx = 0; gen_beat_idx < 4; gen_beat_idx = gen_beat_idx + 1) begin : fifo_out_beats
                  assign dbg_datx8_dqn_phy_q [dwc_byte / pNO_OF_DX_DQS][5][gen_beat_idx] = `DXn.datx8_dq_5.phy_q [gen_beat_idx];
                end
              end
          6 : begin
                assign dbg_datx8_dqn_rbdl_do_n[dwc_byte / pNO_OF_DX_DQS][6] = `DXn.datx8_dq_6.rbdl_do_n;
                assign dbg_datx8_dqn_qs_q     [dwc_byte / pNO_OF_DX_DQS][6] = `DXn.datx8_dq_6.qs_q;
                assign dbg_datx8_dqn_qs_n_q   [dwc_byte / pNO_OF_DX_DQS][6] = `DXn.datx8_dq_6.qs_n_q;
                for (gen_beat_idx = 0; gen_beat_idx < 2; gen_beat_idx = gen_beat_idx + 1) begin : fifo_in_beats
                  assign dbg_datx8_dqn_fifo_q[dwc_byte / pNO_OF_DX_DQS][6][gen_beat_idx] = `DXn.datx8_dq_6.fifo_q[gen_beat_idx];
                end
                for (gen_beat_idx = 0; gen_beat_idx < 4; gen_beat_idx = gen_beat_idx + 1) begin : fifo_out_beats
                  assign dbg_datx8_dqn_phy_q [dwc_byte / pNO_OF_DX_DQS][6][gen_beat_idx] = `DXn.datx8_dq_6.phy_q [gen_beat_idx];
                end
              end
          7 : begin
                assign dbg_datx8_dqn_rbdl_do_n[dwc_byte / pNO_OF_DX_DQS][7] = `DXn.datx8_dq_7.rbdl_do_n;
                assign dbg_datx8_dqn_qs_q     [dwc_byte / pNO_OF_DX_DQS][7] = `DXn.datx8_dq_7.qs_q;
                assign dbg_datx8_dqn_qs_n_q   [dwc_byte / pNO_OF_DX_DQS][7] = `DXn.datx8_dq_7.qs_n_q;
                for (gen_beat_idx = 0; gen_beat_idx < 2; gen_beat_idx = gen_beat_idx + 1) begin : fifo_in_beats
                  assign dbg_datx8_dqn_fifo_q[dwc_byte / pNO_OF_DX_DQS][7][gen_beat_idx] = `DXn.datx8_dq_7.fifo_q[gen_beat_idx];
                end
                for (gen_beat_idx = 0; gen_beat_idx < 4; gen_beat_idx = gen_beat_idx + 1) begin : fifo_out_beats
                  assign dbg_datx8_dqn_phy_q [dwc_byte / pNO_OF_DX_DQS][7][gen_beat_idx] = `DXn.datx8_dq_7.phy_q [gen_beat_idx];
                end
              end
          8 : begin
                assign dbg_datx8_dqn_rbdl_do_n[dwc_byte / pNO_OF_DX_DQS][8] = `DXn.datx8_dq_8.rbdl_do_n;
                assign dbg_datx8_dqn_qs_q     [dwc_byte / pNO_OF_DX_DQS][8] = `DXn.datx8_dq_8.qs_q;
                assign dbg_datx8_dqn_qs_n_q   [dwc_byte / pNO_OF_DX_DQS][8] = `DXn.datx8_dq_8.qs_n_q;
                for (gen_beat_idx = 0; gen_beat_idx < 2; gen_beat_idx = gen_beat_idx + 1) begin : fifo_in_beats
                  assign dbg_datx8_dqn_fifo_q[dwc_byte / pNO_OF_DX_DQS][8][gen_beat_idx] = `DXn.datx8_dq_8.fifo_q[gen_beat_idx];
                end
                for (gen_beat_idx = 0; gen_beat_idx < 4; gen_beat_idx = gen_beat_idx + 1) begin : fifo_out_beats
                  assign dbg_datx8_dqn_phy_q [dwc_byte / pNO_OF_DX_DQS][8][gen_beat_idx] = `DXn.datx8_dq_8.phy_q [gen_beat_idx];
                end
              end
        `ifdef DWC_DDRPHY_X4X2
          9 : begin
                assign dbg_datx8_dqn_rbdl_do_n[dwc_byte / pNO_OF_DX_DQS][9] = `DXn.datx8_dq_9.rbdl_do_n;
                assign dbg_datx8_dqn_qs_q     [dwc_byte / pNO_OF_DX_DQS][9] = `DXn.datx8_dq_9.qs_q;
                assign dbg_datx8_dqn_qs_n_q   [dwc_byte / pNO_OF_DX_DQS][9] = `DXn.datx8_dq_9.qs_n_q;
                for (gen_beat_idx = 0; gen_beat_idx < 2; gen_beat_idx = gen_beat_idx + 1) begin : fifo_in_beats
                  assign dbg_datx8_dqn_fifo_q[dwc_byte / pNO_OF_DX_DQS][9][gen_beat_idx] = `DXn.datx8_dq_9.fifo_q[gen_beat_idx];
                end
                for (gen_beat_idx = 0; gen_beat_idx < 4; gen_beat_idx = gen_beat_idx + 1) begin : fifo_out_beats
                  assign dbg_datx8_dqn_phy_q [dwc_byte / pNO_OF_DX_DQS][9][gen_beat_idx] = `DXn.datx8_dq_9.phy_q [gen_beat_idx];
                end
              end
        `endif
        endcase
      end
    end

  endgenerate
              
  //
  // Build debug signals to help debug DATX8 or DATX4X2 x8 mode simulations
  //
  generate

    for (dwc_byte = 0; dwc_byte < `DWC_NO_OF_BYTES; dwc_byte = dwc_byte + 1) begin : genblk_dbg_gating
      // Sample DQS_N using gate posedge
      assign dbg_datx8dqs_qsgs_clk        [dwc_byte] = `DXn.`DX_DQS0.dqs_gate.qsgs_clk;
      assign dbg_datx8dqs_qsgs_dly_clk    [dwc_byte] = `DXn.`DX_DQS0.dqs_gate.qsgs_dly_clk;
      assign dbg_datx8dqs_qsgs_qs_clk     [dwc_byte] = `DXn.`DX_DQS0.dqs_gate.qs_n_ungated_i;
      assign dbg_datx8dqs_qsgs_gate_status[dwc_byte] = `DXn.`DX_DQS0.dqs_gate.qs_gate_status;
      assign dbg_datx8_qsgs_diff_dly      [dwc_byte] = `DXn.gsdqs_lcdl_dly;
      // 3/2 style gate training
      assign dbg_datx8dqs_gdqs_lcdl_dly[dwc_byte] = `DXn.`DX_DQS0.ds_gate_lcdl_dly;
      assign dbg_datx8dqs_rdqs_lcdl_dly[dwc_byte] = `DXn.`DX_DQS0.qs_lcdl_dly;
      assign dbg_datx8dqs_rdqs_bdl_dly [dwc_byte] = `DXn.`DX_DQS0.qs_bdl_dly;

      assign dbg_datx8_q               [dwc_byte] = {  dbg_datx8_dqn_rbdl_do_n[dwc_byte][`DWC_DX_DQ7_PNUM]
                                                     , dbg_datx8_dqn_rbdl_do_n[dwc_byte][`DWC_DX_DQ6_PNUM]
                                                     , dbg_datx8_dqn_rbdl_do_n[dwc_byte][`DWC_DX_DQ5_PNUM]
                                                     , dbg_datx8_dqn_rbdl_do_n[dwc_byte][`DWC_DX_DQ4_PNUM]
                                                     , dbg_datx8_dqn_rbdl_do_n[dwc_byte][`DWC_DX_DQ3_PNUM]
                                                     , dbg_datx8_dqn_rbdl_do_n[dwc_byte][`DWC_DX_DQ2_PNUM]
                                                     , dbg_datx8_dqn_rbdl_do_n[dwc_byte][`DWC_DX_DQ1_PNUM]
                                                     , dbg_datx8_dqn_rbdl_do_n[dwc_byte][`DWC_DX_DQ0_PNUM]
                                                    };
      assign dbg_datx8_qm            [dwc_byte] = dbg_datx8_dqn_rbdl_do_n[dwc_byte][`DWC_DX_DM0_PNUM];
      assign dbg_datx8_qs_clk        [dwc_byte] = `DXn.`DX_DQS0.qs_clk_out;
      assign dbg_datx8_q_rbeats      [dwc_byte] = {  dbg_datx8_dqn_qs_q[dwc_byte][`DWC_DX_DQ7_PNUM]
                                                   , dbg_datx8_dqn_qs_q[dwc_byte][`DWC_DX_DQ6_PNUM]
                                                   , dbg_datx8_dqn_qs_q[dwc_byte][`DWC_DX_DQ5_PNUM]
                                                   , dbg_datx8_dqn_qs_q[dwc_byte][`DWC_DX_DQ4_PNUM]
                                                   , dbg_datx8_dqn_qs_q[dwc_byte][`DWC_DX_DQ3_PNUM]
                                                   , dbg_datx8_dqn_qs_q[dwc_byte][`DWC_DX_DQ2_PNUM]
                                                   , dbg_datx8_dqn_qs_q[dwc_byte][`DWC_DX_DQ1_PNUM]
                                                   , dbg_datx8_dqn_qs_q[dwc_byte][`DWC_DX_DQ0_PNUM]
                                                  };
      assign dbg_datx8dqs_qs_gate    [dwc_byte] = `DXn.`DX_DQS0.dqs_gate.qs_n_gate;
      assign dbg_datx8_qs_clk_gated  [dwc_byte] = `DXn.`DX_DQS0.qs_n_dly_clk_out;
      assign dbg_datx8_q_fbeats_gated[dwc_byte] = {  dbg_datx8_dqn_qs_n_q[dwc_byte][`DWC_DX_DQ7_PNUM][1]
                                                   , dbg_datx8_dqn_qs_n_q[dwc_byte][`DWC_DX_DQ6_PNUM][1]
                                                   , dbg_datx8_dqn_qs_n_q[dwc_byte][`DWC_DX_DQ5_PNUM][1]
                                                   , dbg_datx8_dqn_qs_n_q[dwc_byte][`DWC_DX_DQ4_PNUM][1]
                                                   , dbg_datx8_dqn_qs_n_q[dwc_byte][`DWC_DX_DQ3_PNUM][1]
                                                   , dbg_datx8_dqn_qs_n_q[dwc_byte][`DWC_DX_DQ2_PNUM][1]
                                                   , dbg_datx8_dqn_qs_n_q[dwc_byte][`DWC_DX_DQ1_PNUM][1]
                                                   , dbg_datx8_dqn_qs_n_q[dwc_byte][`DWC_DX_DQ0_PNUM][1]
                                                  };
      assign dbg_datx8_q_rbeats_gated[dwc_byte] = {  dbg_datx8_dqn_qs_n_q[dwc_byte][`DWC_DX_DQ7_PNUM][0]
                                                   , dbg_datx8_dqn_qs_n_q[dwc_byte][`DWC_DX_DQ6_PNUM][0]
                                                   , dbg_datx8_dqn_qs_n_q[dwc_byte][`DWC_DX_DQ5_PNUM][0]
                                                   , dbg_datx8_dqn_qs_n_q[dwc_byte][`DWC_DX_DQ4_PNUM][0]
                                                   , dbg_datx8_dqn_qs_n_q[dwc_byte][`DWC_DX_DQ3_PNUM][0]
                                                   , dbg_datx8_dqn_qs_n_q[dwc_byte][`DWC_DX_DQ2_PNUM][0]
                                                   , dbg_datx8_dqn_qs_n_q[dwc_byte][`DWC_DX_DQ1_PNUM][0]
                                                   , dbg_datx8_dqn_qs_n_q[dwc_byte][`DWC_DX_DQ0_PNUM][0]
                                                  };
 

      assign dbg_datx8_fifo_in_clk     [dwc_byte] = `DXn.`DX_DQS0.qs_n_dly_clk_out;
      for (gen_beat_idx = 0; gen_beat_idx < 2; gen_beat_idx = gen_beat_idx + 1) begin : q_even_odd_beats
        assign dbg_datx8_fifo_in     [dwc_byte][gen_beat_idx] =  {  dbg_datx8_dqn_fifo_q[dwc_byte][`DWC_DX_DQ7_PNUM][gen_beat_idx]
                                                                  , dbg_datx8_dqn_fifo_q[dwc_byte][`DWC_DX_DQ6_PNUM][gen_beat_idx]
                                                                  , dbg_datx8_dqn_fifo_q[dwc_byte][`DWC_DX_DQ5_PNUM][gen_beat_idx]
                                                                  , dbg_datx8_dqn_fifo_q[dwc_byte][`DWC_DX_DQ4_PNUM][gen_beat_idx]
                                                                  , dbg_datx8_dqn_fifo_q[dwc_byte][`DWC_DX_DQ3_PNUM][gen_beat_idx]
                                                                  , dbg_datx8_dqn_fifo_q[dwc_byte][`DWC_DX_DQ2_PNUM][gen_beat_idx]
                                                                  , dbg_datx8_dqn_fifo_q[dwc_byte][`DWC_DX_DQ1_PNUM][gen_beat_idx]
                                                                  , dbg_datx8_dqn_fifo_q[dwc_byte][`DWC_DX_DQ0_PNUM][gen_beat_idx]
                                                                 };
      end
      assign dbg_datx8_ctl_clk       [dwc_byte] = `DXn.ctl_rd_clk_i;
      assign dbg_datx8_phy_qvld      [dwc_byte] = `DXn.`DX_DQS0.phyqvld_do;
      for (gen_beat_idx = 0; gen_beat_idx < 4; gen_beat_idx = gen_beat_idx + 1) begin : phy_q_beats
        assign dbg_datx8_fifo_out[dwc_byte][gen_beat_idx * 8 +: 8] = {  dbg_datx8_dqn_phy_q[dwc_byte][`DWC_DX_DQ7_PNUM][gen_beat_idx]
                                                                      , dbg_datx8_dqn_phy_q[dwc_byte][`DWC_DX_DQ6_PNUM][gen_beat_idx]
                                                                      , dbg_datx8_dqn_phy_q[dwc_byte][`DWC_DX_DQ5_PNUM][gen_beat_idx]
                                                                      , dbg_datx8_dqn_phy_q[dwc_byte][`DWC_DX_DQ4_PNUM][gen_beat_idx]
                                                                      , dbg_datx8_dqn_phy_q[dwc_byte][`DWC_DX_DQ3_PNUM][gen_beat_idx]
                                                                      , dbg_datx8_dqn_phy_q[dwc_byte][`DWC_DX_DQ2_PNUM][gen_beat_idx]
                                                                      , dbg_datx8_dqn_phy_q[dwc_byte][`DWC_DX_DQ1_PNUM][gen_beat_idx]
                                                                      , dbg_datx8_dqn_phy_q[dwc_byte][`DWC_DX_DQ0_PNUM][gen_beat_idx]
                                                                     };
        assign dbg_datx8_fifo_out_dm[dwc_byte][gen_beat_idx] = dbg_datx8_dqn_phy_q[dwc_byte][`DWC_DX_DM0_PNUM][gen_beat_idx];
      end

    end
  endgenerate

  //
  // Build debug signals to help debug DATX4X2 x4 mode simulations
  //
    `ifdef DWC_DDRPHY_X4X2
    
      generate
        genvar beat_idx;

        // Use dwc_byte for lane indexing as it's the variable name used in the macro expansion
        for (dwc_byte = 0; dwc_byte < pNUM_LANES; dwc_byte = dwc_byte + 1) begin : dbg_gating_lane
          // Sample DQS_N using gate posedge
          if ((dwc_byte % 2) == 1) begin  // Nibble 1
            `ifdef DWC_DDRPHY_X4MODE
              assign dbg_lanedqs_qsgs_clk        [dwc_byte] = `DXn.`DX_DQS1.dqs_gate.qsgs_clk;
              assign dbg_lanedqs_qsgs_dly_clk    [dwc_byte] = `DXn.`DX_DQS1.dqs_gate.qsgs_dly_clk;
              assign dbg_lanedqs_qsgs_qs_clk     [dwc_byte] = `DXn.`DX_DQS1.dqs_gate.qs_n_ungated_i;
              assign dbg_lanedqs_qsgs_gate_status[dwc_byte] = `DXn.`DX_DQS1.dqs_gate.qs_gate_status;
            `else
              assign dbg_lanedqs_qsgs_clk        [dwc_byte] = `DXn.`DX_DQS0.dqs_gate.qsgs_clk;
              assign dbg_lanedqs_qsgs_dly_clk    [dwc_byte] = `DXn.`DX_DQS0.dqs_gate.qsgs_dly_clk;
              assign dbg_lanedqs_qsgs_qs_clk     [dwc_byte] = `DXn.`DX_DQS0.dqs_gate.qs_n_ungated_i;
              assign dbg_lanedqs_qsgs_gate_status[dwc_byte] = `DXn.`DX_DQS0.dqs_gate.qs_gate_status;
            `endif
            assign dbg_lane_qsgs_diff_dly      [dwc_byte] = `DXn.gsdqs_lcdl_dly[(dwc_byte % 2) * 9 +: 9];
            assign dbg_lanedqs_gdqs_lcdl_dly   [dwc_byte] = `DXn.`DX_DQS1.ds_gate_lcdl_dly;
            assign dbg_lanedqs_rdqs_lcdl_dly   [dwc_byte] = `DXn.`DX_DQS1.qs_bdl_dly;
            // 3/2 style gate training
            assign dbg_lane_q                  [dwc_byte] = dbg_datx8_q [dwc_byte/pNO_OF_DX_DQS][4 +: 4];
            assign dbg_lane_qm                 [dwc_byte] = dbg_datx8_qm[dwc_byte/pNO_OF_DX_DQS];
            assign dbg_lane_qs_clk             [dwc_byte] = `DXn.`DX_DQS1.qs_clk_out;
            assign dbg_lane_q_rbeats           [dwc_byte] = dbg_datx8_q_rbeats[dwc_byte/pNO_OF_DX_DQS][4 +: 4];
            assign dbg_lanedqs_qs_gate         [dwc_byte] = `DXn.`DX_DQS1.dqs_gate.qs_n_gate;
            `ifdef DWC_DDRPHY_X4MODE
              assign dbg_lane_qs_clk_gated     [dwc_byte] = `DXn.`DX_DQS1.qs_n_dly_clk_out;
            `else
              assign dbg_lane_qs_clk_gated     [dwc_byte] = `DXn.`DX_DQS0.qs_n_dly_clk_out;
            `endif
            assign dbg_lane_q_fbeats_gated     [dwc_byte] = dbg_datx8_q_fbeats_gated[dwc_byte/pNO_OF_DX_DQS][4 +: 4];
            assign dbg_lane_q_rbeats_gated     [dwc_byte] = dbg_datx8_q_rbeats_gated[dwc_byte/pNO_OF_DX_DQS][4 +: 4];
            `ifdef DWC_DDRPHY_X4MODE
              assign dbg_lane_fifo_in_clk      [dwc_byte] = `DXn.`DX_DQS1.qs_n_dly_clk_out;
            `else
              assign dbg_lane_fifo_in_clk      [dwc_byte] = `DXn.`DX_DQS0.qs_n_dly_clk_out;
            `endif
            for (beat_idx = 0; beat_idx < 2; beat_idx = beat_idx + 1) begin : q_even_odd_beats_nbl1
              assign dbg_lane_fifo_in          [dwc_byte][beat_idx] = dbg_datx8_fifo_in[dwc_byte/pNO_OF_DX_DQS][beat_idx][4 +: 4];
            end
            assign dbg_lane_ctl_clk            [dwc_byte] = `DXn.ctl_rd_clk_i;
            assign dbg_lane_phy_qvld           [dwc_byte] = `DXn.`DX_DQS1.phyqvld_do;
            for (beat_idx = 0; beat_idx < 4; beat_idx = beat_idx + 1) begin : phy_q_beats
              assign dbg_lane_fifo_out   [dwc_byte][beat_idx * 4 +: 4] = dbg_datx8_fifo_out   [dwc_byte/pNO_OF_DX_DQS][(beat_idx * 8) + 4 +: 4];
              assign dbg_lane_fifo_out_dm[dwc_byte][beat_idx         ] = dbg_datx8_fifo_out_dm[dwc_byte/pNO_OF_DX_DQS][beat_idx];
            end
          end
          else begin                      // Nibble 0
            assign dbg_lanedqs_qsgs_clk        [dwc_byte] = `DXn.`DX_DQS0.dqs_gate.qsgs_clk;
            assign dbg_lanedqs_qsgs_dly_clk    [dwc_byte] = `DXn.`DX_DQS0.dqs_gate.qsgs_dly_clk;
            assign dbg_lanedqs_qsgs_qs_clk     [dwc_byte] = `DXn.`DX_DQS0.dqs_gate.qs_n_ungated_i;
            assign dbg_lanedqs_qsgs_gate_status[dwc_byte] = `DXn.`DX_DQS0.dqs_gate.qs_gate_status;
            assign dbg_lane_qsgs_diff_dly      [dwc_byte] = `DXn.gsdqs_lcdl_dly[(dwc_byte % 2) * 9 +: 9];
            assign dbg_lanedqs_gdqs_lcdl_dly   [dwc_byte] = `DXn.`DX_DQS0.ds_gate_lcdl_dly;
            assign dbg_lanedqs_rdqs_lcdl_dly   [dwc_byte] = `DXn.`DX_DQS0.qs_lcdl_dly;
            // 3/2 style gate training
            assign dbg_lane_q                  [dwc_byte] = dbg_datx8_q[dwc_byte/pNO_OF_DX_DQS][0 +: 4];
            assign dbg_lane_qm                 [dwc_byte] = dbg_datx8_dqn_rbdl_do_n[dwc_byte/pNO_OF_DX_DQS][`DWC_DX_DM1_PNUM];
            assign dbg_lane_qs_clk             [dwc_byte] = `DXn.`DX_DQS0.qs_clk_out;
            assign dbg_lane_q_rbeats           [dwc_byte] = dbg_datx8_q_rbeats[dwc_byte/pNO_OF_DX_DQS][0 +: 4];
            assign dbg_lanedqs_qs_gate         [dwc_byte] = `DXn.`DX_DQS0.dqs_gate.qs_n_gate;
            assign dbg_lane_qs_clk_gated       [dwc_byte] = `DXn.`DX_DQS0.qs_n_dly_clk_out;
            assign dbg_lane_q_fbeats_gated     [dwc_byte] = dbg_datx8_q_fbeats_gated[dwc_byte/pNO_OF_DX_DQS][0 +: 4];
            assign dbg_lane_q_rbeats_gated     [dwc_byte] = dbg_datx8_q_rbeats_gated[dwc_byte/pNO_OF_DX_DQS][0 +: 4];
            assign dbg_lane_fifo_in_clk        [dwc_byte] = `DXn.`DX_DQS0.qs_n_dly_clk_out;
            assign dbg_lane_fifo_in_clk        [dwc_byte] = `DXn.`DX_DQS0.qs_n_dly_clk_out;
 
            for (beat_idx = 0; beat_idx < 2; beat_idx = beat_idx + 1) begin : q_even_odd_beats_nbl0
              assign dbg_lane_fifo_in          [dwc_byte][beat_idx] = dbg_datx8_fifo_in[dwc_byte/pNO_OF_DX_DQS][beat_idx][0 +: 4];
            end
            assign dbg_lane_ctl_clk            [dwc_byte] = `DXn.ctl_rd_clk_i;
            assign dbg_lane_phy_qvld           [dwc_byte] = `DXn.`DX_DQS0.phyqvld_do;
            for (beat_idx = 0; beat_idx < 4; beat_idx = beat_idx + 1) begin : phy_q_beats
              assign dbg_lane_fifo_out   [dwc_byte][beat_idx * 4 +: 4] = dbg_datx8_fifo_out [dwc_byte/pNO_OF_DX_DQS][(beat_idx * 8) + 0 +: 4];
              assign dbg_lane_fifo_out_dm[dwc_byte][beat_idx         ] = dbg_datx8_dqn_phy_q[dwc_byte/pNO_OF_DX_DQS][`DWC_DX_DM1_PNUM][beat_idx];
            end
          end

        end  // for (dwc_byte...

      endgenerate


    `endif  // DWC_DDRPHY_X4X2


  // Build segmented versions of `PHY.dq (outgoing) and `PHY.phy_q (incoming)
  always @* begin : proc_dbg_phy_dq
    for (byte_idx = 0; byte_idx < `DWC_NO_OF_BYTES; byte_idx = byte_idx + 1) begin
      dbg_phy_dq   [byte_idx] = `PHY.dq   [byte_idx *       8 +:       8];
      dbg_phy_phy_q[byte_idx] = `PHY.phy_q[byte_idx * (8 * 4) +: (8 * 4)];
    end
                     end
  `endif // !`ifdef GATE_LEVEL_SIM

`endif  // DWC_DDRPHY_EMUL_XILINX


`ifdef DWC_DDRPHY_BOARD_DELAYS
  generate
    for (dwc_byte = 0; dwc_byte < `DWC_NO_OF_BYTES; dwc_byte = dwc_byte + 1) begin : dbg_dq_fromsdram_wdelays
      always @* begin
        dbg_dq_fromsdram[dwc_byte] = `DXn.q;
      end
    end
  endgenerate
`endif

  //// Decode MRS commands
  always @* begin : proc_dbg_mrs_fields
    integer mrs_f_idx;

    if (dbg_phy_sdram_cmd_MRS == 1'b1) begin
      for (mrs_f_idx = 0; mrs_f_idx < 12; mrs_f_idx = mrs_f_idx + 1)
        dbg_MRS_decode_fields[mrs_f_idx] = "";
      case (dbg_phy_sdram_MR_num)
        3'd0 : begin
                 dbg_MRS_decode_fields[0] = (`PHY.a[1:0] == 2'b00) ? "BL: 8 (fixed)"             :
                                            (`PHY.a[1:0] == 2'b01) ? "BL: BC4 or 8 (on-the-fly)" :
                                            (`PHY.a[1:0] == 2'b10) ? "BL: BC4 (fixed)"           :
                                            (`PHY.a[1:0] == 2'b11) ? "BL: Reserved"              : 
                                                                     "Unknown";
                 dbg_MRS_decode_fields[1] = (`PHY.a[3]   == 1'b0) ? "Read Burst Type: Nibble Sequential" :
                                            (`PHY.a[3]   == 1'b1) ? "Read Burst Type: Interleave"        :
                                                                    "Unknown";
                 dbg_MRS_decode_fields[2] = (`PHY.a[7]   == 1'b0) ? "Mode: Normal" :
                                            (`PHY.a[7]   == 1'b1) ? "Mode: Test"   :
                                                                    "Unknown";
                 dbg_MRS_decode_fields[3] = (`PHY.a[8]   == 1'b0) ? "DLL Reset: No"  :
                                            (`PHY.a[8]   == 1'b1) ? "DLL Reset: Yes" :
                                                                    "Unknown";
`ifdef DDR4
                 dbg_MRS_decode_fields[4] = ({`PHY.a[6], `PHY.a[5], `PHY.a[4], `PHY.a[2]} == 4'b0000) ? "CAS Latency: 9"        :
                                            ({`PHY.a[6], `PHY.a[5], `PHY.a[4], `PHY.a[2]} == 4'b0001) ? "CAS Latency: 10"       :
                                            ({`PHY.a[6], `PHY.a[5], `PHY.a[4], `PHY.a[2]} == 4'b0010) ? "CAS Latency: 11"       :
                                            ({`PHY.a[6], `PHY.a[5], `PHY.a[4], `PHY.a[2]} == 4'b0011) ? "CAS Latency: 12"       :
                                            ({`PHY.a[6], `PHY.a[5], `PHY.a[4], `PHY.a[2]} == 4'b0100) ? "CAS Latency: 13"       :
                                            ({`PHY.a[6], `PHY.a[5], `PHY.a[4], `PHY.a[2]} == 4'b0101) ? "CAS Latency: 14"       :
                                            ({`PHY.a[6], `PHY.a[5], `PHY.a[4], `PHY.a[2]} == 4'b0110) ? "CAS Latency: 15"       :
                                            ({`PHY.a[6], `PHY.a[5], `PHY.a[4], `PHY.a[2]} == 4'b0111) ? "CAS Latency: 16"       :
                                            ({`PHY.a[6], `PHY.a[5], `PHY.a[4], `PHY.a[2]} == 4'b1000) ? "CAS Latency: 18"       :
                                            ({`PHY.a[6], `PHY.a[5], `PHY.a[4], `PHY.a[2]} == 4'b1001) ? "CAS Latency: 20"       :
                                            ({`PHY.a[6], `PHY.a[5], `PHY.a[4], `PHY.a[2]} == 4'b1010) ? "CAS Latency: 22"       :
                                            ({`PHY.a[6], `PHY.a[5], `PHY.a[4], `PHY.a[2]} == 4'b1011) ? "CAS Latency: 24"       :
                                            ({`PHY.a[6], `PHY.a[5], `PHY.a[4], `PHY.a[2]} == 4'b1100) ? "CAS Latency: Reserved" :
                                            ({`PHY.a[6], `PHY.a[5], `PHY.a[4], `PHY.a[2]} == 4'b1101) ? "CAS Latency: 17"       :
                                            ({`PHY.a[6], `PHY.a[5], `PHY.a[4], `PHY.a[2]} == 4'b1110) ? "CAS Latency: 19"       :
                                            ({`PHY.a[6], `PHY.a[5], `PHY.a[4], `PHY.a[2]} == 4'b1111) ? "CAS Latency: 21"       :
                                                                                                        "Unknown";
`else
                 dbg_MRS_decode_fields[4] = ({`PHY.a[6], `PHY.a[5], `PHY.a[4], `PHY.a[2]} == 4'b0000) ? "CAS Latency: Reserved" :
                                            ({`PHY.a[6], `PHY.a[5], `PHY.a[4], `PHY.a[2]} == 4'b0010) ? "CAS Latency: 5"        :
                                            ({`PHY.a[6], `PHY.a[5], `PHY.a[4], `PHY.a[2]} == 4'b0100) ? "CAS Latency: 6"        :
                                            ({`PHY.a[6], `PHY.a[5], `PHY.a[4], `PHY.a[2]} == 4'b0110) ? "CAS Latency: 7"        :
                                            ({`PHY.a[6], `PHY.a[5], `PHY.a[4], `PHY.a[2]} == 4'b1000) ? "CAS Latency: 8"        :
                                            ({`PHY.a[6], `PHY.a[5], `PHY.a[4], `PHY.a[2]} == 4'b1010) ? "CAS Latency: 9"        :
                                            ({`PHY.a[6], `PHY.a[5], `PHY.a[4], `PHY.a[2]} == 4'b1100) ? "CAS Latency: 10"       :
                                            ({`PHY.a[6], `PHY.a[5], `PHY.a[4], `PHY.a[2]} == 4'b1110) ? "CAS Latency: 11"       :
                                            ({`PHY.a[6], `PHY.a[5], `PHY.a[4], `PHY.a[2]} == 4'b0001) ? "CAS Latency: 12"       :
                                            ({`PHY.a[6], `PHY.a[5], `PHY.a[4], `PHY.a[2]} == 4'b0011) ? "CAS Latency: 13"       :
                                            ({`PHY.a[6], `PHY.a[5], `PHY.a[4], `PHY.a[2]} == 4'b0101) ? "CAS Latency: 14"       :
                                            ({`PHY.a[6], `PHY.a[5], `PHY.a[4], `PHY.a[2]} == 4'b0111) ? "CAS Latency: 15"       :
                                            ({`PHY.a[6], `PHY.a[5], `PHY.a[4], `PHY.a[2]} == 4'b1001) ? "CAS Latency: 16"       :
                                            ({`PHY.a[6], `PHY.a[5], `PHY.a[4], `PHY.a[2]} == 4'b1011) ? "CAS Latency: Reserved" :
                                            ({`PHY.a[6], `PHY.a[5], `PHY.a[4], `PHY.a[2]} == 4'b1101) ? "CAS Latency: Reserved" :
                                            ({`PHY.a[6], `PHY.a[5], `PHY.a[4], `PHY.a[2]} == 4'b1111) ? "CAS Latency: Reserved" :
                                                                                                        "Unknown";
`endif
`ifdef DDR4
                 dbg_MRS_decode_fields[5] = (`PHY.a[pDBG_A_BIT_11:9] == 3'b000) ? "Write Recovery: 10"       :
                                            (`PHY.a[pDBG_A_BIT_11:9] == 3'b001) ? "Write Recovery: 12"       :
                                            (`PHY.a[pDBG_A_BIT_11:9] == 3'b010) ? "Write Recovery: 14"       :
                                            (`PHY.a[pDBG_A_BIT_11:9] == 3'b011) ? "Write Recovery: 16"       :
                                            (`PHY.a[pDBG_A_BIT_11:9] == 3'b100) ? "Write Recovery: 18"       :
                                            (`PHY.a[pDBG_A_BIT_11:9] == 3'b101) ? "Write Recovery: 20"       :
                                            (`PHY.a[pDBG_A_BIT_11:9] == 3'b110) ? "Write Recovery: 24"       :
                                            (`PHY.a[pDBG_A_BIT_11:9] == 3'b111) ? "Write Recovery: Reserved" :
                                                                                  "Unknown";
`else
                 dbg_MRS_decode_fields[5] = (`PHY.a[pDBG_A_BIT_11:9] == 3'b000) ? "Write Recovery: 16" :
                                            (`PHY.a[pDBG_A_BIT_11:9] == 3'b001) ? "Write Recovery: 5"  :
                                            (`PHY.a[pDBG_A_BIT_11:9] == 3'b010) ? "Write Recovery: 6"  :
                                            (`PHY.a[pDBG_A_BIT_11:9] == 3'b011) ? "Write Recovery: 7"  :
                                            (`PHY.a[pDBG_A_BIT_11:9] == 3'b100) ? "Write Recovery: 8"  :
                                            (`PHY.a[pDBG_A_BIT_11:9] == 3'b101) ? "Write Recovery: 10" :
                                            (`PHY.a[pDBG_A_BIT_11:9] == 3'b110) ? "Write Recovery: 12" :
                                            (`PHY.a[pDBG_A_BIT_11:9] == 3'b111) ? "Write Recovery: 14" :
                                                                                  "Unknown";
`endif
`ifndef DDR4
                 dbg_MRS_decode_fields[6] = (`PHY.a[pDBG_A_BIT_12]   == 1'b0) ? "DLL Control: Slow Exit (DLL off)"  :
                                            (`PHY.a[pDBG_A_BIT_12]   == 1'b1) ? "DLL Control: Fast Exit (DLL on)" :
                                                                                "Unknown";
`endif
   
               end
        3'd1 : begin
                 dbg_MRS_decode_fields[0] = (`PHY.a[0] == 1'b0) ? "DLL Enable"  :
                                            (`PHY.a[0] == 1'b1) ? "DLL Disable" :
                                                                  "Unknown";
`ifdef DDR4
                 dbg_MRS_decode_fields[1] = ({`PHY.a[2], `PHY.a[1]} == 2'b00) ? "Output Driver Zcntl: RZQ/7"   :
                                            ({`PHY.a[2], `PHY.a[1]} == 2'b01) ? "Output Driver Zcntl: RZQ/5"   :
                                            ({`PHY.a[2], `PHY.a[1]} == 2'b10) ? "Output Driver Zcntl: RZQ/TBD" :
                                            ({`PHY.a[2], `PHY.a[1]} == 2'b11) ? "Output Driver Zcntl: RZQ/TBD" :
                                                                                "Unknown";
`else
                 dbg_MRS_decode_fields[1] = ({`PHY.a[5], `PHY.a[1]} == 2'b00) ? "Output Driver Zcntl: RZQ/6"   :
                                            ({`PHY.a[5], `PHY.a[1]} == 2'b01) ? "Output Driver Zcntl: RZQ/7"   :
                                            ({`PHY.a[5], `PHY.a[1]} == 2'b10) ? "Output Driver Zcntl: RZQ/TBD" :
                                            ({`PHY.a[5], `PHY.a[1]} == 2'b11) ? "Output Driver Zcntl: RZQ/TBD" :
                                                                                "Unknown";
`endif
`ifdef DDR4
                 dbg_MRS_decode_fields[2] = ({`PHY.a[10], `PHY.a[9], `PHY.a[8]} == 3'b000) ? "Rtt_Nom: Disabled" :
                                            ({`PHY.a[10], `PHY.a[9], `PHY.a[8]} == 3'b001) ? "Rtt_Nom: RZQ/4"    :
                                            ({`PHY.a[10], `PHY.a[9], `PHY.a[8]} == 3'b010) ? "Rtt_Nom: RZQ/2"    :
                                            ({`PHY.a[10], `PHY.a[9], `PHY.a[8]} == 3'b011) ? "Rtt_Nom: RZQ/6"    :
                                            ({`PHY.a[10], `PHY.a[9], `PHY.a[8]} == 3'b100) ? "Rtt_Nom: RZQ/1"    :
                                            ({`PHY.a[10], `PHY.a[9], `PHY.a[8]} == 3'b101) ? "Rtt_Nom: RZQ/5"    :
                                            ({`PHY.a[10], `PHY.a[9], `PHY.a[8]} == 3'b110) ? "Rtt_Nom: RZQ/3"    :
                                            ({`PHY.a[10], `PHY.a[9], `PHY.a[8]} == 3'b111) ? "Rtt_Nom: RZQ/7"    :
                                                                                             "Unknown";
`else
                 dbg_MRS_decode_fields[2] = ({`PHY.a[9], `PHY.a[6], `PHY.a[2]} == 3'b000) ? "Rtt_Nom: Disabled" :
                                            ({`PHY.a[9], `PHY.a[6], `PHY.a[2]} == 3'b001) ? "Rtt_Nom: RZQ/4"    :
                                            ({`PHY.a[9], `PHY.a[6], `PHY.a[2]} == 3'b010) ? "Rtt_Nom: RZQ/2"    :
                                            ({`PHY.a[9], `PHY.a[6], `PHY.a[2]} == 3'b011) ? "Rtt_Nom: RZQ/6"    :
                                            ({`PHY.a[9], `PHY.a[6], `PHY.a[2]} == 3'b100) ? "Rtt_Nom: RZQ/12"   :
                                            ({`PHY.a[9], `PHY.a[6], `PHY.a[2]} == 3'b101) ? "Rtt_Nom: RZQ/8"    :
                                            ({`PHY.a[9], `PHY.a[6], `PHY.a[2]} == 3'b110) ? "Rtt_Nom: Reserved" :
                                            ({`PHY.a[9], `PHY.a[6], `PHY.a[2]} == 3'b111) ? "Rtt_Nom: Reserved" :
                                                                                            "Unknown";
`endif
                 dbg_MRS_decode_fields[3] = ({`PHY.a[4], `PHY.a[3]} == 2'b00) ? "AL: 0"         :
                                            ({`PHY.a[4], `PHY.a[3]} == 2'b01) ? "AL: CL - 1"    :
                                            ({`PHY.a[4], `PHY.a[3]} == 2'b10) ? "AL: CL - 2"    :
                                            ({`PHY.a[4], `PHY.a[3]} == 2'b11) ? "AL: Reserved " :
                                                                                "Unknown";
                 dbg_MRS_decode_fields[4] = (`PHY.a[7]  == 1'b1) ? "Write Leveling Enable"  :
                                            (`PHY.a[7]  == 1'b0) ? "Write Leveling Disable" :
                                                                   "Unknown";
                 dbg_MRS_decode_fields[5] = (`PHY.a[pDBG_A_BIT_11] == 1'b0) ? "TDQS Disable"  :
                                            (`PHY.a[pDBG_A_BIT_11] == 1'b1) ? "TDQS Enable" :
                                                                              "Unknown";
                 dbg_MRS_decode_fields[6] = (`PHY.a[pDBG_A_BIT_12] == 1'b0) ? "Output buffer Enable"  :
                                            (`PHY.a[pDBG_A_BIT_12] == 1'b1) ? "Output buffer Disable" :
                                                                              "Unknown";

               end
        3'd2 : begin
`ifdef DDR4
                 dbg_MRS_decode_fields[0] = (`PHY.a[2:0] == 3'b000) ? "Must be programmed to 0 during MRS" :
                                                                      "Unknown";
`else
                 dbg_MRS_decode_fields[0] = (`PHY.a[2:0] == 3'b000) ? "Partial Array Self-Refresh: Full Array"               :
                                            (`PHY.a[2:0] == 3'b001) ? "Partial Array Self-Refresh: Half Array (000, ...)"    :
                                            (`PHY.a[2:0] == 3'b010) ? "Partial Array Self-Refresh: Quarter Array (000, 001)" :
                                            (`PHY.a[2:0] == 3'b011) ? "Partial Array Self-Refresh: 1/8th Array (000)"        :
                                            (`PHY.a[2:0] == 3'b100) ? "Partial Array Self-Refresh: 3/4th Array (010, ...)"   :
                                            (`PHY.a[2:0] == 3'b101) ? "Partial Array Self-Refresh: Half Array (100, ...)"    :
                                            (`PHY.a[2:0] == 3'b110) ? "Partial Array Self-Refresh: Quarter Array (110, 111)" :
                                            (`PHY.a[2:0] == 3'b111) ? "Partial Array Self-Refresh: 1/8th Array (111)"        :
                                                                      "Unknown";
`endif
`ifdef DDR4
                 dbg_MRS_decode_fields[1] = (`PHY.a[5:3] == 3'b000) ? "CWL: 9"        :
                                            (`PHY.a[5:3] == 3'b001) ? "CWL: 10"       :
                                            (`PHY.a[5:3] == 3'b010) ? "CWL: 11"       :
                                            (`PHY.a[5:3] == 3'b011) ? "CWL: 12"       :
                                            (`PHY.a[5:3] == 3'b100) ? "CWL: 14"       :
                                            (`PHY.a[5:3] == 3'b101) ? "CWL: 16"       :
                                            (`PHY.a[5:3] == 3'b110) ? "CWL: 18"       :
                                            (`PHY.a[5:3] == 3'b111) ? "CWL: Reserved" :
                                                                      "Unknown";
`else
                 dbg_MRS_decode_fields[1] = (`PHY.a[5:3] == 3'b000) ? "CWL: 5"  :
                                            (`PHY.a[5:3] == 3'b001) ? "CWL: 6"  :
                                            (`PHY.a[5:3] == 3'b010) ? "CWL: 7"  :
                                            (`PHY.a[5:3] == 3'b011) ? "CWL: 8"  :
                                            (`PHY.a[5:3] == 3'b100) ? "CWL: 9"  :
                                            (`PHY.a[5:3] == 3'b101) ? "CWL: 10" :
                                            (`PHY.a[5:3] == 3'b110) ? "CWL: 11" :
                                            (`PHY.a[5:3] == 3'b111) ? "CWL: 12" :
                                                                      "Unknown";
`endif
`ifdef DDR4
                 dbg_MRS_decode_fields[2] = (`PHY.a[7:6] == 2'b00) ? "Manual Mode (Normal Operating Temperature Range)"   :
                                            (`PHY.a[7:6] == 2'b01) ? "Manual Mode (Reduced Operating Temperature Range)"  :
                                            (`PHY.a[7:6] == 2'b10) ? "Manual Mode (Extended Operating Temperature Range)" :
                                            (`PHY.a[7:6] == 2'b11) ? "ASR Mode (Auto Self Refresh)"                       :
                                                                     "Unknown";
                 dbg_MRS_decode_fields[3] = (`PHY.a[8]   == 1'b0)  ? "Must be programmed to 0 during MRS" :
                                                                     "Unknown";
`else
                 dbg_MRS_decode_fields[2] = (`PHY.a[6] == 1'b0) ? "Auto Self-Refresh: Manual"  :
                                            (`PHY.a[6] == 1'b1) ? "Auto Self-Refresh: Enable"  :
                                                                  "Unknown";
                 dbg_MRS_decode_fields[3] = (`PHY.a[7] == 1'b0) ? "Self-Refresh Temp Range: Normal"   :
                                            (`PHY.a[7] == 1'b1) ? "Self-Refresh Temp Range: Extended" :
                                                                  "Unknown";
`endif
`ifdef DDR4
                 dbg_MRS_decode_fields[4] = (`PHY.a[pDBG_A_BIT_10:9] == 2'b00) ? "Rtt_WR: Dynamic ODT" :
                                            (`PHY.a[pDBG_A_BIT_10:9] == 2'b01) ? "Rtt_WR: RZQ/2"       :
                                            (`PHY.a[pDBG_A_BIT_10:9] == 2'b10) ? "Rtt_WR: RZQ/1"       :
                                            (`PHY.a[pDBG_A_BIT_10:9] == 2'b11) ? "Rtt_WR: Hi-Z"        :
                                                                                 "Unknown";
`else
                 dbg_MRS_decode_fields[4] = (`PHY.a[pDBG_A_BIT_10:9] == 2'b00) ? "Rtt_WR: Dynamic ODT" :
                                            (`PHY.a[pDBG_A_BIT_10:9] == 2'b01) ? "Rtt_WR: RZQ/4"       :
                                            (`PHY.a[pDBG_A_BIT_10:9] == 2'b10) ? "Rtt_WR: RZQ/2"       :
                                            (`PHY.a[pDBG_A_BIT_10:9] == 2'b11) ? "Rtt_WR: Reserved"    :
                                                                                 "Unknown";
`endif
`ifdef DDR4
                 dbg_MRS_decode_fields[5] = (`PHY.a[11] == 1'b0)  ? "Must be programmed to 0 during MRS" :
                                                                    "Unknown";
                 dbg_MRS_decode_fields[6] = (`PHY.a[12] == 1'b0)  ? "Write CRC: Disable" :
                                            (`PHY.a[12] == 1'b1)  ? "Write CRC: Enable"  :
                                                                    "Unknown";
                 dbg_MRS_decode_fields[7] = (`PHY.a[13] == 1'b0)  ? "Must be programmed to 0 during MRS" :
                                                                    "Unknown";
`endif
               end
        3'd3 : begin
`ifdef DDR4
                 dbg_MRS_decode_fields[0] = (`PHY.a[1:0] == 2'b00) ? "MPR Page Selection: Page 0" :
                                            (`PHY.a[1:0] == 2'b00) ? "MPR Page Selection: Page 1" :
                                            (`PHY.a[1:0] == 2'b10) ? "MPR Page Selection: Page 2" :
                                            (`PHY.a[1:0] == 2'b11) ? "MPR Page Selection: Page 3" :
                                                                     "Unknown";
`else
                 dbg_MRS_decode_fields[0] = (`PHY.a[1:0] == 2'b00) ? "MPR: Predefined pattern" :
                                            (`PHY.a[1:0] == 2'b00) ? "MPR: RFU"                :
                                            (`PHY.a[1:0] == 2'b10) ? "MPR: RFU"                :
                                            (`PHY.a[1:0] == 2'b11) ? "MPR: RFU"                :
                                                                     "Unknown";
`endif
                 dbg_MRS_decode_fields[1] = (`PHY.a[2]   == 1'b0)  ? "MPR: Normal operation"   :
                                            (`PHY.a[2]   == 1'b1)  ? "MPR: Dataflow from MPR"  :
                                                                     "Unknown";
`ifdef DDR4
                 dbg_MRS_decode_fields[2] = (`PHY.a[3]   == 1'b0)  ? "Geardown Mode: 1/2 Rate" :
                                            (`PHY.a[3]   == 1'b1)  ? "Geardown Mode: 1/4 Rate" :
                                                                     "Unknown";
                 dbg_MRS_decode_fields[3] = (`PHY.a[4]   == 1'b0)  ? "Per DRAM Addressability: Disable" :
                                            (`PHY.a[4]   == 1'b1)  ? "Per DRAM Addressability: Enable"  :
                                                                     "Unknown";
                 dbg_MRS_decode_fields[4] = (`PHY.a[5]   == 1'b0)  ? "Temp Sensor Readout: Disable" :
                                            (`PHY.a[5]   == 1'b1)  ? "Temp Sensor Readout: Enable"  :
                                                                     "Unknown";
                 dbg_MRS_decode_fields[5] = (`PHY.a[8:6] == 3'b000) ? "Fine Granularity Refresh Mode: Normal (Fixed 1x)"    :
                                            (`PHY.a[8:6] == 3'b001) ? "Fine Granularity Refresh Mode: Fixed 2x"             :
                                            (`PHY.a[8:6] == 3'b010) ? "Fine Granularity Refresh Mode: Fixed 4x"             :
                                            (`PHY.a[8:6] == 3'b011) ? "Fine Granularity Refresh Mode: Reserved"             :
                                            (`PHY.a[8:6] == 3'b100) ? "Fine Granularity Refresh Mode: Reserved"             :
                                            (`PHY.a[8:6] == 3'b101) ? "Fine Granularity Refresh Mode: Enable on-the-fly 2x" :
                                            (`PHY.a[8:6] == 3'b110) ? "Fine Granularity Refresh Mode: Enable on-the-fly 4x" :
                                            (`PHY.a[8:6] == 3'b111) ? "Fine Granularity Refresh Mode: Reserved"             :
                                                                      "Unknown";
                 dbg_MRS_decode_fields[6] = (`PHY.a[pDBG_A_BIT_10:9] == 2'b00) ? "Write CMD Latency (CRC & DM Enabled): 4nCK" :
                                            (`PHY.a[pDBG_A_BIT_10:9] == 2'b01) ? "Write CMD Latency (CRC & DM Enabled): 5nCK" :
                                            (`PHY.a[pDBG_A_BIT_10:9] == 2'b10) ? "Write CMD Latency (CRC & DM Enabled): 6nCK" :
                                            (`PHY.a[pDBG_A_BIT_10:9] == 2'b11) ? "Write CMD Latency (CRC & DM Enabled): RFU"  :
                                                                                 "Unknown";
                 dbg_MRS_decode_fields[7] = (`PHY.a[pDBG_A_BIT_12:pDBG_A_BIT_11] == 2'b00) ? "MPR Read Format: Serial"    :
                                            (`PHY.a[pDBG_A_BIT_12:pDBG_A_BIT_11] == 2'b01) ? "MPR Read Format: Parallel"  :
                                            (`PHY.a[pDBG_A_BIT_12:pDBG_A_BIT_11] == 2'b10) ? "MPR Read Format: Staggered" :
                                            (`PHY.a[pDBG_A_BIT_12:pDBG_A_BIT_11] == 2'b11) ? "MPR Read Format: Reserved"  :
                                                                                             "Unknown";
                 dbg_MRS_decode_fields[8] = (`PHY.a[pDBG_A_BIT_13]    == 1'b0)  ? "RFU" :
                                                                                  "Unknown";
`endif
               end
        3'd4 : begin
                 dbg_MRS_decode_fields[0]  = (`PHY.a[0] == 1'b0) ? "RFU" :
                                                                   "Unknown";
                 dbg_MRS_decode_fields[1]  = (`PHY.a[1] == 1'b0) ? "Maximum Power Down Mode: Disable" :
                                             (`PHY.a[1] == 1'b1) ? "Maximum Power Down Mode: Enable"  :
                                                                   "Unknown";
                 dbg_MRS_decode_fields[2]  = (`PHY.a[2] == 1'b0) ? "Temperature Controlled Refresh Range: Normal"   :
                                             (`PHY.a[2] == 1'b1) ? "Temperature Controlled Refresh Range: Extended" :
                                                                   "Unknown";
                 dbg_MRS_decode_fields[3]  = (`PHY.a[3] == 1'b0) ? "Temperature Controlled Refresh Mode: Disable" :
                                             (`PHY.a[3] == 1'b1) ? "Temperature Controlled Refresh Mode: Enable"  :
                                                                   "Unknown";
                 dbg_MRS_decode_fields[4]  = (`PHY.a[4] == 1'b0) ? "Internal Vref Monitor: Disable" :
                                             (`PHY.a[4] == 1'b1) ? "Internal Vref Monitor: Enable"  :
                                                                   "Unknown";
                 dbg_MRS_decode_fields[5]  = (`PHY.a[5] == 1'b0) ? "RFU" :
                                                                   "Unknown";
                 dbg_MRS_decode_fields[6]  = (`PHY.a[8:6] == 3'b000) ? "CS to CMD/ADDR Latency Mode: Disable"  :
                                             (`PHY.a[8:6] == 3'b001) ? "CS to CMD/ADDR Latency Mode: 3"        :
                                             (`PHY.a[8:6] == 3'b010) ? "CS to CMD/ADDR Latency Mode: 4"        :
                                             (`PHY.a[8:6] == 3'b011) ? "CS to CMD/ADDR Latency Mode: 5"        :
                                             (`PHY.a[8:6] == 3'b100) ? "CS to CMD/ADDR Latency Mode: 6"        :
                                             (`PHY.a[8:6] == 3'b101) ? "CS to CMD/ADDR Latency Mode: 8"        :
                                             (`PHY.a[8:6] == 3'b110) ? "CS to CMD/ADDR Latency Mode: Reserved" :
                                             (`PHY.a[8:6] == 3'b111) ? "CS to CMD/ADDR Latency Mode: Reserved" :
                                                                       "Unknown";
                 dbg_MRS_decode_fields[7]  = (`PHY.a[9]  == 1'b0) ? "Self Refresh Abort: Disable" :
                                             (`PHY.a[9]  == 1'b1) ? "Self Refresh Abort: Enable"  :
                                                                    "Unknown";
                 dbg_MRS_decode_fields[8]  = (`PHY.a[pDBG_A_BIT_10] == 1'b0) ? "Read Preamble Training Mode: Disable" :
                                             (`PHY.a[pDBG_A_BIT_10] == 1'b1) ? "Read Preamble Training Mode: Enable"  :
                                                                               "Unknown";
                 dbg_MRS_decode_fields[9]  = (`PHY.a[pDBG_A_BIT_11] == 1'b0) ? "Read Preamble: 1nCK" :
                                             (`PHY.a[pDBG_A_BIT_11] == 1'b1) ? "Read Preamble: 2nCK" :
                                                                               "Unknown";
                 dbg_MRS_decode_fields[10] = (`PHY.a[pDBG_A_BIT_12] == 1'b0) ? "Write Preamble: 1nCK" :
                                             (`PHY.a[pDBG_A_BIT_12] == 1'b1) ? "Write Preamble: 2nCK" :
                                                                               "Unknown";
                 dbg_MRS_decode_fields[11] = (`PHY.a[pDBG_A_BIT_13] == 1'b0) ? "RFU" :
                                                                               "Unknown";
               end
        3'd5 : begin
                 dbg_MRS_decode_fields[0] = (`PHY.a[2:0] == 3'b000) ? "CA Parity Latency Mode: Disable"  :
                                            (`PHY.a[2:0] == 3'b001) ? "CA Parity Latency Mode: 4"        :
                                            (`PHY.a[2:0] == 3'b010) ? "CA Parity Latency Mode: 5"        :
                                            (`PHY.a[2:0] == 3'b011) ? "CA Parity Latency Mode: 6"        :
                                            (`PHY.a[2:0] == 3'b100) ? "CA Parity Latency Mode: 8"        :
                                            (`PHY.a[2:0] == 3'b101) ? "CA Parity Latency Mode: Reserved" :
                                            (`PHY.a[2:0] == 3'b110) ? "CA Parity Latency Mode: Reserved" :
                                            (`PHY.a[2:0] == 3'b111) ? "CA Parity Latency Mode: Reserved" :
                                                                     "Unknown";
                 dbg_MRS_decode_fields[1] = (`PHY.a[3]   == 1'b0)  ? "CRC Error Clear: Clear"  :
                                            (`PHY.a[3]   == 1'b1)  ? "CRC Error Clear: Error"  :
                                                                     "Unknown";
                 dbg_MRS_decode_fields[2] = (`PHY.a[4]   == 1'b0)  ? "C/A Parity Error Status: Clear"  :
                                            (`PHY.a[4]   == 1'b1)  ? "C/A Parity Error Status: Error"  :
                                                                     "Unknown";
                 dbg_MRS_decode_fields[3] = (`PHY.a[5]   == 1'b0)  ? "ODT Input Buffer during Power Down Mode: Activated" :
                                            (`PHY.a[5]   == 1'b1)  ? "ODT Input Buffer during Power Down Mode: Deactivated"  :
                                                                     "Unknown";
                 dbg_MRS_decode_fields[4] = (`PHY.a[8:6] == 3'b000) ? "RTT_PARK: Disable" :
                                            (`PHY.a[8:6] == 3'b000) ? "RTT_PARK: RZQ/4"   :
                                            (`PHY.a[8:6] == 3'b010) ? "RTT_PARK: RZQ/2"   :
                                            (`PHY.a[8:6] == 3'b011) ? "RTT_PARK: RZQ/6"   :
                                            (`PHY.a[8:6] == 3'b100) ? "RTT_PARK: RZQ/1"   :
                                            (`PHY.a[8:6] == 3'b101) ? "RTT_PARK: RZQ/5"   :
                                            (`PHY.a[8:6] == 3'b110) ? "RTT_PARK: RZQ/3"   :
                                            (`PHY.a[8:6] == 3'b111) ? "RTT_PARK: RZQ/7"   :
                                                                      "Unknown";
                 dbg_MRS_decode_fields[5] = (`PHY.a[9]   == 1'b0)  ? "CA parity Persistent Error: Disable" :
                                            (`PHY.a[9]   == 1'b1)  ? "CA parity Persistent Error: Enable"  :
                                                                     "Unknown";
                 dbg_MRS_decode_fields[6] = (`PHY.a[pDBG_A_BIT_10]  == 1'b0)  ? "Data Mask: Disable" :
                                            (`PHY.a[pDBG_A_BIT_10]  == 1'b1)  ? "Data Mask: Enable"  :
                                                                                "Unknown";
                 dbg_MRS_decode_fields[7] = (`PHY.a[pDBG_A_BIT_11]  == 1'b0)  ? "Write DBI: Disable" :
                                            (`PHY.a[pDBG_A_BIT_11]  == 1'b1)  ? "Write DBI: Enable"  :
                                                                                "Unknown";
                 dbg_MRS_decode_fields[8] = (`PHY.a[pDBG_A_BIT_12]  == 1'b0)  ? "Read DBI: Disable" :
                                            (`PHY.a[pDBG_A_BIT_12]  == 1'b1)  ? "Read DBI: Enable"  :
                                                                                "Unknown";
                 dbg_MRS_decode_fields[9] = (`PHY.a[pDBG_A_BIT_13]  == 1'b0)  ? "RFU"             :
                                            (`PHY.a[pDBG_A_BIT_13]  == 1'b1)  ? "RFU: Must be 0"  :
                                                                                "Unknown";
               end
        3'd6 : begin
                 dbg_MRS_decode_fields[0] = (`PHY.a[5:0] >= 6'b110011) ? "Reserveed" :
                                                                         "VrefDQ Training Value: TBD";
                 dbg_MRS_decode_fields[1] = (`PHY.a[6]     == 1'b0)    ? "VrefDQ Training: Range 1" :
                                                                         "VrefDQ Training: Range 2";
                 dbg_MRS_decode_fields[2] = (`PHY.a[7]     == 1'b0)    ? "VrefDQ Training Disable" :
                                                                         "VrefDQ Training Enable";
                 dbg_MRS_decode_fields[3] = (`PHY.a[pDBG_A_BIT_12:pDBG_A_BIT_10] == 3'b000)  ? "tCCD_L: 4" :
                                            (`PHY.a[pDBG_A_BIT_12:pDBG_A_BIT_10] == 3'b001)  ? "tCCD_L: 5" :
                                            (`PHY.a[pDBG_A_BIT_12:pDBG_A_BIT_10] == 3'b010)  ? "tCCD_L: 6" :
                                            (`PHY.a[pDBG_A_BIT_12:pDBG_A_BIT_10] == 3'b011)  ? "tCCD_L: 7" :
                                            (`PHY.a[pDBG_A_BIT_12:pDBG_A_BIT_10] == 3'b100)  ? "tCCD_L: 8" :
                                                                                               "tCCD_L: Reserved";
               end
        default : begin
                  end
      endcase
    end
  end

  //// LPDDRX only
  reg  [50*8      - 1 : 0] dbg_phy_lpddr2_cmd_string;
  reg  [50*8      - 1 : 0] dbg_phy_lpddr2_cmd_string_reg;
  reg  [50*8      - 1 : 0] dbg_phy_lpddr2_cmd_p0n_string;
  reg  [6         - 1 : 0] dbg_phy_lpddr2_cmd_p0n;
  wire [6         - 1 : 0] dbg_phy_lpddr2_cmd;
  reg  [3         - 1 : 0] dbg_phy_lpddr2_bank;
  reg  [32        - 1 : 0] dbg_phy_lpddr2_row;
  reg  [12        - 1 : 0] dbg_phy_lpddr2_col;
  reg  [8         - 1 : 0] dbg_phy_lpddr2_mr_num;

  initial begin
    dbg_phy_lpddr2_row    = 0;
    dbg_phy_lpddr2_col[0] = 1'b0;
    dbg_phy_lpddr2_mr_num = 0;
  end

  // In LPDDR2 the command is built out of address bits
  `ifdef DWC_AC_CS_USE
    assign dbg_phy_lpddr2_cmd = { (&(`PHY.cs_n)) ,`PHY.a[0] ,`PHY.a[1] ,`PHY.a[2] ,`PHY.a[3] };
  `else
    assign dbg_phy_lpddr2_cmd = { 1'b0 ,`PHY.a[0] ,`PHY.a[1] ,`PHY.a[2] ,`PHY.a[3] };
  `endif  
  
  always @* begin
    `ifdef DWC_AC_CS_USE
      dbg_phy_lpddr2_cmd_string     = (&`PHY.cs_n == 1'b0) ? get_lpddr2_cmd_string(dbg_phy_lpddr2_cmd)     : 'hZ;
      dbg_phy_lpddr2_cmd_p0n_string = (&`PHY.cs_n == 1'b0) ? get_lpddr2_cmd_string(dbg_phy_lpddr2_cmd_p0n) : 'hZ;
    `else
      dbg_phy_lpddr2_cmd_string     = get_lpddr2_cmd_string(dbg_phy_lpddr2_cmd)    ;
      dbg_phy_lpddr2_cmd_p0n_string = get_lpddr2_cmd_string(dbg_phy_lpddr2_cmd_p0n);
    `endif  
  end
  
  // On the rising edge of the clock...
  always @(posedge `PHY.ck[0]) begin
    dbg_phy_lpddr2_cmd_string_reg <= dbg_phy_lpddr2_cmd_string;
    // For readability on waveforms hold non-NOP command values until next change
    if (dbg_phy_lpddr2_cmd_string != "NOP")
      dbg_phy_lpddr2_cmd_p0n = dbg_phy_lpddr2_cmd;
    // Decode bank address
    case (dbg_phy_lpddr2_cmd_string)
      "ACT",
      "WR" ,
      "RD" ,
      "PRE" : dbg_phy_lpddr2_bank = { `PHY.a[9], `PHY.a[8], `PHY.a[7] };
    endcase
    // Decode partial row address during activate
    if (dbg_phy_lpddr2_cmd_string == "ACT")
      dbg_phy_lpddr2_row[12:8] = `PHY.a[6:2];
    // Decode partial column address during wr/rd
    if ((dbg_phy_lpddr2_cmd_string == "WR") || (dbg_phy_lpddr2_cmd_string == "RD"))
      dbg_phy_lpddr2_col[2:1] = `PHY.a[6:5];
    // Decode partial mode register access address
    if ((dbg_phy_lpddr2_cmd_string == "MR_Write") || (dbg_phy_lpddr2_cmd_string == "MR_Read"))
      dbg_phy_lpddr2_mr_num[5:0] = `PHY.a[9:4];
  end

  // On the falling edge of the clock...
  always @(negedge `PHY.ck[0]) begin
    // Decode the remaining row address during activate
    if ((dbg_phy_lpddr2_cmd_p0n_string == "ACT") && (dbg_phy_lpddr2_cmd_string_reg == "ACT")) begin
      dbg_phy_lpddr2_row[7 : 0] = `PHY.a[7:0];
      dbg_phy_lpddr2_row[14:13] = `PHY.a[9:8];
    end
    // Decode the remaining column address during wr/rd
    if (   ((dbg_phy_lpddr2_cmd_p0n_string == "WR") && (dbg_phy_lpddr2_cmd_string_reg == "WR"))
        || ((dbg_phy_lpddr2_cmd_p0n_string == "RD") && (dbg_phy_lpddr2_cmd_string_reg == "RD")) 
       )
      dbg_phy_lpddr2_col[11:3] = `PHY.a[9:1];
    // Decode partial mode register access address
    if ((dbg_phy_lpddr2_cmd_string_reg == "MR_Write") || (dbg_phy_lpddr2_cmd_string_reg == "MR_Read"))
      dbg_phy_lpddr2_mr_num[7:6] = `PHY.a[1:0];
  end

  // LPDDR2 command strings
  function [50*8  - 1 : 0] get_lpddr2_cmd_string;
    input [5  - 1 : 0] lpddr2_cmd_bus;

    begin
      casez (lpddr2_cmd_bus)
        5'b0_0000 : get_lpddr2_cmd_string = "MR_Write";
        5'b0_0001 : get_lpddr2_cmd_string = "MR_Read";
        5'b0_0010 : get_lpddr2_cmd_string = "REF_bank";
        5'b0_0011 : get_lpddr2_cmd_string = "REF_all";
        5'b0_001? : get_lpddr2_cmd_string = "SelfRefresh";
        5'b0_01?? : get_lpddr2_cmd_string = "ACT";
        5'b0_100? : get_lpddr2_cmd_string = "WR";
        5'b0_101? : get_lpddr2_cmd_string = "RD";
        5'b0_1101 : get_lpddr2_cmd_string = "PRE";
        5'b0_1100 : get_lpddr2_cmd_string = "BST";
        5'b0_110? : get_lpddr2_cmd_string = "PowerDown";
        5'b0_111? : get_lpddr2_cmd_string = "NOP";
      endcase
    end
  endfunction

  //// DFI
  wire [4                                     - 1 : 0] dbg_dfi_cmd_even;
  wire [4                                     - 1 : 0] dbg_dfi_cmd_odd;
  wire [pNO_OF_CSNS                           - 1 : 0] dbg_dfi_cs_n_even;
  wire [pNO_OF_CSNS                           - 1 : 0] dbg_dfi_cs_n_odd;
  reg  [(pNO_OF_DX_DQS * pMEMCTL_NO_OF_BEATS) - 1 : 0] dbg_dfi_wrdata_mask_dx    [`DWC_NO_OF_BYTES    - 1 : 0];
  reg  [(8             * pMEMCTL_NO_OF_BEATS) - 1 : 0] dbg_dfi_wrdata_dx         [`DWC_NO_OF_BYTES    - 1 : 0];
  reg  [(8             * pMEMCTL_NO_OF_BEATS) - 1 : 0] dbg_dfi_rddata_dx         [`DWC_NO_OF_BYTES    - 1 : 0];
  reg  [(8             * pNUM_LANES)          - 1 : 0] dbg_dfi_rddata_dx_per_beat[pMEMCTL_NO_OF_BEATS - 1 : 0];
  reg  [(pNO_OF_DX_DQS * pMEMCTL_NO_OF_CMDS)  - 1 : 0] dbg_dfi_wrdata_en_dx      [`DWC_NO_OF_BYTES    - 1 : 0];
  reg  [(pNO_OF_DX_DQS * pMEMCTL_NO_OF_CMDS)  - 1 : 0] dbg_dfi_rddata_en_dx      [`DWC_NO_OF_BYTES    - 1 : 0];
  reg  [(pDBEAT_WIDTH  * pMEMCTL_NO_OF_BEATS) - 1 : 0] dbg_dfi_wrdata_x4         [pNUM_LANES          - 1 : 0];
  reg  [(pDBEAT_WIDTH  * pMEMCTL_NO_OF_BEATS) - 1 : 0] dbg_dfi_rddata_x4         [pNUM_LANES          - 1 : 0];
  reg  [(pDBEAT_WIDTH  * pNUM_LANES)          - 1 : 0] dbg_dfi_rddata_x4_per_beat[pMEMCTL_NO_OF_BEATS - 1 : 0];


  assign dbg_dfi_cmd_odd  = { (&(`PHYDFI.ac_ctl.dfi_cs_n [pNO_OF_CSNS *2-1:pNO_OF_CSNS ]))
                                ,`PHYDFI.ac_ctl.dfi_ras_n  [1]
                                ,`PHYDFI.ac_ctl.dfi_cas_n  [1]
                                ,`PHYDFI.ac_ctl.dfi_we_n   [1]
                            };
  assign dbg_dfi_cmd_even = { (&(`PHYDFI.ac_ctl.dfi_cs_n [pNO_OF_CSNS -1:0]))
                                ,`PHYDFI.ac_ctl.dfi_ras_n  [0]
                                ,`PHYDFI.ac_ctl.dfi_cas_n  [0]
                                ,`PHYDFI.ac_ctl.dfi_we_n   [0]
                            };
  assign dbg_dfi_cs_n_odd  = `PHYDFI.ac_ctl.dfi_cs_n [pNO_OF_CSNS *2-1:pNO_OF_CSNS ];
  assign dbg_dfi_cs_n_even = `PHYDFI.ac_ctl.dfi_cs_n [pNO_OF_CSNS -1:0];

  // Build byte-lane segmented versions of `PHYDFI.dfi_wrdata (outgoing) and `PHYDFI.dfi_rddata (incoming)
  always @* begin : proc_dbg_dfi_data
    integer beat_idx;
    for (byte_idx = 0; byte_idx < `DWC_NO_OF_BYTES; byte_idx = byte_idx + 1) begin
      dbg_dfi_wrdata_en_dx[byte_idx] = {  `PHYDFI.dfi_wrdata_en[(`DWC_NO_OF_BYTES * pNO_OF_DX_DQS) + (byte_idx * pNO_OF_DX_DQS) +: pNO_OF_DX_DQS] // Odd  phase
                                        , `PHYDFI.dfi_wrdata_en[                                     (byte_idx * pNO_OF_DX_DQS) +: pNO_OF_DX_DQS] // Even phase
                                       };
      dbg_dfi_rddata_en_dx[byte_idx] = {  `PHYDFI.dfi_rddata_en[(`DWC_NO_OF_BYTES * pNO_OF_DX_DQS) + (byte_idx * pNO_OF_DX_DQS) +: pNO_OF_DX_DQS] // Odd  phase
                                        , `PHYDFI.dfi_rddata_en[                                     (byte_idx * pNO_OF_DX_DQS) +: pNO_OF_DX_DQS] // Even phase
                                       };
      for (beat_idx = 0; beat_idx < pMEMCTL_NO_OF_BEATS; beat_idx = beat_idx + 1) begin
        dbg_dfi_wrdata_mask_dx    [byte_idx][beat_idx * pNO_OF_DX_DQS +: pNO_OF_DX_DQS] = `PHYDFI.dfi_wrdata_mask[(`DWC_NO_OF_BYTES * pNO_OF_DX_DQS * beat_idx) + (byte_idx * pNO_OF_DX_DQS) +: pNO_OF_DX_DQS];
        dbg_dfi_wrdata_dx         [byte_idx][beat_idx * 8 +: 8] = `PHYDFI.dfi_wrdata[(beat_idx * 8 * `DWC_NO_OF_BYTES) + (byte_idx * 8) +: 8];
        dbg_dfi_rddata_dx         [byte_idx][beat_idx * 8 +: 8] = `PHYDFI.dfi_rddata[(beat_idx * 8 * `DWC_NO_OF_BYTES) + (byte_idx * 8) +: 8];
        dbg_dfi_rddata_dx_per_beat[beat_idx][byte_idx * 8 +: 8] = `PHYDFI.dfi_rddata[(beat_idx * 8 * `DWC_NO_OF_BYTES) + (byte_idx * 8) +: 8];
      end
    end
  end

  // Build x4-lane segmented versions of `PHYDFI.dfi_wrdata (outgoing) and `PHYDFI.dfi_rddata (incoming)
  always @* begin : proc_dbg_dfi_data_x4
    integer beat_idx;
    integer lane_idx;
    for (lane_idx = 0; lane_idx < pNUM_LANES; lane_idx = lane_idx + 1) begin
      for (beat_idx = 0; beat_idx < pMEMCTL_NO_OF_BEATS; beat_idx = beat_idx + 1) begin
        dbg_dfi_wrdata_x4         [lane_idx][beat_idx * pDBEAT_WIDTH +: pDBEAT_WIDTH] = `PHYDFI.dfi_wrdata[(beat_idx * pDBEAT_WIDTH * pNUM_LANES) + (lane_idx * pDBEAT_WIDTH) +: pDBEAT_WIDTH];
        dbg_dfi_rddata_x4         [lane_idx][beat_idx * pDBEAT_WIDTH +: pDBEAT_WIDTH] = `PHYDFI.dfi_rddata[(beat_idx * pDBEAT_WIDTH * pNUM_LANES) + (lane_idx * pDBEAT_WIDTH) +: pDBEAT_WIDTH];
        dbg_dfi_rddata_x4_per_beat[beat_idx][lane_idx * pDBEAT_WIDTH +: pDBEAT_WIDTH] = `PHYDFI.dfi_rddata[(beat_idx * pDBEAT_WIDTH * pMEMCTL_NO_OF_BEATS) + (lane_idx * pDBEAT_WIDTH) +: pDBEAT_WIDTH];
      end
    end
  end

  localparam pDG_SL_WIDTH        = 3
  ,          pDG_LCDL_WIDTH      = 9
  ;
 
  reg  [pDG_LCDL_WIDTH - 1 : 0] dbg_dfi_gdqs_dly     [pNO_OF_LRANKS - 1 : 0] [pNUM_LANES - 1 : 0];
  reg  [pDG_SL_WIDTH   - 1 : 0] dbg_dfi_gdqs_rsl     [pNO_OF_LRANKS - 1 : 0] [pNUM_LANES - 1 : 0];
  reg  [3              - 1 : 0] dbg_dfi_in_wsl       [pNO_OF_LRANKS - 1 : 0] [pNUM_LANES - 1 : 0];
  reg  [1              - 1 : 0] dbg_dfi_in_wsl_ddr   [pNO_OF_LRANKS - 1 : 0] [pNUM_LANES - 1 : 0];
  reg  [4              - 1 : 0] dbg_dfi_in_wlsl      [pNO_OF_LRANKS - 1 : 0] [pNUM_LANES - 1 : 0];
  reg  [pDG_LCDL_WIDTH - 1 : 0] dbg_dfi_in_wl_dly    [pNO_OF_LRANKS - 1 : 0] [pNUM_LANES - 1 : 0];
  reg  [pDG_LCDL_WIDTH - 1 : 0] dbg_dfi_out_wl_dly                              [pNUM_LANES - 1 : 0];

  always @* begin : proc_dbg_gdqs_dly
    integer lane_idx;

    for (rank_idx = 0; rank_idx < pNO_OF_LRANKS; rank_idx = rank_idx + 1) begin
      for (lane_idx = 0; lane_idx < pNUM_LANES; lane_idx = lane_idx + 1) begin
        dbg_dfi_gdqs_dly[rank_idx][lane_idx] = `PHYDFI.gdqs_dly[(pNUM_LANES * pDG_LCDL_WIDTH * rank_idx) + (lane_idx * pDG_LCDL_WIDTH) +: pDG_LCDL_WIDTH];
        dbg_dfi_gdqs_rsl[rank_idx][lane_idx] = `PHYDFI.gdqs_rsl[(pNUM_LANES * pDG_SL_WIDTH   * rank_idx) + (lane_idx * pDG_SL_WIDTH  ) +: pDG_SL_WIDTH  ];
      end
    end
  end
 
/* -----\/----- EXCLUDED -----\/-----
  always @* begin : proc_dbg_wlsl
    integer lane_idx;

    for (lane_idx = 0; lane_idx < pNUM_LANES; lane_idx = lane_idx + 1) begin
      dbg_dfi_out_wl_dly [lane_idx] = `PHYDFI.chn[0].dx.dx_ctl.O_ctl_wl_dly[(lane_idx * pDG_LCDL_WIDTH) +: pDG_LCDL_WIDTH];
      for (rank_idx = 0; rank_idx < pNO_OF_LRANKS; rank_idx = rank_idx + 1) begin
        // Integer (CK clock period equivalent) portion of WLSL and DDR clock cycle equivalent delays
        dbg_dfi_in_wsl    [rank_idx][lane_idx] = `PHYDFI.chn[0].dx.dx_ctl.I_wl_wsl    [(pNUM_LANES * rank_idx * 3) + (lane_idx * 3) +: 3];
        dbg_dfi_in_wsl_ddr[rank_idx][lane_idx] = `PHYDFI.chn[0].dx.dx_ctl.I_wl_ddr_dly[(pNUM_LANES * rank_idx * 1) + (lane_idx * 1) +: 1];
        dbg_dfi_in_wlsl   [rank_idx][lane_idx] = {dbg_dfi_in_wsl[rank_idx][lane_idx], dbg_dfi_in_wsl_ddr[rank_idx][lane_idx]};
        // Write-leveling LCDL delay
        dbg_dfi_in_wl_dly[rank_idx][lane_idx] = `PHYDFI.wl_dly[(pNUM_LANES * pDG_LCDL_WIDTH * rank_idx) + (lane_idx * pDG_LCDL_WIDTH) +: pDG_LCDL_WIDTH];  
      end
    end
  end
 -----/\----- EXCLUDED -----/\----- */

  //// Gate Training Registers
  reg [5  - 1 : 0] dbg_DXnGTR_dgsl_per_lane     [pNUM_LANES - 1 : 0] [4 - 1 : 0];  // Fixed at 4 ranks
  reg [4  - 1 : 0] dbg_DXnGTR_wlsl_per_lane     [pNUM_LANES - 1 : 0] [4 - 1 : 0];  // Fixed at 4 ranks
  reg [9  - 1 : 0] dbg_DXnLCDLR0_wld_per_lane   [pNUM_LANES - 1 : 0] [4 - 1 : 0];  // Fixed at 4 ranks
  reg [9  - 1 : 0] dbg_DXnLCDLR2_dqsgd_per_lane [pNUM_LANES - 1 : 0] [4 - 1 : 0];  // Fixed at 4 ranks

  generate
    genvar gv_l_idx;
    genvar gv_r_idx;

    for (gv_l_idx = 0; gv_l_idx < pNUM_LANES; gv_l_idx = gv_l_idx + 1) begin : genblk_dbg_dxn_gate_per_lane
      for (gv_r_idx = 0; gv_r_idx < `DWC_NO_OF_RANKS; gv_r_idx = gv_r_idx + 1) begin : genblk_dbg_dxn_gate_per_lane
        always @* begin
          // GTR0 is indirect access per rank so we need to probe the signal that holds all ranks and all lanes
          dbg_DXnGTR_dgsl_per_lane    [gv_l_idx][gv_r_idx] = `PUB.u_DWC_ddrphy_cfg.i_cfg_dgsl_rdata_all_ranks   [(`DWC_NO_OF_RANKS * gv_l_idx * 5) + (gv_r_idx * 5) +: 5];
          dbg_DXnGTR_wlsl_per_lane    [gv_l_idx][gv_r_idx] = {  `PUB.u_DWC_ddrphy_cfg.i_cfg_wlsl_rdata_all_ranks[(`DWC_NO_OF_RANKS * gv_l_idx * 3) + (gv_r_idx * 3) +: 3]
                                                              , `PUB.u_DWC_ddrphy_cfg.i_cfg_wlddr_all_ranks     [(`DWC_NO_OF_RANKS * gv_l_idx * 1) + (gv_r_idx * 1) +: 1]
                                                             };
          dbg_DXnLCDLR0_wld_per_lane  [gv_l_idx][gv_r_idx] = `PUB.u_DWC_ddrphy_cfg.i_cfg_wld_rdata_all_ranks    [(`DWC_NO_OF_RANKS * gv_l_idx * 9) + (gv_r_idx * 9) +: 9];
          dbg_DXnLCDLR2_dqsgd_per_lane[gv_l_idx][gv_r_idx] = `PUB.u_DWC_ddrphy_cfg.i_cfg_gdqsd_rdata_all_ranks  [(`DWC_NO_OF_RANKS * gv_l_idx * 9) + (gv_r_idx * 9) +: 9];
        end
      end
    end
  endgenerate  

  //// DDRPHY_top DFI

  wire [4                    - 1 : 0] dbg_top_dfi_cmd_even;
  wire [8                    - 1 : 0] dbg_top_ddr4_dfi_cmd_even;
  wire [pNO_OF_CSNS          - 1 : 0] dbg_top_dfi_cs_n_even;
  reg  [pNO_OF_CSNS          - 1 : 0] dbg_top_dfi_cs_n_even_pn[pDDR4_CMD_LAT_MAX - 1 : 0];
  wire [4                    - 1 : 0] dbg_top_dfi_cmd_odd;
  wire [8                    - 1 : 0] dbg_top_ddr4_dfi_cmd_odd;
  wire [pNO_OF_CSNS          - 1 : 0] dbg_top_dfi_cs_n_odd;
  reg  [pNO_OF_CSNS          - 1 : 0] dbg_top_dfi_cs_n_odd_pn [pDDR4_CMD_LAT_MAX - 1 : 0];
  wire                                dbg_top_dfi_clk;
  wire [5                    - 1 : 0] dbg_top_dfi_lpddr2_cmd_even;
  wire [5                    - 1 : 0] dbg_top_dfi_lpddr2_cmd_odd;
  reg  [50*8                 - 1 : 0] dbg_top_dfi_lpddr2_cmd_even_str;
  reg  [50*8                 - 1 : 0] dbg_top_dfi_lpddr2_cmd_odd_str;

  reg  [(pNO_OF_DX_DQS * pMEMCTL_NO_OF_BEATS) - 1 : 0] dbg_top_dfi_wrdata_mask_dx    [`DWC_NO_OF_BYTES    - 1 : 0];
  reg  [(8 * pMEMCTL_NO_OF_BEATS)             - 1 : 0] dbg_top_dfi_wrdata_dx         [`DWC_NO_OF_BYTES    - 1 : 0];
  reg  [(8 * pMEMCTL_NO_OF_BEATS)             - 1 : 0] dbg_top_dfi_rddata_dx         [`DWC_NO_OF_BYTES    - 1 : 0];
  reg  [(8 * pNUM_LANES)                      - 1 : 0] dbg_top_dfi_rddata_dx_per_beat[pMEMCTL_NO_OF_BEATS - 1 : 0];
  reg  [(pNO_OF_DX_DQS * pMEMCTL_NO_OF_CMDS)  - 1 : 0] dbg_top_dfi_wrdata_en_dx      [`DWC_NO_OF_BYTES    - 1 : 0];
  reg  [(pNO_OF_DX_DQS * pMEMCTL_NO_OF_CMDS)  - 1 : 0] dbg_top_dfi_rddata_en_dx      [`DWC_NO_OF_BYTES    - 1 : 0];

  assign dbg_top_dfi_cs_n_even = `PHY_TOP.dfi_cs_n[pNO_OF_CSNS  -1:0];
  assign dbg_top_dfi_cmd_even  = { (&dbg_top_dfi_cs_n_even)
                                  ,`PHY_TOP.dfi_ras_n  [0]
                                  ,`PHY_TOP.dfi_cas_n  [0]
                                  ,`PHY_TOP.dfi_we_n   [0]
                                 };
  `ifdef DDR4
    assign dbg_top_ddr4_dfi_cmd_even = {  &dbg_phy_sdram_mr0_bl_otf
                                        , `PHY_TOP.dfi_address[12]
                                        , `PHY_TOP.dfi_address[10]
                                        , (&dbg_top_dfi_cs_n_even_pn[dbg_phy_sdram_mr3_cmd_lat[0]])
                                        , `PHY_TOP.dfi_act_n[0]
                                        , `PHY_TOP.dfi_ras_n[0]
                                        , `PHY_TOP.dfi_cas_n[0]
                                        , `PHY_TOP.dfi_we_n [0]
                                       };
  `endif

  assign dbg_top_dfi_lpddr2_cmd_even = { (&(`PHY_TOP.dfi_cs_n[pNO_OF_CSNS - 1 : 0]))
                                            ,`PHY_TOP.dfi_address[0]
                                            ,`PHY_TOP.dfi_address[1]
                                            ,`PHY_TOP.dfi_address[2]
                                            ,`PHY_TOP.dfi_address[3] 
                                          };
  always @*
    dbg_top_dfi_lpddr2_cmd_even_str = get_lpddr2_cmd_string(dbg_top_dfi_lpddr2_cmd_even);

  always @* begin
    dbg_top_dfi_cs_n_even_pn[0] = dbg_top_dfi_cs_n_even;
    dbg_top_dfi_cs_n_odd_pn [0] = dbg_top_dfi_cs_n_odd;
  end

  assign dbg_top_dfi_clk = (`PUB.u_DWC_ddrphy_cfg.cfg_dsgcr_sdrmode == 2'b01) ? `PHY_TOP.ctl_sdr_clk : `PHY_TOP.pub_ctl_clk;

  always @(posedge dbg_top_dfi_clk) begin
    // Keep pipelined copies of cs_n
    for (cidx = 1; cidx < pDDR4_CMD_LAT_MAX - 1; cidx = cidx + 1) begin
      dbg_top_dfi_cs_n_even_pn[cidx] <= dbg_top_dfi_cs_n_even_pn[cidx - 1];
      dbg_top_dfi_cs_n_odd_pn [cidx] <= dbg_top_dfi_cs_n_odd_pn [cidx - 1];
    end
  end

  // Build byte-lane segmented versions of PHYTOP.dfi_wrdata (outgoing) and PHYTOP.dfi_rddata (incoming)
  always @* begin : proc_dbg_top_dfi_data
    integer beat_idx;
    for (byte_idx = 0; byte_idx < `DWC_NO_OF_BYTES; byte_idx = byte_idx + 1) begin
      dbg_top_dfi_wrdata_en_dx[byte_idx] = {  `PHY_TOP.dfi_wrdata_en[(`DWC_NO_OF_BYTES * pNO_OF_DX_DQS) + (byte_idx * pNO_OF_DX_DQS) +: pNO_OF_DX_DQS] // Odd  phase
                                            , `PHY_TOP.dfi_wrdata_en[                                     (byte_idx * pNO_OF_DX_DQS) +: pNO_OF_DX_DQS] // Even phase
                                           };
      dbg_top_dfi_rddata_en_dx[byte_idx] = {  `PHY_TOP.dfi_rddata_en[(`DWC_NO_OF_BYTES * pNO_OF_DX_DQS) + (byte_idx * pNO_OF_DX_DQS) +: pNO_OF_DX_DQS] // Odd  phase
                                            , `PHY_TOP.dfi_rddata_en[                                     (byte_idx * pNO_OF_DX_DQS) +: pNO_OF_DX_DQS] // Even phase
                                           };
      for (beat_idx = 0; beat_idx < pMEMCTL_NO_OF_BEATS; beat_idx = beat_idx + 1) begin
        dbg_top_dfi_wrdata_mask_dx    [byte_idx][beat_idx * pNO_OF_DX_DQS +: pNO_OF_DX_DQS] = `PHY_TOP.dfi_wrdata_mask[(`DWC_NO_OF_BYTES * pNO_OF_DX_DQS * beat_idx) + (byte_idx * pNO_OF_DX_DQS) +: pNO_OF_DX_DQS];
        dbg_top_dfi_wrdata_dx         [byte_idx][beat_idx * 8 +: 8] = `PHY_TOP.dfi_wrdata[(beat_idx * 8 * `DWC_NO_OF_BYTES) + (byte_idx * 8) +: 8];
        dbg_top_dfi_rddata_dx         [byte_idx][beat_idx * 8 +: 8] = `PHY_TOP.dfi_rddata[(beat_idx * 8 * `DWC_NO_OF_BYTES) + (byte_idx * 8) +: 8];
        dbg_top_dfi_rddata_dx_per_beat[beat_idx][byte_idx * 8 +: 8] = `PHY_TOP.dfi_rddata[(beat_idx * 8 * `DWC_NO_OF_BYTES) + (byte_idx * 8) +: 8];
      end
    end
  end

`ifdef DWC_DDRPHY_HDR_MODE

  assign dbg_top_dfi_cs_n_odd  = `PHY_TOP.dfi_cs_n[(pNO_OF_CSNS*2)-1:pNO_OF_CSNS];
  assign dbg_top_dfi_cmd_odd = { (&dbg_top_dfi_cs_n_odd)
                                ,`PHY_TOP.dfi_ras_n  [1]
                                ,`PHY_TOP.dfi_cas_n  [1]
                                ,`PHY_TOP.dfi_we_n   [1]
                               };
  `ifdef DDR4
    assign dbg_top_ddr4_dfi_cmd_odd  = {  &dbg_phy_sdram_mr0_bl_otf
                                        , `PHY_TOP.dfi_address[`PHY_TOP.pXADDR_WIDTH + 12]
                                        , `PHY_TOP.dfi_address[`PHY_TOP.pXADDR_WIDTH + 10]
                                        , (&dbg_top_dfi_cs_n_odd_pn[dbg_phy_sdram_mr3_cmd_lat[0]])
                                        , `PHY_TOP.dfi_act_n[1]
                                        , `PHY_TOP.dfi_ras_n[1]
                                        , `PHY_TOP.dfi_cas_n[1]
                                        , `PHY_TOP.dfi_we_n [1]
                                       };
  `endif

  // LPDDR2 Mode
  assign dbg_top_dfi_lpddr2_cmd_odd = { (&(`PHY_TOP.dfi_cs_n[(pNO_OF_CSNS * 2) - 1 : pNO_OF_CSNS]))
                                            ,`PHY_TOP.dfi_address[20]
                                            ,`PHY_TOP.dfi_address[21]
                                            ,`PHY_TOP.dfi_address[22]
                                            ,`PHY_TOP.dfi_address[23] 
                                         };

  always @*
    dbg_top_dfi_lpddr2_cmd_odd_str = get_lpddr2_cmd_string(dbg_top_dfi_lpddr2_cmd_odd);

`else
  //// CTLDFI

  `define CTLDFI                      `PUB.u_DWC_ddrphy_scheduler.genblk_ctl2dfi.u_ctldfi

  wire [4                    - 1 : 0] dbg_ctldfi_cmd;
  wire [pNO_OF_CSNS     - 1 : 0] dbg_ctldfi_cs_n;

/*  assign dbg_ctldfi_cs_n = `CTLDFI.i_ctldfi_cs_n;
  assign dbg_ctldfi_cmd  = { (&dbg_ctldfi_cs_n)
                            ,`CTLDFI.i_ctldfi_ras_n
                            ,`CTLDFI.i_ctldfi_cas_n
                            ,`CTLDFI.i_ctldfi_we_n
                           };*/

`endif

  //// DCU
  localparam pDBG_CTL_RANK_WIDTH     = (pNO_OF_LRANKS > 8) ? 4 :
                                       (pNO_OF_LRANKS > 4) ? 3 :
                                       (pNO_OF_LRANKS > 2) ? 2 :
                                       (pNO_OF_LRANKS > 1) ? 1 : 0;
  localparam pDBG_CTL_ADDR_WIDTH     = `DWC_PHY_ADDR_WIDTH;
  localparam pDBG_CTL_BANK_WIDTH     = `DWC_PHY_BG_WIDTH + `DWC_PHY_BA_WIDTH;
  localparam pDBG_DCU_CTL_MASK_WIDTH = pNUM_LANES * 4;
  localparam pDBG_DCU_CTL_DATA_WIDTH = (1 * (8 * 4));
  localparam pDBG_DCU_EC_DATA_WIDTH  = pDBG_DCU_CTL_DATA_WIDTH;

   // Command Cache
   localparam
   // Controller buses: command, rank variables, address, data, data mask
     pCTL_DTP_WIDTH      = 5   // DRAM timing parameter
   , pCTL_TAG_WIDTH      = 2   // includes DDR3 BL4 NOP + all-ranks flag
   , pCTL_CMD_WIDTH      = 4
   , pCTL_RANK_WIDTH     = pDBG_CTL_RANK_WIDTH
   , pCTL_BANK_WIDTH     = pDBG_CTL_BANK_WIDTH
   , pCTL_ADDR_WIDTH     = pDBG_CTL_ADDR_WIDTH
   , pCTL_MASK_WIDTH     = pDBG_DCU_CTL_MASK_WIDTH
   , pCTL_DATA_WIDTH     = pDBG_DCU_CTL_DATA_WIDTH
   // Command cache may use a single byte-lane to drive the same data on all data lane
   , pCC_ONE_BL_DATA_EN  = 1  // Use single byte-lane of data and drive on all lanes
   , pDCU_CTL_DATA_WIDTH = (8 * 4)
   , pDCU_CTL_MASK_WIDTH = (1 * 4 * pNO_OF_DX_DQS)
   , pDCU_CTL_RQST_WIDTH =   pCTL_DTP_WIDTH
                           + pCTL_TAG_WIDTH       //   Command tag
                           + pCTL_CMD_WIDTH       // + command
                           + pCTL_RANK_WIDTH      // + addr
                           + pCTL_BANK_WIDTH
                           + pCTL_ADDR_WIDTH
                           + pDCU_CTL_MASK_WIDTH  // + mask
                           + pDCU_CTL_DATA_WIDTH  // + data
   , pCC_RQST_FIELD_WIDTH    = pDCU_CTL_RQST_WIDTH
   , pCC_RPTIDX_FIELD_WIDTH  = 3
   , pCC_DATA_WIDTH          =   pCC_RPTIDX_FIELD_WIDTH 
                               + pCC_RQST_FIELD_WIDTH
   , pSLICE_WIDTH           = `REG_DATA_WIDTH
   , pPARTIAL_SLICE_WIDTH   = pCC_DATA_WIDTH % pSLICE_WIDTH
   , pALL_FULL_SLICES_WIDTH = (pCC_DATA_WIDTH - pPARTIAL_SLICE_WIDTH)
   , pNUM_FULL_SLICES       = (pALL_FULL_SLICES_WIDTH / pSLICE_WIDTH)
   , pPARTIAL_SLICE_EN      = (pPARTIAL_SLICE_WIDTH > 0) ? 1 : 0
   , pNUM_TOT_SLICES        = (pNUM_FULL_SLICES + pPARTIAL_SLICE_EN)
   , pSLICE_SEL_WIDTH       = (pNUM_TOT_SLICES <=  2) ? 1 :
                              (pNUM_TOT_SLICES <=  4) ? 2 :
                              (pNUM_TOT_SLICES <=  8) ? 3 :
                              (pNUM_TOT_SLICES <= 16) ? 4 :
                                                        5   // Max 32 slices
   , pWW_PARTIAL_WRD_BIT_LO = (pPARTIAL_SLICE_EN == 1) ? pCC_DATA_WIDTH - pPARTIAL_SLICE_WIDTH :
                                                         0
   , pWW_PARTIAL_WRD_BIT_HI = (pPARTIAL_SLICE_EN == 1) ? pCC_DATA_WIDTH - 1 :
                                                         0
   ;

  wire [5                        - 1 : 0]  dbg_dcu_ctl_rqst_field_dtp;
  wire [2                        - 1 : 0]  dbg_dcu_ctl_rqst_field_tag;
  wire [4                        - 1 : 0]  dbg_dcu_ctl_rqst_field_cmd;
  wire [pDBG_CTL_RANK_WIDTH      - 1 : 0]  dbg_dcu_ctl_rqst_field_rank;
  wire [pDBG_CTL_BANK_WIDTH      - 1 : 0]  dbg_dcu_ctl_rqst_field_bank;
  wire [pDBG_CTL_ADDR_WIDTH      - 1 : 0]  dbg_dcu_ctl_rqst_field_addr;
  wire [pDBG_DCU_CTL_MASK_WIDTH  - 1 : 0]  dbg_dcu_ctl_rqst_field_mask;
  wire [pDBG_DCU_CTL_DATA_WIDTH  - 1 : 0]  dbg_dcu_ctl_rqst_field_data;

  assign {  dbg_dcu_ctl_rqst_field_dtp
          , dbg_dcu_ctl_rqst_field_tag
          , dbg_dcu_ctl_rqst_field_cmd
          , dbg_dcu_ctl_rqst_field_rank
          , dbg_dcu_ctl_rqst_field_bank
          , dbg_dcu_ctl_rqst_field_addr
          , dbg_dcu_ctl_rqst_field_mask
          , dbg_dcu_ctl_rqst_field_data
         } = `PUB.u_DWC_ddrphy_dcu.u_dcu_cmd_drv.fifo_wrdata;

  integer                                  dcucc_mem_idx;
  integer                                  slice_idx;
  reg  [3                        - 1 : 0]  dbg_dcu_cc_rqst_field_rpt  [`CCACHE_DEPTH - 1 : 0];
  reg  [5                        - 1 : 0]  dbg_dcu_cc_rqst_field_dtp  [`CCACHE_DEPTH - 1 : 0];
  reg  [2                        - 1 : 0]  dbg_dcu_cc_rqst_field_tag  [`CCACHE_DEPTH - 1 : 0];
  reg  [4                        - 1 : 0]  dbg_dcu_cc_rqst_field_cmd  [`CCACHE_DEPTH - 1 : 0];
  reg  [pDBG_CTL_RANK_WIDTH      - 1 : 0]  dbg_dcu_cc_rqst_field_rank [`CCACHE_DEPTH - 1 : 0];
  reg  [pDBG_CTL_BANK_WIDTH      - 1 : 0]  dbg_dcu_cc_rqst_field_bank [`CCACHE_DEPTH - 1 : 0];
  reg  [pDBG_CTL_ADDR_WIDTH      - 1 : 0]  dbg_dcu_cc_rqst_field_addr [`CCACHE_DEPTH - 1 : 0];
  reg  [pDBG_DCU_CTL_MASK_WIDTH  - 1 : 0]  dbg_dcu_cc_rqst_field_mask [`CCACHE_DEPTH - 1 : 0];
  reg  [pDBG_DCU_CTL_DATA_WIDTH  - 1 : 0]  dbg_dcu_cc_rqst_field_data [`CCACHE_DEPTH - 1 : 0];
  reg  [pCC_DATA_WIDTH           - 1 : 0]  dbg_dcu_cc_entry;

`ifdef GATE_LEVEL_SIM
`else
  always @* begin
    for (dcucc_mem_idx = 0; dcucc_mem_idx < `CCACHE_DEPTH; dcucc_mem_idx = dcucc_mem_idx + 1) begin
      if (pPARTIAL_SLICE_EN == 1)
        dbg_dcu_cc_entry[pWW_PARTIAL_WRD_BIT_HI : pWW_PARTIAL_WRD_BIT_LO] = `PUB.u_DWC_ddrphy_dcu.u_cmd_cache.mem_msb_pslice[dcucc_mem_idx];
      for (slice_idx = 0; slice_idx < pNUM_FULL_SLICES; slice_idx = slice_idx + 1) begin
        dbg_dcu_cc_entry[(slice_idx * pSLICE_WIDTH) +: pSLICE_WIDTH] = `PUB.u_DWC_ddrphy_dcu.u_cmd_cache.mem_slices[dcucc_mem_idx][slice_idx];
      end
      {  dbg_dcu_cc_rqst_field_rpt  [dcucc_mem_idx]
       , dbg_dcu_cc_rqst_field_dtp  [dcucc_mem_idx]
       , dbg_dcu_cc_rqst_field_tag  [dcucc_mem_idx]
       , dbg_dcu_cc_rqst_field_cmd  [dcucc_mem_idx]
       , dbg_dcu_cc_rqst_field_rank [dcucc_mem_idx]
       , dbg_dcu_cc_rqst_field_bank [dcucc_mem_idx]
       , dbg_dcu_cc_rqst_field_addr [dcucc_mem_idx]
       , dbg_dcu_cc_rqst_field_mask [dcucc_mem_idx]
       , dbg_dcu_cc_rqst_field_data [dcucc_mem_idx]
      } = dbg_dcu_cc_entry;
    end
  end

  //// Scheduler
  localparam pDBG_SCH_DTP_WIDTH   =  5;           // DRAM timing parameter
  localparam pDBG_SCH_TAG_WIDTH   =  2;           // command tag
  localparam pDBG_SCH_CMD_WIDTH   =  4;           // command
  localparam pDBG_SCH_RANK_WIDTH  =  pDBG_CTL_RANK_WIDTH;
  localparam pDBG_SCH_BANK_WIDTH  =  `DWC_BANK_WIDTH;
  localparam pDBG_SCH_ADDR_WIDTH  =  `DWC_ADDR_WIDTH;
  localparam pDBG_SCH_MASK_WIDTH  =  `DWC_DX_NO_OF_DQS;
  localparam pDBG_SCH_DATA_WIDTH  =  `PUB_DATA_TYPE_WIDTH;
  localparam pDBG_SCH_DATA_BIT_LO = 0;
  localparam pDBG_SCH_DATA_BIT_HI = pDBG_SCH_DATA_BIT_LO + pDBG_SCH_DATA_WIDTH - 1;
  localparam pDBG_SCH_MASK_BIT_LO = pDBG_SCH_DATA_BIT_HI + 1;
  localparam pDBG_SCH_MASK_BIT_HI = pDBG_SCH_MASK_BIT_LO + pDBG_SCH_MASK_WIDTH - 1;
  localparam pDBG_SCH_ADDR_BIT_LO = pDBG_SCH_MASK_BIT_HI + 1;
  localparam pDBG_SCH_ADDR_BIT_HI = pDBG_SCH_ADDR_BIT_LO + pDBG_SCH_ADDR_WIDTH - 1;
  localparam pDBG_SCH_BANK_BIT_LO = pDBG_SCH_ADDR_BIT_HI + 1;
  localparam pDBG_SCH_BANK_BIT_HI = pDBG_SCH_BANK_BIT_LO + pDBG_SCH_BANK_WIDTH - 1;
  localparam pDBG_SCH_RANK_BIT_LO = pDBG_SCH_BANK_BIT_HI + 1;
  localparam pDBG_SCH_RANK_BIT_HI = pDBG_SCH_RANK_BIT_LO + pDBG_SCH_RANK_WIDTH - 1;
  localparam pDBG_SCH_CMD_BIT_LO  = pDBG_SCH_RANK_BIT_HI + 1;
  localparam pDBG_SCH_CMD_BIT_HI  = pDBG_SCH_CMD_BIT_LO  + pDBG_SCH_CMD_WIDTH  - 1;
  localparam pDBG_SCH_TAG_BIT_LO  = pDBG_SCH_CMD_BIT_HI  + 1;
  localparam pDBG_SCH_TAG_BIT_HI  = pDBG_SCH_TAG_BIT_LO  + pDBG_SCH_TAG_WIDTH  - 1;
  localparam pDBG_SCH_DTP_BIT_LO  = pDBG_SCH_TAG_BIT_HI  + 1;
  localparam pDBG_SCH_DTP_BIT_HI  = pDBG_SCH_DTP_BIT_LO  + pDBG_SCH_DTP_WIDTH  - 1;

  wire  [pDBG_SCH_DTP_WIDTH  - 1 : 0] dbg_auto_rqst_d_DTP;
  wire  [pDBG_SCH_TAG_WIDTH  - 1 : 0] dbg_auto_rqst_d_TAG;
  wire  [pDBG_SCH_CMD_WIDTH  - 1 : 0] dbg_auto_rqst_d_CMD;
  wire  [pDBG_SCH_RANK_WIDTH - 1 : 0] dbg_auto_rqst_d_RANK;
  wire  [pDBG_SCH_BANK_WIDTH - 1 : 0] dbg_auto_rqst_d_BANK;
  wire  [pDBG_SCH_ADDR_WIDTH - 1 : 0] dbg_auto_rqst_d_ADDR;
  wire  [pDBG_SCH_MASK_WIDTH - 1 : 0] dbg_auto_rqst_d_MASK;
  wire  [pDBG_SCH_DATA_WIDTH - 1 : 0] dbg_auto_rqst_d_DATA;

  assign dbg_auto_rqst_d_DTP  = `PUB.u_DWC_ddrphy_scheduler.auto_rqst_d[pDBG_SCH_DTP_BIT_HI :pDBG_SCH_DTP_BIT_LO];
  assign dbg_auto_rqst_d_TAG  = `PUB.u_DWC_ddrphy_scheduler.auto_rqst_d[pDBG_SCH_TAG_BIT_HI :pDBG_SCH_TAG_BIT_LO];
  assign dbg_auto_rqst_d_CMD  = `PUB.u_DWC_ddrphy_scheduler.auto_rqst_d[pDBG_SCH_CMD_BIT_HI :pDBG_SCH_CMD_BIT_LO];
  assign dbg_auto_rqst_d_BANK = `PUB.u_DWC_ddrphy_scheduler.auto_rqst_d[pDBG_SCH_BANK_BIT_HI:pDBG_SCH_BANK_BIT_LO];
  assign dbg_auto_rqst_d_ADDR = `PUB.u_DWC_ddrphy_scheduler.auto_rqst_d[pDBG_SCH_ADDR_BIT_HI:pDBG_SCH_ADDR_BIT_LO];
  assign dbg_auto_rqst_d_MASK = `PUB.u_DWC_ddrphy_scheduler.auto_rqst_d[pDBG_SCH_MASK_BIT_HI:pDBG_SCH_MASK_BIT_LO];
  assign dbg_auto_rqst_d_DATA = `PUB.u_DWC_ddrphy_scheduler.auto_rqst_d[pDBG_SCH_DATA_BIT_HI:pDBG_SCH_DATA_BIT_LO];
  generate
    if (pNO_OF_PRANKS > 1) begin
      assign dbg_auto_rqst_d_RANK = `PUB.u_DWC_ddrphy_scheduler.auto_rqst_d[pDBG_SCH_RANK_BIT_HI:pDBG_SCH_RANK_BIT_LO];
    end else begin
      assign dbg_auto_rqst_d_RANK = 0;
    end
  endgenerate

`endif // XILINX Emulation

`endif // ifndef DWC_DDRPHY_GATE_SIM_EXCEPT
`endif // `ifndef GATE_LEVEL_SIM
   //---------------------------------------------------------------------------
  // Vectors and Logs
  //---------------------------------------------------------------------------

  // Miscellaneous Vectors
  // ---------------------
  // Vectros to be used by other tools
`ifdef VCD_DUMP
  `ifdef POWER_VECTORS
  // Vectros for power analysis - dump region is controlled from a power analysis testcase
  initial
    begin
      $dumpoff;
    `ifdef VCD_DUMP_ALL
      `ifdef DWC_BLOCK_DX
      $display("DEBUG in DX");
      $dumpvars(0, `DX0);
      `else
      $display("DEBUG in AC");
      $dumpvars(0, `AC);
      `endif
    `endif // !ifdef VCD_DUMP_ALL
    end // initial begin
  `else
  initial
    begin
      $dumpvars;
    end
  `endif
`else // !ifdef VCD_DUMP
  `ifdef MIXED_SIM
  // for mixed simulation, we still dump all signals for debug purposes
  initial
    begin
      $dumpvars;
    end
  `endif
`endif // ifdef VCD_DUMP

// extended VCD for AC/DATX8 fault grading
`ifdef EXTENDED_VCD_DUMP
  initial
    begin
      fork
        $dumpports(`AC,  `AC_VCDE_FILE);
        $dumpports(`DX0, `DX_VCDE_FILE);
      join
    end
`endif

`ifdef MODELSIM
  initial begin
    $wlfdumpvars(2, `CHIP);
  end
`endif


`ifdef LSI_VCD_DUMP
  initial $lsi_dumpports(`CHIP, `TC_VCD_FILE);
`endif

// SVB Vectors
// -----------
// strobed just after the positive edge of the clock
`ifdef SVB_VECTORS
  always @(posedge `CHIP.t_clk) begin
    if (svb_vector_enable === 1'b1) begin
      #`TESTER_STROBE_POS;
      $fdisplay(svb_vec_file_ptr, "%b", { `CHIP.t_clk,
                                          `CHIP.t_rst_n,
                                          `CHIP.t_en,
                                          `CHIP.t_inst,
                                          `CHIP.t_di,
                                          `CHIP.t_do,
                                          1'b0,
                                          1'b0
                                        }
               );
    end //if svb_tester_enable
  end

`endif // ifdef SVB_VECTORS
   
  
  // VCS/NC Verilog Post-Processing
  //-------------------------------
  // dump all signals for post-processing, i.e. the simulation is run in batch 
  // mode, and the waveforms are viewed later when needed;

  // VCS
  // to enable the dump, compile with the option +define+vcdpluson, or run with
  // the Plusarg option +vcdpluson (e.g. simv +vcdpluson) - in the later case
  // you only need to compile once!
  // info will by default be in file vcdplus.vpd, or you can specify the file
`ifdef vcdpluson
    initial
      begin
// BUG 4073 - temp workaround for regression/interactive difference issues
  `ifdef vcdplusmemon
        // Dump all multi-dimensional signal arrays under this hierarchy
        $vcdplusmemon(`PUB);
        $vcdplusmemon(`SYS);
        //$vcdplusmemon(`PHY);
        //$vcdplusmemon(`EYE_MNT);
        $vcdplusmemon(tc);
        $vcdplusmemon(`DDR_MNT);
        $vcdplusmemon(`GRM);
        $vcdplusmemon(`MCTL);
        $vcdplusmemon(`TB.dwc_dimm[0].u_ddr_rank.dwc_rank[0].sdram_rank.dwc_sdram[0].xn_dram.u_sdram);
    `ifdef DWC_DDRPHY_BOARD_DELAYS
        $vcdplusmemon(`TB.u_ddr_board_cfg);
    `endif
  `endif
  `ifdef vcdpluson
        $vcdpluson(tc);
//          $vcdpluson(0, tc.ddr_tb.dwc_rank[0].u_ddr_rank.dwc_sdram[0].xn_dram.u_sdram.sdram);
  `else
        if ($test$plusargs("vcdpluson"))
          begin
            $vcdpluson(tc);
          end
  `endif
// BUG 4073 - temp workaround for regression/interactive difference issues
      end
`endif

  // NC Verilog
  // compile with +define+simvision
`ifdef simvision
    initial
      begin
  `ifdef NCVERILOG
        $shm_open(`SHM_NCWAVE_FILE);
  `endif
  `ifdef VERILOGXL
        $shm_open(`SHM_XLWAVE_FILE);
  `endif
        // AS: in current scope and below, exclude library cells
        // ACMTF: include almost everything: memories, library cells, tasks
        //        and functions
        //$shm_probe(`TB, "AS");
        $shm_probe(tc, "ACMTF");
      end
`endif

`ifdef novas
  initial begin
    $fsdbDumpvars();
    $fsdbDumpMDA(`PUB);
    $fsdbDumpMDA(`SYS);
    $fsdbDumpMDA(1, tc);
  end
`endif

`ifdef DWC_DDRPHY_EMUL_XILINX
  `ifdef SDF_ANNOTATE
     `ifdef SDF_SLOW
        $sdf_annotate(`EMUL_SDF_FILE, `PHY   ,, "emul_ddrphy_sdf.log", "MAXIMUM");
     `endif  
     `ifdef SDF_FAST
        $sdf_annotate(`EMUL_SDF_FILE, `PHY   ,, "emul_ddrphy_sdf.log", "MINIMUM");
     `endif  
  `endif  
`else
  //---------------------------------------------------------------------------
  // SDF Annotation
  //---------------------------------------------------------------------------
  // annotate all AC and DATX modules
  `ifdef SDF_ANNOTATE
  initial begin
    `ifdef DWC_DDRPHY_ACX48
    $sdf_annotate(`ACX48_SDF_FILE, `AC   ,, "ac_sdf.log", "MAXIMUM");
    `else
    $sdf_annotate(`AC_SDF_FILE, `AC   ,, "ac_sdf.log", "MAXIMUM");
    `endif
  end

  generate
    for (dwc_byte=0; dwc_byte<`DWC_NO_OF_BYTES; dwc_byte=dwc_byte+1) begin: dwc_dx_sdf
      initial begin
    `ifdef DWC_DDRPHY_X4X2
        $sdf_annotate(`DX4_SDF_FILE, `DXn_inst,, "dx_sdf.log", "MAXIMUM");
    `else
        $sdf_annotate(`DX_SDF_FILE, `DXn_inst,, "dx_sdf.log", "MAXIMUM");
    `endif
      end
    end
  endgenerate


  // disable timing checks on
  // ------------------------
  // first flop of 2-stage synchronizer for AC loopback enable;
  // first flop of 2-stage synchronizer for AC loopback write ponter;
  // first flop of 2-stage synchronizer for AC loopback FIFO
  initial
    begin
      force `AC.ac_ctrl.lbwptr_ff_p0.NOTIFIER = 1'b0;
      $disable_warnings("timing",`AC.ac_ctrl.lbwptr_ff_p0);
      force `AC.ac_ctrl.lben_ff0.NOTIFIER = 1'b0;
      $disable_warnings("timing",`AC.ac_ctrl.lben_ff0);
    end

  generate
    for (dwc_byte=0; dwc_byte<`DWC_NO_OF_BYTES; dwc_byte=dwc_byte+1)
      initial
	    begin
          force `DXn_inst.`DX_DQS0.qs_n_ptr_sync_reg_0.NOTIFIER = 1'b0;
          $disable_warnings("timing",`DXn_inst.`DX_DQS0.qs_n_ptr_sync_reg_0);
          force `DXn_inst.`DX_DQS0.qs_n_ptr_sync_reg_1.NOTIFIER = 1'b0;
          $disable_warnings("timing",`DXn_inst.`DX_DQS0.qs_n_ptr_sync_reg_1);

`ifdef DWC_DDRPHY_X4X2
          force `DXn_inst.`DX_DQS1.qs_n_ptr_sync_reg_0.NOTIFIER = 1'b0;
          $disable_warnings("timing",`DXn_inst.`DX_DQS1.qs_n_ptr_sync_reg_0);
          force `DXn_inst.`DX_DQS1.qs_n_ptr_sync_reg_1.NOTIFIER = 1'b0;
          $disable_warnings("timing",`DXn_inst.`DX_DQS1.qs_n_ptr_sync_reg_1);
`endif
  	    end
  endgenerate

  // some special flops that may have timing violations during calibration;
  // release the force after calibration so that the timing is checked; same with DQS gate training 
  always@(force_notifiers)
    begin
      force `AC.ac_sctrl.ac_ddr_cnt.ddr_d_ld_0_ff.NOTIFIER = 1'b0;
      $disable_warnings("timing",`AC.ac_sctrl.ac_ddr_cnt.ddr_d_ld_0_ff);
      force `AC.ac_sctrl.ck_ddr_cnt.ddr_d_ld_0_ff.NOTIFIER = 1'b0;
      $disable_warnings("timing",`AC.ac_sctrl.ck_ddr_cnt.ddr_d_ld_0_ff);

      force `AC.ac_sctrl.ac_ddr_cnt.ddr_d_ld_1_ff.NOTIFIER = 1'b0;
      $disable_warnings("timing",`AC.ac_sctrl.ac_ddr_cnt.ddr_d_ld_1_ff);
      force `AC.ac_sctrl.ck_ddr_cnt.ddr_d_ld_1_ff.NOTIFIER = 1'b0;
      $disable_warnings("timing",`AC.ac_sctrl.ck_ddr_cnt.ddr_d_ld_1_ff);

      force `AC.ac_clkgen.ac_dly_pipe.dly_p2_regx9.ff_8.NOTIFIER = 1'b0;
      $disable_warnings("timing",`AC.ac_clkgen.ac_dly_pipe.dly_p2_regx9.ff_8);
      force `AC.ac_clkgen.ac_dly_pipe.dly_p2_regx9.ff_7.NOTIFIER = 1'b0;
      $disable_warnings("timing",`AC.ac_clkgen.ac_dly_pipe.dly_p2_regx9.ff_7);
      force `AC.ac_clkgen.ac_dly_pipe.dly_p2_regx9.ff_6.NOTIFIER = 1'b0;
      $disable_warnings("timing",`AC.ac_clkgen.ac_dly_pipe.dly_p2_regx9.ff_6);
      force `AC.ac_clkgen.ac_dly_pipe.dly_p2_regx9.ff_5.NOTIFIER = 1'b0;
      $disable_warnings("timing",`AC.ac_clkgen.ac_dly_pipe.dly_p2_regx9.ff_5);
      force `AC.ac_clkgen.ac_dly_pipe.dly_p2_regx9.ff_4.NOTIFIER = 1'b0;
      $disable_warnings("timing",`AC.ac_clkgen.ac_dly_pipe.dly_p2_regx9.ff_4);
      force `AC.ac_clkgen.ac_dly_pipe.dly_p2_regx9.ff_3.NOTIFIER = 1'b0;
      $disable_warnings("timing",`AC.ac_clkgen.ac_dly_pipe.dly_p2_regx9.ff_3);
      force `AC.ac_clkgen.ac_dly_pipe.dly_p2_regx9.ff_2.NOTIFIER = 1'b0;
      $disable_warnings("timing",`AC.ac_clkgen.ac_dly_pipe.dly_p2_regx9.ff_2);
      force `AC.ac_clkgen.ac_dly_pipe.dly_p2_regx9.ff_1.NOTIFIER = 1'b0;
      $disable_warnings("timing",`AC.ac_clkgen.ac_dly_pipe.dly_p2_regx9.ff_1);
      force `AC.ac_clkgen.ac_dly_pipe.dly_p2_regx9.ff_0.NOTIFIER = 1'b0;
      $disable_warnings("timing",`AC.ac_clkgen.ac_dly_pipe.dly_p2_regx9.ff_0);

      force `AC.ac_ctrl.ddl_test.osc_lu.NOTIFIER = 1'b0;
      $disable_warnings("timing",`AC.ac_ctrl.ddl_test.osc_lu);

      force `AC.ac_0.phy_reg.NOTIFIER = 1'b0;
      $disable_warnings("timing",`AC.ac_0.phy_reg);
      force `AC.ac_1.phy_reg.NOTIFIER = 1'b0;
      $disable_warnings("timing",`AC.ac_1.phy_reg);
      force `AC.ac_2.phy_reg.NOTIFIER = 1'b0;
      $disable_warnings("timing",`AC.ac_2.phy_reg);
      force `AC.ac_3.phy_reg.NOTIFIER = 1'b0;
      $disable_warnings("timing",`AC.ac_3.phy_reg);
      force `AC.ac_4.phy_reg.NOTIFIER = 1'b0;
      $disable_warnings("timing",`AC.ac_4.phy_reg);
      force `AC.ac_5.phy_reg.NOTIFIER = 1'b0;
      $disable_warnings("timing",`AC.ac_5.phy_reg);
      force `AC.ac_6.phy_reg.NOTIFIER = 1'b0;
      $disable_warnings("timing",`AC.ac_6.phy_reg);
      force `AC.ac_7.phy_reg.NOTIFIER = 1'b0;
      $disable_warnings("timing",`AC.ac_7.phy_reg);
      force `AC.ac_8.phy_reg.NOTIFIER = 1'b0;
      $disable_warnings("timing",`AC.ac_8.phy_reg);
      force `AC.ac_9.phy_reg.NOTIFIER = 1'b0;
      $disable_warnings("timing",`AC.ac_9.phy_reg);
      force `AC.ac_10.phy_reg.NOTIFIER = 1'b0;
      $disable_warnings("timing",`AC.ac_10.phy_reg);
      force `AC.ac_11.phy_reg.NOTIFIER = 1'b0;
      $disable_warnings("timing",`AC.ac_11.phy_reg);
      force `AC.ac_12.phy_reg.NOTIFIER = 1'b0;
      $disable_warnings("timing",`AC.ac_12.phy_reg);
      force `AC.ac_13.phy_reg.NOTIFIER = 1'b0;
      $disable_warnings("timing",`AC.ac_13.phy_reg);
      force `AC.ac_14.phy_reg.NOTIFIER = 1'b0;
      $disable_warnings("timing",`AC.ac_14.phy_reg);
      force `AC.ac_15.phy_reg.NOTIFIER = 1'b0;
      $disable_warnings("timing",`AC.ac_15.phy_reg);
      force `AC.ac_16.phy_reg.NOTIFIER = 1'b0;
      $disable_warnings("timing",`AC.ac_16.phy_reg);
      force `AC.ac_17.phy_reg.NOTIFIER = 1'b0;
      $disable_warnings("timing",`AC.ac_17.phy_reg);
      force `AC.ac_18.phy_reg.NOTIFIER = 1'b0;
      $disable_warnings("timing",`AC.ac_18.phy_reg);
      force `AC.ac_19.phy_reg.NOTIFIER = 1'b0;
      $disable_warnings("timing",`AC.ac_19.phy_reg);
      force `AC.ac_20.phy_reg.NOTIFIER = 1'b0;
      $disable_warnings("timing",`AC.ac_20.phy_reg);
      force `AC.ac_21.phy_reg.NOTIFIER = 1'b0;
      $disable_warnings("timing",`AC.ac_21.phy_reg);
      force `AC.ac_22.phy_reg.NOTIFIER = 1'b0;
      $disable_warnings("timing",`AC.ac_22.phy_reg);
      force `AC.ac_23.phy_reg.NOTIFIER = 1'b0;
      $disable_warnings("timing",`AC.ac_23.phy_reg);
      force `AC.ac_24.phy_reg.NOTIFIER = 1'b0;
      $disable_warnings("timing",`AC.ac_24.phy_reg);
      force `AC.ac_25.phy_reg.NOTIFIER = 1'b0;
      $disable_warnings("timing",`AC.ac_25.phy_reg);
      force `AC.ac_26.phy_reg.NOTIFIER = 1'b0;
      $disable_warnings("timing",`AC.ac_26.phy_reg);
      force `AC.ac_27.phy_reg.NOTIFIER = 1'b0;
      $disable_warnings("timing",`AC.ac_27.phy_reg);
      force `AC.ac_28.phy_reg.NOTIFIER = 1'b0;
      $disable_warnings("timing",`AC.ac_28.phy_reg);
      force `AC.ac_29.phy_reg.NOTIFIER = 1'b0;
      $disable_warnings("timing",`AC.ac_29.phy_reg);
      force `AC.ac_30.phy_reg.NOTIFIER = 1'b0;
      $disable_warnings("timing",`AC.ac_30.phy_reg);
      force `AC.ac_31.phy_reg.NOTIFIER = 1'b0;
      $disable_warnings("timing",`AC.ac_31.phy_reg);
      force `AC.ac_32.phy_reg.NOTIFIER = 1'b0;
      $disable_warnings("timing",`AC.ac_32.phy_reg);
      force `AC.ac_33.phy_reg.NOTIFIER = 1'b0;
      $disable_warnings("timing",`AC.ac_33.phy_reg);
      force `AC.ac_34.phy_reg.NOTIFIER = 1'b0;
      $disable_warnings("timing",`AC.ac_34.phy_reg);
      force `AC.ac_35.phy_reg.NOTIFIER = 1'b0;
      $disable_warnings("timing",`AC.ac_35.phy_reg);
    end

  generate
    for (dwc_byte=0; dwc_byte<`DWC_NO_OF_BYTES; dwc_byte=dwc_byte+1)
      begin :gen_dx8_force_declaration
        always@(force_notifiers)
          begin
            // CDC in the read data fifo from qs_clk to phy_clk
            force `DXn_inst.datx8_dq_0.qs_fifo_0.phy_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_0.qs_fifo_0.phy_ff);
            force `DXn_inst.datx8_dq_1.qs_fifo_0.phy_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_1.qs_fifo_0.phy_ff);
            force `DXn_inst.datx8_dq_2.qs_fifo_0.phy_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_2.qs_fifo_0.phy_ff);
            force `DXn_inst.datx8_dq_3.qs_fifo_0.phy_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_3.qs_fifo_0.phy_ff);
            force `DXn_inst.datx8_dq_4.qs_fifo_0.phy_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_4.qs_fifo_0.phy_ff);
            force `DXn_inst.datx8_dq_5.qs_fifo_0.phy_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_5.qs_fifo_0.phy_ff);
            force `DXn_inst.datx8_dq_6.qs_fifo_0.phy_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_6.qs_fifo_0.phy_ff);
            force `DXn_inst.datx8_dq_7.qs_fifo_0.phy_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_7.qs_fifo_0.phy_ff);
            force `DXn_inst.datx8_dq_8.qs_fifo_0.phy_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_8.qs_fifo_0.phy_ff);
            force `DXn_inst.datx8_dq_0.qs_fifo_1.phy_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_0.qs_fifo_1.phy_ff);
            force `DXn_inst.datx8_dq_1.qs_fifo_1.phy_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_1.qs_fifo_1.phy_ff);
            force `DXn_inst.datx8_dq_2.qs_fifo_1.phy_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_2.qs_fifo_1.phy_ff);
            force `DXn_inst.datx8_dq_3.qs_fifo_1.phy_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_3.qs_fifo_1.phy_ff);
            force `DXn_inst.datx8_dq_4.qs_fifo_1.phy_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_4.qs_fifo_1.phy_ff);
            force `DXn_inst.datx8_dq_5.qs_fifo_1.phy_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_5.qs_fifo_1.phy_ff);
            force `DXn_inst.datx8_dq_6.qs_fifo_1.phy_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_6.qs_fifo_1.phy_ff);
            force `DXn_inst.datx8_dq_7.qs_fifo_1.phy_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_7.qs_fifo_1.phy_ff);
            force `DXn_inst.datx8_dq_8.qs_fifo_1.phy_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_8.qs_fifo_1.phy_ff);
            force `DXn_inst.datx8_dq_0.qs_fifo_2.phy_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_0.qs_fifo_2.phy_ff);
            force `DXn_inst.datx8_dq_1.qs_fifo_2.phy_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_1.qs_fifo_2.phy_ff);
            force `DXn_inst.datx8_dq_2.qs_fifo_2.phy_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_2.qs_fifo_2.phy_ff);
            force `DXn_inst.datx8_dq_3.qs_fifo_2.phy_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_3.qs_fifo_2.phy_ff);
            force `DXn_inst.datx8_dq_4.qs_fifo_2.phy_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_4.qs_fifo_2.phy_ff);
            force `DXn_inst.datx8_dq_5.qs_fifo_2.phy_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_5.qs_fifo_2.phy_ff);
            force `DXn_inst.datx8_dq_6.qs_fifo_2.phy_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_6.qs_fifo_2.phy_ff);
            force `DXn_inst.datx8_dq_7.qs_fifo_2.phy_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_7.qs_fifo_2.phy_ff);
            force `DXn_inst.datx8_dq_8.qs_fifo_2.phy_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_8.qs_fifo_2.phy_ff);
            force `DXn_inst.datx8_dq_0.qs_fifo_3.phy_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_0.qs_fifo_3.phy_ff);
            force `DXn_inst.datx8_dq_1.qs_fifo_3.phy_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_1.qs_fifo_3.phy_ff);
            force `DXn_inst.datx8_dq_2.qs_fifo_3.phy_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_2.qs_fifo_3.phy_ff);
            force `DXn_inst.datx8_dq_3.qs_fifo_3.phy_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_3.qs_fifo_3.phy_ff);
            force `DXn_inst.datx8_dq_4.qs_fifo_3.phy_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_4.qs_fifo_3.phy_ff);
            force `DXn_inst.datx8_dq_5.qs_fifo_3.phy_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_5.qs_fifo_3.phy_ff);
            force `DXn_inst.datx8_dq_6.qs_fifo_3.phy_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_6.qs_fifo_3.phy_ff);
            force `DXn_inst.datx8_dq_7.qs_fifo_3.phy_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_7.qs_fifo_3.phy_ff);
            force `DXn_inst.datx8_dq_8.qs_fifo_3.phy_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_8.qs_fifo_3.phy_ff);

`ifdef DWC_DDRPHY_X4X2
            force `DXn_inst.datx8_dq_9.qs_fifo_3.phy_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_9.qs_fifo_3.phy_ff);
            force `DXn_inst.datx8_dq_9.qs_fifo_2.phy_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_9.qs_fifo_2.phy_ff);
            force `DXn_inst.datx8_dq_9.qs_fifo_1.phy_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_9.qs_fifo_1.phy_ff);
            force `DXn_inst.datx8_dq_9.qs_fifo_0.phy_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_9.qs_fifo_0.phy_ff);
`endif


            // Some flops in the read FIFO may violate during training as the DQS gate or DQS or DQ are moved
            // around; same with QS/QSN pointer flops
            force `DXn_inst.datx8_dq_0.qs_fifo_0.qs_n_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_0.qs_fifo_0.qs_n_ff_0);
            force `DXn_inst.datx8_dq_1.qs_fifo_0.qs_n_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_1.qs_fifo_0.qs_n_ff_0);
            force `DXn_inst.datx8_dq_2.qs_fifo_0.qs_n_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_2.qs_fifo_0.qs_n_ff_0);
            force `DXn_inst.datx8_dq_3.qs_fifo_0.qs_n_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_3.qs_fifo_0.qs_n_ff_0);
            force `DXn_inst.datx8_dq_4.qs_fifo_0.qs_n_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_4.qs_fifo_0.qs_n_ff_0);
            force `DXn_inst.datx8_dq_5.qs_fifo_0.qs_n_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_5.qs_fifo_0.qs_n_ff_0);
            force `DXn_inst.datx8_dq_6.qs_fifo_0.qs_n_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_6.qs_fifo_0.qs_n_ff_0);
            force `DXn_inst.datx8_dq_7.qs_fifo_0.qs_n_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_7.qs_fifo_0.qs_n_ff_0);
            force `DXn_inst.datx8_dq_8.qs_fifo_0.qs_n_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_8.qs_fifo_0.qs_n_ff_0);
            force `DXn_inst.datx8_dq_0.qs_fifo_1.qs_n_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_0.qs_fifo_1.qs_n_ff_0);
            force `DXn_inst.datx8_dq_1.qs_fifo_1.qs_n_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_1.qs_fifo_1.qs_n_ff_0);
            force `DXn_inst.datx8_dq_2.qs_fifo_1.qs_n_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_2.qs_fifo_1.qs_n_ff_0);
            force `DXn_inst.datx8_dq_3.qs_fifo_1.qs_n_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_3.qs_fifo_1.qs_n_ff_0);
            force `DXn_inst.datx8_dq_4.qs_fifo_1.qs_n_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_4.qs_fifo_1.qs_n_ff_0);
            force `DXn_inst.datx8_dq_5.qs_fifo_1.qs_n_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_5.qs_fifo_1.qs_n_ff_0);
            force `DXn_inst.datx8_dq_6.qs_fifo_1.qs_n_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_6.qs_fifo_1.qs_n_ff_0);
            force `DXn_inst.datx8_dq_7.qs_fifo_1.qs_n_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_7.qs_fifo_1.qs_n_ff_0);
            force `DXn_inst.datx8_dq_8.qs_fifo_1.qs_n_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_8.qs_fifo_1.qs_n_ff_0);
            force `DXn_inst.datx8_dq_0.qs_fifo_2.qs_n_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_0.qs_fifo_2.qs_n_ff_0);
            force `DXn_inst.datx8_dq_1.qs_fifo_2.qs_n_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_1.qs_fifo_2.qs_n_ff_0);
            force `DXn_inst.datx8_dq_2.qs_fifo_2.qs_n_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_2.qs_fifo_2.qs_n_ff_0);
            force `DXn_inst.datx8_dq_3.qs_fifo_2.qs_n_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_3.qs_fifo_2.qs_n_ff_0);
            force `DXn_inst.datx8_dq_4.qs_fifo_2.qs_n_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_4.qs_fifo_2.qs_n_ff_0);
            force `DXn_inst.datx8_dq_5.qs_fifo_2.qs_n_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_5.qs_fifo_2.qs_n_ff_0);
            force `DXn_inst.datx8_dq_6.qs_fifo_2.qs_n_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_6.qs_fifo_2.qs_n_ff_0);
            force `DXn_inst.datx8_dq_7.qs_fifo_2.qs_n_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_7.qs_fifo_2.qs_n_ff_0);
            force `DXn_inst.datx8_dq_8.qs_fifo_2.qs_n_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_8.qs_fifo_2.qs_n_ff_0);
            force `DXn_inst.datx8_dq_0.qs_fifo_3.qs_n_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_0.qs_fifo_3.qs_n_ff_0);
            force `DXn_inst.datx8_dq_1.qs_fifo_3.qs_n_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_1.qs_fifo_3.qs_n_ff_0);
            force `DXn_inst.datx8_dq_2.qs_fifo_3.qs_n_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_2.qs_fifo_3.qs_n_ff_0);
            force `DXn_inst.datx8_dq_3.qs_fifo_3.qs_n_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_3.qs_fifo_3.qs_n_ff_0);
            force `DXn_inst.datx8_dq_4.qs_fifo_3.qs_n_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_4.qs_fifo_3.qs_n_ff_0);
            force `DXn_inst.datx8_dq_5.qs_fifo_3.qs_n_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_5.qs_fifo_3.qs_n_ff_0);
            force `DXn_inst.datx8_dq_6.qs_fifo_3.qs_n_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_6.qs_fifo_3.qs_n_ff_0);
            force `DXn_inst.datx8_dq_7.qs_fifo_3.qs_n_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_7.qs_fifo_3.qs_n_ff_0);
            force `DXn_inst.datx8_dq_8.qs_fifo_3.qs_n_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_8.qs_fifo_3.qs_n_ff_0);

            force `DXn_inst.datx8_dq_0.qs_fifo_0.qs_n_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_0.qs_fifo_0.qs_n_ff_1);
            force `DXn_inst.datx8_dq_1.qs_fifo_0.qs_n_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_1.qs_fifo_0.qs_n_ff_1);
            force `DXn_inst.datx8_dq_2.qs_fifo_0.qs_n_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_2.qs_fifo_0.qs_n_ff_1);
            force `DXn_inst.datx8_dq_3.qs_fifo_0.qs_n_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_3.qs_fifo_0.qs_n_ff_1);
            force `DXn_inst.datx8_dq_4.qs_fifo_0.qs_n_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_4.qs_fifo_0.qs_n_ff_1);
            force `DXn_inst.datx8_dq_5.qs_fifo_0.qs_n_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_5.qs_fifo_0.qs_n_ff_1);
            force `DXn_inst.datx8_dq_6.qs_fifo_0.qs_n_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_6.qs_fifo_0.qs_n_ff_1);
            force `DXn_inst.datx8_dq_7.qs_fifo_0.qs_n_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_7.qs_fifo_0.qs_n_ff_1);
            force `DXn_inst.datx8_dq_8.qs_fifo_0.qs_n_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_8.qs_fifo_0.qs_n_ff_1);
            force `DXn_inst.datx8_dq_0.qs_fifo_1.qs_n_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_0.qs_fifo_1.qs_n_ff_1);
            force `DXn_inst.datx8_dq_1.qs_fifo_1.qs_n_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_1.qs_fifo_1.qs_n_ff_1);
            force `DXn_inst.datx8_dq_2.qs_fifo_1.qs_n_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_2.qs_fifo_1.qs_n_ff_1);
            force `DXn_inst.datx8_dq_3.qs_fifo_1.qs_n_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_3.qs_fifo_1.qs_n_ff_1);
            force `DXn_inst.datx8_dq_4.qs_fifo_1.qs_n_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_4.qs_fifo_1.qs_n_ff_1);
            force `DXn_inst.datx8_dq_5.qs_fifo_1.qs_n_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_5.qs_fifo_1.qs_n_ff_1);
            force `DXn_inst.datx8_dq_6.qs_fifo_1.qs_n_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_6.qs_fifo_1.qs_n_ff_1);
            force `DXn_inst.datx8_dq_7.qs_fifo_1.qs_n_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_7.qs_fifo_1.qs_n_ff_1);
            force `DXn_inst.datx8_dq_8.qs_fifo_1.qs_n_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_8.qs_fifo_1.qs_n_ff_1);
            force `DXn_inst.datx8_dq_0.qs_fifo_2.qs_n_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_0.qs_fifo_2.qs_n_ff_1);
            force `DXn_inst.datx8_dq_1.qs_fifo_2.qs_n_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_1.qs_fifo_2.qs_n_ff_1);
            force `DXn_inst.datx8_dq_2.qs_fifo_2.qs_n_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_2.qs_fifo_2.qs_n_ff_1);
            force `DXn_inst.datx8_dq_3.qs_fifo_2.qs_n_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_3.qs_fifo_2.qs_n_ff_1);
            force `DXn_inst.datx8_dq_4.qs_fifo_2.qs_n_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_4.qs_fifo_2.qs_n_ff_1);
            force `DXn_inst.datx8_dq_5.qs_fifo_2.qs_n_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_5.qs_fifo_2.qs_n_ff_1);
            force `DXn_inst.datx8_dq_6.qs_fifo_2.qs_n_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_6.qs_fifo_2.qs_n_ff_1);
            force `DXn_inst.datx8_dq_7.qs_fifo_2.qs_n_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_7.qs_fifo_2.qs_n_ff_1);
            force `DXn_inst.datx8_dq_8.qs_fifo_2.qs_n_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_8.qs_fifo_2.qs_n_ff_1);
            force `DXn_inst.datx8_dq_0.qs_fifo_3.qs_n_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_0.qs_fifo_3.qs_n_ff_1);
            force `DXn_inst.datx8_dq_1.qs_fifo_3.qs_n_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_1.qs_fifo_3.qs_n_ff_1);
            force `DXn_inst.datx8_dq_2.qs_fifo_3.qs_n_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_2.qs_fifo_3.qs_n_ff_1);
            force `DXn_inst.datx8_dq_3.qs_fifo_3.qs_n_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_3.qs_fifo_3.qs_n_ff_1);
            force `DXn_inst.datx8_dq_4.qs_fifo_3.qs_n_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_4.qs_fifo_3.qs_n_ff_1);
            force `DXn_inst.datx8_dq_5.qs_fifo_3.qs_n_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_5.qs_fifo_3.qs_n_ff_1);
            force `DXn_inst.datx8_dq_6.qs_fifo_3.qs_n_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_6.qs_fifo_3.qs_n_ff_1);
            force `DXn_inst.datx8_dq_7.qs_fifo_3.qs_n_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_7.qs_fifo_3.qs_n_ff_1);
            force `DXn_inst.datx8_dq_8.qs_fifo_3.qs_n_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_8.qs_fifo_3.qs_n_ff_1);

            force `DXn_inst.datx8_dq_0.qs_fifo_0.qs_n_ff_2.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_0.qs_fifo_0.qs_n_ff_2);
            force `DXn_inst.datx8_dq_1.qs_fifo_0.qs_n_ff_2.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_1.qs_fifo_0.qs_n_ff_2);
            force `DXn_inst.datx8_dq_2.qs_fifo_0.qs_n_ff_2.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_2.qs_fifo_0.qs_n_ff_2);
            force `DXn_inst.datx8_dq_3.qs_fifo_0.qs_n_ff_2.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_3.qs_fifo_0.qs_n_ff_2);
            force `DXn_inst.datx8_dq_4.qs_fifo_0.qs_n_ff_2.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_4.qs_fifo_0.qs_n_ff_2);
            force `DXn_inst.datx8_dq_5.qs_fifo_0.qs_n_ff_2.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_5.qs_fifo_0.qs_n_ff_2);
            force `DXn_inst.datx8_dq_6.qs_fifo_0.qs_n_ff_2.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_6.qs_fifo_0.qs_n_ff_2);
            force `DXn_inst.datx8_dq_7.qs_fifo_0.qs_n_ff_2.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_7.qs_fifo_0.qs_n_ff_2);
            force `DXn_inst.datx8_dq_8.qs_fifo_0.qs_n_ff_2.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_8.qs_fifo_0.qs_n_ff_2);
            force `DXn_inst.datx8_dq_0.qs_fifo_1.qs_n_ff_2.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_0.qs_fifo_1.qs_n_ff_2);
            force `DXn_inst.datx8_dq_1.qs_fifo_1.qs_n_ff_2.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_1.qs_fifo_1.qs_n_ff_2);
            force `DXn_inst.datx8_dq_2.qs_fifo_1.qs_n_ff_2.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_2.qs_fifo_1.qs_n_ff_2);
            force `DXn_inst.datx8_dq_3.qs_fifo_1.qs_n_ff_2.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_3.qs_fifo_1.qs_n_ff_2);
            force `DXn_inst.datx8_dq_4.qs_fifo_1.qs_n_ff_2.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_4.qs_fifo_1.qs_n_ff_2);
            force `DXn_inst.datx8_dq_5.qs_fifo_1.qs_n_ff_2.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_5.qs_fifo_1.qs_n_ff_2);
            force `DXn_inst.datx8_dq_6.qs_fifo_1.qs_n_ff_2.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_6.qs_fifo_1.qs_n_ff_2);
            force `DXn_inst.datx8_dq_7.qs_fifo_1.qs_n_ff_2.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_7.qs_fifo_1.qs_n_ff_2);
            force `DXn_inst.datx8_dq_8.qs_fifo_1.qs_n_ff_2.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_8.qs_fifo_1.qs_n_ff_2);
            force `DXn_inst.datx8_dq_0.qs_fifo_2.qs_n_ff_2.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_0.qs_fifo_2.qs_n_ff_2);
            force `DXn_inst.datx8_dq_1.qs_fifo_2.qs_n_ff_2.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_1.qs_fifo_2.qs_n_ff_2);
            force `DXn_inst.datx8_dq_2.qs_fifo_2.qs_n_ff_2.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_2.qs_fifo_2.qs_n_ff_2);
            force `DXn_inst.datx8_dq_3.qs_fifo_2.qs_n_ff_2.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_3.qs_fifo_2.qs_n_ff_2);
            force `DXn_inst.datx8_dq_4.qs_fifo_2.qs_n_ff_2.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_4.qs_fifo_2.qs_n_ff_2);
            force `DXn_inst.datx8_dq_5.qs_fifo_2.qs_n_ff_2.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_5.qs_fifo_2.qs_n_ff_2);
            force `DXn_inst.datx8_dq_6.qs_fifo_2.qs_n_ff_2.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_6.qs_fifo_2.qs_n_ff_2);
            force `DXn_inst.datx8_dq_7.qs_fifo_2.qs_n_ff_2.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_7.qs_fifo_2.qs_n_ff_2);
            force `DXn_inst.datx8_dq_8.qs_fifo_2.qs_n_ff_2.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_8.qs_fifo_2.qs_n_ff_2);
            force `DXn_inst.datx8_dq_0.qs_fifo_3.qs_n_ff_2.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_0.qs_fifo_3.qs_n_ff_2);
            force `DXn_inst.datx8_dq_1.qs_fifo_3.qs_n_ff_2.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_1.qs_fifo_3.qs_n_ff_2);
            force `DXn_inst.datx8_dq_2.qs_fifo_3.qs_n_ff_2.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_2.qs_fifo_3.qs_n_ff_2);
            force `DXn_inst.datx8_dq_3.qs_fifo_3.qs_n_ff_2.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_3.qs_fifo_3.qs_n_ff_2);
            force `DXn_inst.datx8_dq_4.qs_fifo_3.qs_n_ff_2.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_4.qs_fifo_3.qs_n_ff_2);
            force `DXn_inst.datx8_dq_5.qs_fifo_3.qs_n_ff_2.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_5.qs_fifo_3.qs_n_ff_2);
            force `DXn_inst.datx8_dq_6.qs_fifo_3.qs_n_ff_2.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_6.qs_fifo_3.qs_n_ff_2);
            force `DXn_inst.datx8_dq_7.qs_fifo_3.qs_n_ff_2.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_7.qs_fifo_3.qs_n_ff_2);
            force `DXn_inst.datx8_dq_8.qs_fifo_3.qs_n_ff_2.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_8.qs_fifo_3.qs_n_ff_2);

            force `DXn_inst.datx8_dq_0.qs_fifo_0.qs_n_ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_0.qs_fifo_0.qs_n_ff_3);
            force `DXn_inst.datx8_dq_1.qs_fifo_0.qs_n_ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_1.qs_fifo_0.qs_n_ff_3);
            force `DXn_inst.datx8_dq_2.qs_fifo_0.qs_n_ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_2.qs_fifo_0.qs_n_ff_3);
            force `DXn_inst.datx8_dq_3.qs_fifo_0.qs_n_ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_3.qs_fifo_0.qs_n_ff_3);
            force `DXn_inst.datx8_dq_4.qs_fifo_0.qs_n_ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_4.qs_fifo_0.qs_n_ff_3);
            force `DXn_inst.datx8_dq_5.qs_fifo_0.qs_n_ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_5.qs_fifo_0.qs_n_ff_3);
            force `DXn_inst.datx8_dq_6.qs_fifo_0.qs_n_ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_6.qs_fifo_0.qs_n_ff_3);
            force `DXn_inst.datx8_dq_7.qs_fifo_0.qs_n_ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_7.qs_fifo_0.qs_n_ff_3);
            force `DXn_inst.datx8_dq_8.qs_fifo_0.qs_n_ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_8.qs_fifo_0.qs_n_ff_3);
            force `DXn_inst.datx8_dq_0.qs_fifo_1.qs_n_ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_0.qs_fifo_1.qs_n_ff_3);
            force `DXn_inst.datx8_dq_1.qs_fifo_1.qs_n_ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_1.qs_fifo_1.qs_n_ff_3);
            force `DXn_inst.datx8_dq_2.qs_fifo_1.qs_n_ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_2.qs_fifo_1.qs_n_ff_3);
            force `DXn_inst.datx8_dq_3.qs_fifo_1.qs_n_ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_3.qs_fifo_1.qs_n_ff_3);
            force `DXn_inst.datx8_dq_4.qs_fifo_1.qs_n_ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_4.qs_fifo_1.qs_n_ff_3);
            force `DXn_inst.datx8_dq_5.qs_fifo_1.qs_n_ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_5.qs_fifo_1.qs_n_ff_3);
            force `DXn_inst.datx8_dq_6.qs_fifo_1.qs_n_ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_6.qs_fifo_1.qs_n_ff_3);
            force `DXn_inst.datx8_dq_7.qs_fifo_1.qs_n_ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_7.qs_fifo_1.qs_n_ff_3);
            force `DXn_inst.datx8_dq_8.qs_fifo_1.qs_n_ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_8.qs_fifo_1.qs_n_ff_3);
            force `DXn_inst.datx8_dq_0.qs_fifo_2.qs_n_ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_0.qs_fifo_2.qs_n_ff_3);
            force `DXn_inst.datx8_dq_1.qs_fifo_2.qs_n_ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_1.qs_fifo_2.qs_n_ff_3);
            force `DXn_inst.datx8_dq_2.qs_fifo_2.qs_n_ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_2.qs_fifo_2.qs_n_ff_3);
            force `DXn_inst.datx8_dq_3.qs_fifo_2.qs_n_ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_3.qs_fifo_2.qs_n_ff_3);
            force `DXn_inst.datx8_dq_4.qs_fifo_2.qs_n_ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_4.qs_fifo_2.qs_n_ff_3);
            force `DXn_inst.datx8_dq_5.qs_fifo_2.qs_n_ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_5.qs_fifo_2.qs_n_ff_3);
            force `DXn_inst.datx8_dq_6.qs_fifo_2.qs_n_ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_6.qs_fifo_2.qs_n_ff_3);
            force `DXn_inst.datx8_dq_7.qs_fifo_2.qs_n_ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_7.qs_fifo_2.qs_n_ff_3);
            force `DXn_inst.datx8_dq_8.qs_fifo_2.qs_n_ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_8.qs_fifo_2.qs_n_ff_3);
            force `DXn_inst.datx8_dq_0.qs_fifo_3.qs_n_ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_0.qs_fifo_3.qs_n_ff_3);
            force `DXn_inst.datx8_dq_1.qs_fifo_3.qs_n_ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_1.qs_fifo_3.qs_n_ff_3);
            force `DXn_inst.datx8_dq_2.qs_fifo_3.qs_n_ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_2.qs_fifo_3.qs_n_ff_3);
            force `DXn_inst.datx8_dq_3.qs_fifo_3.qs_n_ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_3.qs_fifo_3.qs_n_ff_3);
            force `DXn_inst.datx8_dq_4.qs_fifo_3.qs_n_ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_4.qs_fifo_3.qs_n_ff_3);
            force `DXn_inst.datx8_dq_5.qs_fifo_3.qs_n_ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_5.qs_fifo_3.qs_n_ff_3);
            force `DXn_inst.datx8_dq_6.qs_fifo_3.qs_n_ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_6.qs_fifo_3.qs_n_ff_3);
            force `DXn_inst.datx8_dq_7.qs_fifo_3.qs_n_ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_7.qs_fifo_3.qs_n_ff_3);
            force `DXn_inst.datx8_dq_8.qs_fifo_3.qs_n_ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_8.qs_fifo_3.qs_n_ff_3);

`ifdef DWC_DDRPHY_X4X2  

	    force `DXn_inst.datx8_dq_9.qs_fifo_3.qs_n_ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_9.qs_fifo_3.qs_n_ff_0);
	    force `DXn_inst.datx8_dq_9.qs_fifo_3.qs_n_ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_9.qs_fifo_3.qs_n_ff_1);
	    force `DXn_inst.datx8_dq_9.qs_fifo_3.qs_n_ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_9.qs_fifo_3.qs_n_ff_2);
	    force `DXn_inst.datx8_dq_9.qs_fifo_3.qs_n_ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_9.qs_fifo_3.qs_n_ff_3);
	    force `DXn_inst.datx8_dq_9.qs_fifo_2.qs_n_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_9.qs_fifo_2.qs_n_ff_0);
	    force `DXn_inst.datx8_dq_9.qs_fifo_2.qs_n_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_9.qs_fifo_2.qs_n_ff_1);
	    force `DXn_inst.datx8_dq_9.qs_fifo_2.qs_n_ff_2.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_9.qs_fifo_2.qs_n_ff_2);
	    force `DXn_inst.datx8_dq_9.qs_fifo_2.qs_n_ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_9.qs_fifo_2.qs_n_ff_3);
	    force `DXn_inst.datx8_dq_9.qs_fifo_1.qs_n_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_9.qs_fifo_1.qs_n_ff_0);
	    force `DXn_inst.datx8_dq_9.qs_fifo_1.qs_n_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_9.qs_fifo_1.qs_n_ff_1);
	    force `DXn_inst.datx8_dq_9.qs_fifo_1.qs_n_ff_2.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_9.qs_fifo_1.qs_n_ff_2);
	    force `DXn_inst.datx8_dq_9.qs_fifo_1.qs_n_ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_9.qs_fifo_1.qs_n_ff_3);
	    force `DXn_inst.datx8_dq_9.qs_fifo_0.qs_n_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_9.qs_fifo_0.qs_n_ff_0);
	    force `DXn_inst.datx8_dq_9.qs_fifo_0.qs_n_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_9.qs_fifo_0.qs_n_ff_1);
	    force `DXn_inst.datx8_dq_9.qs_fifo_0.qs_n_ff_2.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_9.qs_fifo_0.qs_n_ff_2);
	    force `DXn_inst.datx8_dq_9.qs_fifo_0.qs_n_ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_9.qs_fifo_0.qs_n_ff_3);

`endif

            force `DXn_inst.datx8_dq_0.qs_q_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_0.qs_q_ff);
            force `DXn_inst.datx8_dq_1.qs_q_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_1.qs_q_ff);
            force `DXn_inst.datx8_dq_2.qs_q_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_2.qs_q_ff);
            force `DXn_inst.datx8_dq_3.qs_q_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_3.qs_q_ff);
            force `DXn_inst.datx8_dq_4.qs_q_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_4.qs_q_ff);
            force `DXn_inst.datx8_dq_5.qs_q_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_5.qs_q_ff);
            force `DXn_inst.datx8_dq_6.qs_q_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_6.qs_q_ff);
            force `DXn_inst.datx8_dq_7.qs_q_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_7.qs_q_ff);
            force `DXn_inst.datx8_dq_8.qs_q_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_8.qs_q_ff);
            force `DXn_inst.`DX_DQS0.qs_q_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS0.qs_q_ff);

`ifdef DWC_DDRPHY_X4X2  

	    force `DXn_inst.datx8_dq_9.qs_q_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_9.qs_q_ff);
            force `DXn_inst.`DX_DQS1.qs_q_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS1.qs_q_ff);
            force `DXn_inst.datx8_dq_9.qs_n_q_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_9.qs_n_q_ff_1);
            force `DXn_inst.datx8_dq_9.qs_n_q_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_9.qs_n_q_ff_0);

`endif

            force `DXn_inst.datx8_dq_0.qs_n_q_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_0.qs_n_q_ff_1);
            force `DXn_inst.datx8_dq_1.qs_n_q_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_1.qs_n_q_ff_1);
            force `DXn_inst.datx8_dq_2.qs_n_q_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_2.qs_n_q_ff_1);
            force `DXn_inst.datx8_dq_3.qs_n_q_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_3.qs_n_q_ff_1);
            force `DXn_inst.datx8_dq_4.qs_n_q_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_4.qs_n_q_ff_1);
            force `DXn_inst.datx8_dq_5.qs_n_q_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_5.qs_n_q_ff_1);
            force `DXn_inst.datx8_dq_6.qs_n_q_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_6.qs_n_q_ff_1);
            force `DXn_inst.datx8_dq_7.qs_n_q_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_7.qs_n_q_ff_1);
            force `DXn_inst.datx8_dq_8.qs_n_q_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_8.qs_n_q_ff_1);

            force `DXn_inst.datx8_dq_0.qs_n_q_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_0.qs_n_q_ff_0);
            force `DXn_inst.datx8_dq_1.qs_n_q_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_1.qs_n_q_ff_0);
            force `DXn_inst.datx8_dq_2.qs_n_q_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_2.qs_n_q_ff_0);
            force `DXn_inst.datx8_dq_3.qs_n_q_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_3.qs_n_q_ff_0);
            force `DXn_inst.datx8_dq_4.qs_n_q_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_4.qs_n_q_ff_0);
            force `DXn_inst.datx8_dq_5.qs_n_q_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_5.qs_n_q_ff_0);
            force `DXn_inst.datx8_dq_6.qs_n_q_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_6.qs_n_q_ff_0);
            force `DXn_inst.datx8_dq_7.qs_n_q_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_7.qs_n_q_ff_0);
            force `DXn_inst.datx8_dq_8.qs_n_q_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_8.qs_n_q_ff_0);

	    force `DXn_inst.`DX_DQS0.qs_n_q_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS0.qs_n_q_ff_0);
	    force `DXn_inst.`DX_DQS0.qs_n_q_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS0.qs_n_q_ff_1);

    	    force `DXn_inst.`DX_DQS0.qs_fifo_0.qs_n_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS0.qs_fifo_0.qs_n_ff_0);
	    force `DXn_inst.`DX_DQS0.qs_fifo_0.qs_n_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS0.qs_fifo_0.qs_n_ff_1);
    	    force `DXn_inst.`DX_DQS0.qs_fifo_0.qs_n_ff_2.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS0.qs_fifo_0.qs_n_ff_2);
	    force `DXn_inst.`DX_DQS0.qs_fifo_0.qs_n_ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS0.qs_fifo_0.qs_n_ff_3);

    	    force `DXn_inst.`DX_DQS0.qs_fifo_1.qs_n_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS0.qs_fifo_1.qs_n_ff_0);
	    force `DXn_inst.`DX_DQS0.qs_fifo_1.qs_n_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS0.qs_fifo_1.qs_n_ff_1);
    	    force `DXn_inst.`DX_DQS0.qs_fifo_1.qs_n_ff_2.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS0.qs_fifo_1.qs_n_ff_2);
	    force `DXn_inst.`DX_DQS0.qs_fifo_1.qs_n_ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS0.qs_fifo_1.qs_n_ff_3);

    	    force `DXn_inst.`DX_DQS0.qs_fifo_2.qs_n_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS0.qs_fifo_2.qs_n_ff_0);
	    force `DXn_inst.`DX_DQS0.qs_fifo_2.qs_n_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS0.qs_fifo_2.qs_n_ff_1);
    	    force `DXn_inst.`DX_DQS0.qs_fifo_2.qs_n_ff_2.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS0.qs_fifo_2.qs_n_ff_2);
	    force `DXn_inst.`DX_DQS0.qs_fifo_2.qs_n_ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS0.qs_fifo_2.qs_n_ff_3);

    	    force `DXn_inst.`DX_DQS0.qs_fifo_3.qs_n_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS0.qs_fifo_3.qs_n_ff_0);
	    force `DXn_inst.`DX_DQS0.qs_fifo_3.qs_n_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS0.qs_fifo_3.qs_n_ff_1);
    	    force `DXn_inst.`DX_DQS0.qs_fifo_3.qs_n_ff_2.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS0.qs_fifo_3.qs_n_ff_2);
	    force `DXn_inst.`DX_DQS0.qs_fifo_3.qs_n_ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS0.qs_fifo_3.qs_n_ff_3);

            force `DXn_inst.`DX_DQS0.qs_n_ptr_lwr_reg.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS0.qs_n_ptr_lwr_reg);
            force `DXn_inst.`DX_DQS0.qs_n_ptr_reg_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS0.qs_n_ptr_reg_0);
            force `DXn_inst.`DX_DQS0.qs_n_ptr_reg_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS0.qs_n_ptr_reg_1);


            force `DXn_inst.`DX_DQS0.get_rdata_reg.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS0.get_rdata_reg);
            force `DXn_inst.`DX_DQS0.rdptr_reg_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS0.rdptr_reg_0);
            force `DXn_inst.`DX_DQS0.rdptr_reg_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS0.rdptr_reg_1);
            force `DXn_inst.`DX_DQS0.phyqvld_reg.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS0.phyqvld_reg);
            force `DXn_inst.`DX_DQS0.dqs_gate.qs_n_cnt_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS0.dqs_gate.qs_n_cnt_ff);


`ifdef DWC_DDRPHY_X4X2  
            force `DXn_inst.`DX_DQS1.qs_n_ptr_lwr_reg.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS1.qs_n_ptr_lwr_reg);
            force `DXn_inst.`DX_DQS1.qs_n_ptr_reg_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS1.qs_n_ptr_reg_0);
            force `DXn_inst.`DX_DQS1.qs_n_ptr_reg_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS1.qs_n_ptr_reg_1);

 	    force `DXn_inst.`DX_DQS1.qs_n_q_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS1.qs_n_q_ff_0);
	    force `DXn_inst.`DX_DQS1.qs_n_q_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS1.qs_n_q_ff_1);

    	    force `DXn_inst.`DX_DQS1.qs_fifo_0.qs_n_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS1.qs_fifo_0.qs_n_ff_0);
	    force `DXn_inst.`DX_DQS1.qs_fifo_0.qs_n_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS1.qs_fifo_0.qs_n_ff_1);
    	    force `DXn_inst.`DX_DQS1.qs_fifo_0.qs_n_ff_2.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS1.qs_fifo_0.qs_n_ff_2);
	    force `DXn_inst.`DX_DQS1.qs_fifo_0.qs_n_ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS1.qs_fifo_0.qs_n_ff_3);

    	    force `DXn_inst.`DX_DQS1.qs_fifo_1.qs_n_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS1.qs_fifo_1.qs_n_ff_0);
	    force `DXn_inst.`DX_DQS1.qs_fifo_1.qs_n_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS1.qs_fifo_1.qs_n_ff_1);
    	    force `DXn_inst.`DX_DQS1.qs_fifo_1.qs_n_ff_2.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS1.qs_fifo_1.qs_n_ff_2);
	    force `DXn_inst.`DX_DQS1.qs_fifo_1.qs_n_ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS1.qs_fifo_1.qs_n_ff_3);

    	    force `DXn_inst.`DX_DQS1.qs_fifo_2.qs_n_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS1.qs_fifo_2.qs_n_ff_0);
	    force `DXn_inst.`DX_DQS1.qs_fifo_2.qs_n_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS1.qs_fifo_2.qs_n_ff_1);
    	    force `DXn_inst.`DX_DQS1.qs_fifo_2.qs_n_ff_2.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS1.qs_fifo_2.qs_n_ff_2);
	    force `DXn_inst.`DX_DQS1.qs_fifo_2.qs_n_ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS1.qs_fifo_2.qs_n_ff_3);

    	    force `DXn_inst.`DX_DQS1.qs_fifo_3.qs_n_ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS1.qs_fifo_3.qs_n_ff_0);
	    force `DXn_inst.`DX_DQS1.qs_fifo_3.qs_n_ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS1.qs_fifo_3.qs_n_ff_1);
    	    force `DXn_inst.`DX_DQS1.qs_fifo_3.qs_n_ff_2.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS1.qs_fifo_3.qs_n_ff_2);
	    force `DXn_inst.`DX_DQS1.qs_fifo_3.qs_n_ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS1.qs_fifo_3.qs_n_ff_3);
 
 	    force `DXn_inst.`DX_DQS1.get_rdata_reg.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS1.get_rdata_reg);
            force `DXn_inst.`DX_DQS1.rdptr_reg_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS1.rdptr_reg_0);
            force `DXn_inst.`DX_DQS1.rdptr_reg_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS1.rdptr_reg_1);
            force `DXn_inst.`DX_DQS1.phyqvld_reg.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS1.phyqvld_reg);
            force `DXn_inst.`DX_DQS1.dqs_gate.qs_n_cnt_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS1.dqs_gate.qs_n_cnt_ff);


`endif
 	    force `DXn_inst.`DX_CTRL.rd_rst_n_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_CTRL.rd_rst_n_ff);
 	    force `DXn_inst.`DX_CTRL.rdfifo_rst_n_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_CTRL.rdfifo_rst_n_ff);



            force `DXn_inst.datx8_dq_0.d_drmux.ddro.ddr_d_1_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_0.d_drmux.ddro.ddr_d_1_ff);
            force `DXn_inst.datx8_dq_1.d_drmux.ddro.ddr_d_1_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_1.d_drmux.ddro.ddr_d_1_ff);
            force `DXn_inst.datx8_dq_2.d_drmux.ddro.ddr_d_1_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_2.d_drmux.ddro.ddr_d_1_ff);
            force `DXn_inst.datx8_dq_3.d_drmux.ddro.ddr_d_1_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_3.d_drmux.ddro.ddr_d_1_ff);
            force `DXn_inst.datx8_dq_4.d_drmux.ddro.ddr_d_1_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_4.d_drmux.ddro.ddr_d_1_ff);
            force `DXn_inst.datx8_dq_5.d_drmux.ddro.ddr_d_1_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_5.d_drmux.ddro.ddr_d_1_ff);
            force `DXn_inst.datx8_dq_6.d_drmux.ddro.ddr_d_1_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_6.d_drmux.ddro.ddr_d_1_ff);
            force `DXn_inst.datx8_dq_7.d_drmux.ddro.ddr_d_1_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_7.d_drmux.ddro.ddr_d_1_ff);
            force `DXn_inst.datx8_dq_8.d_drmux.ddro.ddr_d_1_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_8.d_drmux.ddro.ddr_d_1_ff);

            force `DXn_inst.`DX_DQS_DDRCNT.ddr_d_ld_0_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS_DDRCNT.ddr_d_ld_0_ff);
            force `DXn_inst.`DX_DQ_DDRCNT.ddr_d_ld_0_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQ_DDRCNT.ddr_d_ld_0_ff);
            force `DXn_inst.`DX_CTRL_DDRCNT.ddr_d_ld_0_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_CTRL_DDRCNT.ddr_d_ld_0_ff);

            force `DXn_inst.`DX_DQS_DDRCNT.ddr_d_ld_1_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS_DDRCNT.ddr_d_ld_1_ff);
            force `DXn_inst.`DX_DQ_DDRCNT.ddr_d_ld_1_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQ_DDRCNT.ddr_d_ld_1_ff);
            force `DXn_inst.`DX_CTRL_DDRCNT.ddr_d_ld_1_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_CTRL_DDRCNT.ddr_d_ld_1_ff);

            force `DXn_inst.`DX_CLKGEN0.wl_dly_pipe.dly_p2_regx9.ff_8.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_CLKGEN0.wl_dly_pipe.dly_p2_regx9.ff_8);
            force `DXn_inst.`DX_CLKGEN0.wl_dly_pipe.dly_p2_regx9.ff_7.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_CLKGEN0.wl_dly_pipe.dly_p2_regx9.ff_7);
            force `DXn_inst.`DX_CLKGEN0.wl_dly_pipe.dly_p2_regx9.ff_6.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_CLKGEN0.wl_dly_pipe.dly_p2_regx9.ff_6);
            force `DXn_inst.`DX_CLKGEN0.wl_dly_pipe.dly_p2_regx9.ff_5.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_CLKGEN0.wl_dly_pipe.dly_p2_regx9.ff_5);
            force `DXn_inst.`DX_CLKGEN0.wl_dly_pipe.dly_p2_regx9.ff_4.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_CLKGEN0.wl_dly_pipe.dly_p2_regx9.ff_4);
            force `DXn_inst.`DX_CLKGEN0.wl_dly_pipe.dly_p2_regx9.ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_CLKGEN0.wl_dly_pipe.dly_p2_regx9.ff_3);
            force `DXn_inst.`DX_CLKGEN0.wl_dly_pipe.dly_p2_regx9.ff_2.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_CLKGEN0.wl_dly_pipe.dly_p2_regx9.ff_2);
            force `DXn_inst.`DX_CLKGEN0.wl_dly_pipe.dly_p2_regx9.ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_CLKGEN0.wl_dly_pipe.dly_p2_regx9.ff_1);
            force `DXn_inst.`DX_CLKGEN0.wl_dly_pipe.dly_p2_regx9.ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_CLKGEN0.wl_dly_pipe.dly_p2_regx9.ff_0);

            force `DXn_inst.`DX_CLKGEN0.wdq_dly_pipe.dly_p2_regx9.ff_8.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_CLKGEN0.wdq_dly_pipe.dly_p2_regx9.ff_8);
            force `DXn_inst.`DX_CLKGEN0.wdq_dly_pipe.dly_p2_regx9.ff_7.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_CLKGEN0.wdq_dly_pipe.dly_p2_regx9.ff_7);
            force `DXn_inst.`DX_CLKGEN0.wdq_dly_pipe.dly_p2_regx9.ff_6.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_CLKGEN0.wdq_dly_pipe.dly_p2_regx9.ff_6);
            force `DXn_inst.`DX_CLKGEN0.wdq_dly_pipe.dly_p2_regx9.ff_5.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_CLKGEN0.wdq_dly_pipe.dly_p2_regx9.ff_5);
            force `DXn_inst.`DX_CLKGEN0.wdq_dly_pipe.dly_p2_regx9.ff_4.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_CLKGEN0.wdq_dly_pipe.dly_p2_regx9.ff_4);
            force `DXn_inst.`DX_CLKGEN0.wdq_dly_pipe.dly_p2_regx9.ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_CLKGEN0.wdq_dly_pipe.dly_p2_regx9.ff_3);
            force `DXn_inst.`DX_CLKGEN0.wdq_dly_pipe.dly_p2_regx9.ff_2.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_CLKGEN0.wdq_dly_pipe.dly_p2_regx9.ff_2);
            force `DXn_inst.`DX_CLKGEN0.wdq_dly_pipe.dly_p2_regx9.ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_CLKGEN0.wdq_dly_pipe.dly_p2_regx9.ff_1);
            force `DXn_inst.`DX_CLKGEN0.wdq_dly_pipe.dly_p2_regx9.ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_CLKGEN0.wdq_dly_pipe.dly_p2_regx9.ff_0);

            force `DXn_inst.`DX_CLKGEN0.wdq_dly_pipe.dly_ld_drmux.ddro.ddr_d_ld_0_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_CLKGEN0.wdq_dly_pipe.dly_ld_drmux.ddro.ddr_d_ld_0_ff);
            force `DXn_inst.`DX_CLKGEN0.wdq_dly_pipe.dly_ld_drmux.ddro.ddr_d_ld_1_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_CLKGEN0.wdq_dly_pipe.dly_ld_drmux.ddro.ddr_d_ld_1_ff);
            force `DXn_inst.`DX_CLKGEN0.wdq_dly_pipe.dly_ld_drmux.ddro.ddr_d_0_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_CLKGEN0.wdq_dly_pipe.dly_ld_drmux.ddro.ddr_d_0_ff);
            force `DXn_inst.`DX_CLKGEN0.wdq_dly_pipe.dly_ld_drmux.ddro.ddr_d_1_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_CLKGEN0.wdq_dly_pipe.dly_ld_drmux.ddro.ddr_d_1_ff);
            force `DXn_inst.`DX_DQS0.ds_gate_lcdl_so_reg.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS0.ds_gate_lcdl_so_reg);
            force `DXn_inst.`DX_DQS0.qs_q_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS0.qs_q_ff);

`ifdef DWC_DDRPHY_X4X2  
            force `DXn_inst.`DX_CLKGEN1.wl_dly_pipe.dly_p2_regx9.ff_8.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_CLKGEN1.wl_dly_pipe.dly_p2_regx9.ff_8);
            force `DXn_inst.`DX_CLKGEN1.wl_dly_pipe.dly_p2_regx9.ff_7.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_CLKGEN1.wl_dly_pipe.dly_p2_regx9.ff_7);
            force `DXn_inst.`DX_CLKGEN1.wl_dly_pipe.dly_p2_regx9.ff_6.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_CLKGEN1.wl_dly_pipe.dly_p2_regx9.ff_6);
            force `DXn_inst.`DX_CLKGEN1.wl_dly_pipe.dly_p2_regx9.ff_5.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_CLKGEN1.wl_dly_pipe.dly_p2_regx9.ff_5);
            force `DXn_inst.`DX_CLKGEN1.wl_dly_pipe.dly_p2_regx9.ff_4.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_CLKGEN1.wl_dly_pipe.dly_p2_regx9.ff_4);
            force `DXn_inst.`DX_CLKGEN1.wl_dly_pipe.dly_p2_regx9.ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_CLKGEN1.wl_dly_pipe.dly_p2_regx9.ff_3);
            force `DXn_inst.`DX_CLKGEN1.wl_dly_pipe.dly_p2_regx9.ff_2.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_CLKGEN1.wl_dly_pipe.dly_p2_regx9.ff_2);
            force `DXn_inst.`DX_CLKGEN1.wl_dly_pipe.dly_p2_regx9.ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_CLKGEN1.wl_dly_pipe.dly_p2_regx9.ff_1);
            force `DXn_inst.`DX_CLKGEN1.wl_dly_pipe.dly_p2_regx9.ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_CLKGEN1.wl_dly_pipe.dly_p2_regx9.ff_0);

            force `DXn_inst.`DX_CLKGEN1.wdq_dly_pipe.dly_p2_regx9.ff_8.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_CLKGEN1.wdq_dly_pipe.dly_p2_regx9.ff_8);
            force `DXn_inst.`DX_CLKGEN1.wdq_dly_pipe.dly_p2_regx9.ff_7.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_CLKGEN1.wdq_dly_pipe.dly_p2_regx9.ff_7);
            force `DXn_inst.`DX_CLKGEN1.wdq_dly_pipe.dly_p2_regx9.ff_6.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_CLKGEN1.wdq_dly_pipe.dly_p2_regx9.ff_6);
            force `DXn_inst.`DX_CLKGEN1.wdq_dly_pipe.dly_p2_regx9.ff_5.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_CLKGEN1.wdq_dly_pipe.dly_p2_regx9.ff_5);
            force `DXn_inst.`DX_CLKGEN1.wdq_dly_pipe.dly_p2_regx9.ff_4.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_CLKGEN1.wdq_dly_pipe.dly_p2_regx9.ff_4);
            force `DXn_inst.`DX_CLKGEN1.wdq_dly_pipe.dly_p2_regx9.ff_3.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_CLKGEN1.wdq_dly_pipe.dly_p2_regx9.ff_3);
            force `DXn_inst.`DX_CLKGEN1.wdq_dly_pipe.dly_p2_regx9.ff_2.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_CLKGEN1.wdq_dly_pipe.dly_p2_regx9.ff_2);
            force `DXn_inst.`DX_CLKGEN1.wdq_dly_pipe.dly_p2_regx9.ff_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_CLKGEN1.wdq_dly_pipe.dly_p2_regx9.ff_1);
            force `DXn_inst.`DX_CLKGEN1.wdq_dly_pipe.dly_p2_regx9.ff_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_CLKGEN1.wdq_dly_pipe.dly_p2_regx9.ff_0);

            force `DXn_inst.`DX_CLKGEN1.wdq_dly_pipe.dly_ld_drmux.ddro.ddr_d_ld_0_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_CLKGEN1.wdq_dly_pipe.dly_ld_drmux.ddro.ddr_d_ld_0_ff);
            force `DXn_inst.`DX_CLKGEN1.wdq_dly_pipe.dly_ld_drmux.ddro.ddr_d_ld_1_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_CLKGEN1.wdq_dly_pipe.dly_ld_drmux.ddro.ddr_d_ld_1_ff);
            force `DXn_inst.`DX_CLKGEN1.wdq_dly_pipe.dly_ld_drmux.ddro.ddr_d_0_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_CLKGEN1.wdq_dly_pipe.dly_ld_drmux.ddro.ddr_d_0_ff);
            force `DXn_inst.`DX_CLKGEN1.wdq_dly_pipe.dly_ld_drmux.ddro.ddr_d_1_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_CLKGEN1.wdq_dly_pipe.dly_ld_drmux.ddro.ddr_d_1_ff);
            force `DXn_inst.`DX_DQS1.ds_gate_lcdl_so_reg.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS1.ds_gate_lcdl_so_reg);
            force `DXn_inst.`DX_DQS1.qs_q_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS1.qs_q_ff);
`endif

            force `DXn_inst.datx8_dq_0.d_drmux.ddro.ddr_d_ld_0_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_0.d_drmux.ddro.ddr_d_ld_0_ff);
            force `DXn_inst.datx8_dq_1.d_drmux.ddro.ddr_d_ld_0_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_1.d_drmux.ddro.ddr_d_ld_0_ff);
            force `DXn_inst.datx8_dq_2.d_drmux.ddro.ddr_d_ld_0_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_2.d_drmux.ddro.ddr_d_ld_0_ff);
            force `DXn_inst.datx8_dq_3.d_drmux.ddro.ddr_d_ld_0_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_3.d_drmux.ddro.ddr_d_ld_0_ff);
            force `DXn_inst.datx8_dq_4.d_drmux.ddro.ddr_d_ld_0_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_4.d_drmux.ddro.ddr_d_ld_0_ff);
            force `DXn_inst.datx8_dq_5.d_drmux.ddro.ddr_d_ld_0_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_5.d_drmux.ddro.ddr_d_ld_0_ff);
            force `DXn_inst.datx8_dq_6.d_drmux.ddro.ddr_d_ld_0_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_6.d_drmux.ddro.ddr_d_ld_0_ff);
            force `DXn_inst.datx8_dq_7.d_drmux.ddro.ddr_d_ld_0_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_7.d_drmux.ddro.ddr_d_ld_0_ff);
            force `DXn_inst.datx8_dq_8.d_drmux.ddro.ddr_d_ld_0_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_8.d_drmux.ddro.ddr_d_ld_0_ff);

            force `DXn_inst.datx8_dq_0.d_drmux.ddro.ddr_d_ld_1_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_0.d_drmux.ddro.ddr_d_ld_1_ff);
            force `DXn_inst.datx8_dq_1.d_drmux.ddro.ddr_d_ld_1_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_1.d_drmux.ddro.ddr_d_ld_1_ff);
            force `DXn_inst.datx8_dq_2.d_drmux.ddro.ddr_d_ld_1_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_2.d_drmux.ddro.ddr_d_ld_1_ff);
            force `DXn_inst.datx8_dq_3.d_drmux.ddro.ddr_d_ld_1_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_3.d_drmux.ddro.ddr_d_ld_1_ff);
            force `DXn_inst.datx8_dq_4.d_drmux.ddro.ddr_d_ld_1_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_4.d_drmux.ddro.ddr_d_ld_1_ff);
            force `DXn_inst.datx8_dq_5.d_drmux.ddro.ddr_d_ld_1_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_5.d_drmux.ddro.ddr_d_ld_1_ff);
            force `DXn_inst.datx8_dq_6.d_drmux.ddro.ddr_d_ld_1_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_6.d_drmux.ddro.ddr_d_ld_1_ff);
            force `DXn_inst.datx8_dq_7.d_drmux.ddro.ddr_d_ld_1_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_7.d_drmux.ddro.ddr_d_ld_1_ff);
            force `DXn_inst.datx8_dq_8.d_drmux.ddro.ddr_d_ld_1_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_8.d_drmux.ddro.ddr_d_ld_1_ff);

            force `DXn_inst.datx8_dq_0.d_drmux.ddro.ddr_d_0_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_0.d_drmux.ddro.ddr_d_0_ff);
            force `DXn_inst.datx8_dq_1.d_drmux.ddro.ddr_d_0_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_1.d_drmux.ddro.ddr_d_0_ff);
            force `DXn_inst.datx8_dq_2.d_drmux.ddro.ddr_d_0_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_2.d_drmux.ddro.ddr_d_0_ff);
            force `DXn_inst.datx8_dq_3.d_drmux.ddro.ddr_d_0_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_3.d_drmux.ddro.ddr_d_0_ff);
            force `DXn_inst.datx8_dq_4.d_drmux.ddro.ddr_d_0_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_4.d_drmux.ddro.ddr_d_0_ff);
            force `DXn_inst.datx8_dq_5.d_drmux.ddro.ddr_d_0_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_5.d_drmux.ddro.ddr_d_0_ff);
            force `DXn_inst.datx8_dq_6.d_drmux.ddro.ddr_d_0_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_6.d_drmux.ddro.ddr_d_0_ff);
            force `DXn_inst.datx8_dq_7.d_drmux.ddro.ddr_d_0_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_7.d_drmux.ddro.ddr_d_0_ff);
            force `DXn_inst.datx8_dq_8.d_drmux.ddro.ddr_d_0_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_8.d_drmux.ddro.ddr_d_0_ff);

            force `DXn_inst.datx8_dq_0.qs_q_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_0.qs_q_ff);
            force `DXn_inst.datx8_dq_1.qs_q_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_1.qs_q_ff);
            force `DXn_inst.datx8_dq_2.qs_q_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_2.qs_q_ff);
            force `DXn_inst.datx8_dq_3.qs_q_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_3.qs_q_ff);
            force `DXn_inst.datx8_dq_4.qs_q_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_4.qs_q_ff);
            force `DXn_inst.datx8_dq_5.qs_q_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_5.qs_q_ff);
            force `DXn_inst.datx8_dq_6.qs_q_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_6.qs_q_ff);
            force `DXn_inst.datx8_dq_7.qs_q_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_7.qs_q_ff);
            force `DXn_inst.datx8_dq_8.qs_q_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_8.qs_q_ff);

`ifdef DWC_DDRPHY_X4X2  
            force `DXn_inst.datx8_dq_9.d_drmux.ddro.ddr_d_ld_0_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_9.d_drmux.ddro.ddr_d_ld_0_ff);
            force `DXn_inst.datx8_dq_9.d_drmux.ddro.ddr_d_ld_1_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_9.d_drmux.ddro.ddr_d_ld_1_ff);
            force `DXn_inst.datx8_dq_9.d_drmux.ddro.ddr_d_0_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_9.d_drmux.ddro.ddr_d_0_ff);
            force `DXn_inst.datx8_dq_9.qs_q_ff.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.datx8_dq_9.qs_q_ff);
`endif

            force `DXn_inst.`DX_DQS0.dqs_gate.qs_gate_status_reg_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS0.dqs_gate.qs_gate_status_reg_1);
            force `DXn_inst.`DX_DQS0.dqs_gate.qs_gate_status_reg_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS0.dqs_gate.qs_gate_status_reg_0);

`ifdef DWC_DDRPHY_X4X2  
            force `DXn_inst.`DX_DQS1.dqs_gate.qs_gate_status_reg_1.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS1.dqs_gate.qs_gate_status_reg_1);
            force `DXn_inst.`DX_DQS1.dqs_gate.qs_gate_status_reg_0.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.`DX_DQS1.dqs_gate.qs_gate_status_reg_0);

`endif

            // ATPG lock-up latches are don't care in mission mode
            force `AC.ctl_x_0_lu.NOTIFIER = 1'b0;
            $disable_warnings("timing",`AC.ctl_x_0_lu);
            force `AC.ctl_x_1_lu.NOTIFIER = 1'b0;
            $disable_warnings("timing",`AC.ctl_x_1_lu);
            force `AC.ctl_x_2_lu.NOTIFIER = 1'b0;
            $disable_warnings("timing",`AC.ctl_x_2_lu);
            force `AC.ctl_0_lu.NOTIFIER = 1'b0;
            $disable_warnings("timing",`AC.ctl_0_lu);
            force `AC.ctl_1_lu.NOTIFIER = 1'b0;
            $disable_warnings("timing",`AC.ctl_1_lu);
            force `AC.ddr_0_lu.NOTIFIER = 1'b0;
            $disable_warnings("timing",`AC.ddr_0_lu);
            force `AC.ddr_1_lu.NOTIFIER = 1'b0;
            $disable_warnings("timing",`AC.ddr_1_lu);
            force `AC.ddr_x_lu.NOTIFIER = 1'b0;
            $disable_warnings("timing",`AC.ddr_x_lu);
            force `AC.ctl_rd_lu.NOTIFIER = 1'b0;
            $disable_warnings("timing",`AC.ctl_rd_lu);
            force `AC.lb_lu.NOTIFIER = 1'b0;
            $disable_warnings("timing",`AC.lb_lu);
            force `AC.lb_x_lu.NOTIFIER = 1'b0;
            $disable_warnings("timing",`AC.lb_x_lu);

            force `DXn_inst.ctl_x_0_lu.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.ctl_x_0_lu);
            force `DXn_inst.ctl_x_1_lu.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.ctl_x_1_lu);
    `ifdef DWC_DDRPHY_X4X2
            force `DXn_inst.ctl_x_2_lu.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.ctl_x_2_lu);
    `endif
            force `DXn_inst.ctl_0_lu.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.ctl_0_lu);
            force `DXn_inst.ctl_1_lu.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.ctl_1_lu);
    `ifdef DWC_DDRPHY_X4X2
            force `DXn_inst.ctl_2_lu.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.ctl_2_lu);
    `endif
            force `DXn_inst.ddr_0_lu.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.ddr_0_lu);
            force `DXn_inst.ddr_1_lu.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.ddr_1_lu);
    `ifdef DWC_DDRPHY_X4X2
            force `DXn_inst.ddr_2_lu.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.ddr_2_lu);
    `endif
            force `DXn_inst.ddr_x_lu.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.ddr_x_lu);
            force `DXn_inst.ctl_rd_lu.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.ctl_rd_lu);
            force `DXn_inst.qs_x_lu.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.qs_x_lu);
            force `DXn_inst.qs_n_x_lu.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.qs_n_x_lu);
            force `DXn_inst.qs_n_0_lu.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.qs_n_0_lu);
            force `DXn_inst.qs_n_1_lu.NOTIFIER = 1'b0;
            $disable_warnings("timing",`DXn_inst.qs_n_1_lu);
          end // always@ (force_notifiers)
      end // block: gen_dx8_force_declaration
  endgenerate

  
  // re-enable timing checks
  // -----------------------
  // after calibration, re-enable the timing checks of those flops that were problematic only
  // during calibration
  generate
  for (dwc_byte=0; dwc_byte<`DWC_NO_OF_BYTES; dwc_byte=dwc_byte+1) 
    begin :gen_dx8_release_declaration
      always@(release_calib_notifiers)
        begin
          //
        end
    end
  endgenerate

  // after training, re-enable the timing checks of those flops that were problematic only
  // during training 
  always@(release_train_notifiers)
    begin
      release `AC.ac_sctrl.ac_ddr_cnt.ddr_d_ld_0_ff.NOTIFIER;
      $enable_warnings("timing",`AC.ac_sctrl.ac_ddr_cnt.ddr_d_ld_0_ff);
      release `AC.ac_sctrl.ck_ddr_cnt.ddr_d_ld_0_ff.NOTIFIER;
      $enable_warnings("timing",`AC.ac_sctrl.ck_ddr_cnt.ddr_d_ld_0_ff);

      release `AC.ac_sctrl.ac_ddr_cnt.ddr_d_ld_1_ff.NOTIFIER;
      $enable_warnings("timing",`AC.ac_sctrl.ac_ddr_cnt.ddr_d_ld_1_ff);
      release `AC.ac_sctrl.ck_ddr_cnt.ddr_d_ld_1_ff.NOTIFIER;
      $enable_warnings("timing",`AC.ac_sctrl.ck_ddr_cnt.ddr_d_ld_1_ff);

      release `AC.ac_clkgen.ac_dly_pipe.dly_p2_regx9.ff_8.NOTIFIER;
      $enable_warnings("timing",`AC.ac_clkgen.ac_dly_pipe.dly_p2_regx9.ff_8);
      release `AC.ac_clkgen.ac_dly_pipe.dly_p2_regx9.ff_7.NOTIFIER;
      $enable_warnings("timing",`AC.ac_clkgen.ac_dly_pipe.dly_p2_regx9.ff_7);
      release `AC.ac_clkgen.ac_dly_pipe.dly_p2_regx9.ff_6.NOTIFIER;
      $enable_warnings("timing",`AC.ac_clkgen.ac_dly_pipe.dly_p2_regx9.ff_6);
      release `AC.ac_clkgen.ac_dly_pipe.dly_p2_regx9.ff_5.NOTIFIER;
      $enable_warnings("timing",`AC.ac_clkgen.ac_dly_pipe.dly_p2_regx9.ff_5);
      release `AC.ac_clkgen.ac_dly_pipe.dly_p2_regx9.ff_4.NOTIFIER;
      $enable_warnings("timing",`AC.ac_clkgen.ac_dly_pipe.dly_p2_regx9.ff_4);
      release `AC.ac_clkgen.ac_dly_pipe.dly_p2_regx9.ff_3.NOTIFIER;
      $enable_warnings("timing",`AC.ac_clkgen.ac_dly_pipe.dly_p2_regx9.ff_3);
      release `AC.ac_clkgen.ac_dly_pipe.dly_p2_regx9.ff_2.NOTIFIER;
      $enable_warnings("timing",`AC.ac_clkgen.ac_dly_pipe.dly_p2_regx9.ff_2);
      release `AC.ac_clkgen.ac_dly_pipe.dly_p2_regx9.ff_1.NOTIFIER;
      $enable_warnings("timing",`AC.ac_clkgen.ac_dly_pipe.dly_p2_regx9.ff_1);
      release `AC.ac_clkgen.ac_dly_pipe.dly_p2_regx9.ff_0.NOTIFIER;
      $enable_warnings("timing",`AC.ac_clkgen.ac_dly_pipe.dly_p2_regx9.ff_0);

      release `AC.ac_ctrl.ddl_test.osc_lu.NOTIFIER;
      $enable_warnings("timing",`AC.ac_ctrl.ddl_test.osc_lu);

      release `AC.ac_0.phy_reg.NOTIFIER;
      $enable_warnings("timing",`AC.ac_0.phy_reg);
      release `AC.ac_1.phy_reg.NOTIFIER;
      $enable_warnings("timing",`AC.ac_1.phy_reg);
      release `AC.ac_2.phy_reg.NOTIFIER;
      $enable_warnings("timing",`AC.ac_2.phy_reg);
      release `AC.ac_3.phy_reg.NOTIFIER;
      $enable_warnings("timing",`AC.ac_3.phy_reg);
      release `AC.ac_4.phy_reg.NOTIFIER;
      $enable_warnings("timing",`AC.ac_4.phy_reg);
      release `AC.ac_5.phy_reg.NOTIFIER;
      $enable_warnings("timing",`AC.ac_5.phy_reg);
      release `AC.ac_6.phy_reg.NOTIFIER;
      $enable_warnings("timing",`AC.ac_6.phy_reg);
      release `AC.ac_7.phy_reg.NOTIFIER;
      $enable_warnings("timing",`AC.ac_7.phy_reg);
      release `AC.ac_8.phy_reg.NOTIFIER;
      $enable_warnings("timing",`AC.ac_8.phy_reg);
      release `AC.ac_9.phy_reg.NOTIFIER;
      $enable_warnings("timing",`AC.ac_9.phy_reg);
      release `AC.ac_10.phy_reg.NOTIFIER;
      $enable_warnings("timing",`AC.ac_10.phy_reg);
      release `AC.ac_11.phy_reg.NOTIFIER;
      $enable_warnings("timing",`AC.ac_11.phy_reg);
      release `AC.ac_12.phy_reg.NOTIFIER;
      $enable_warnings("timing",`AC.ac_12.phy_reg);
      release `AC.ac_13.phy_reg.NOTIFIER;
      $enable_warnings("timing",`AC.ac_13.phy_reg);
      release `AC.ac_14.phy_reg.NOTIFIER;
      $enable_warnings("timing",`AC.ac_14.phy_reg);
      release `AC.ac_15.phy_reg.NOTIFIER;
      $enable_warnings("timing",`AC.ac_15.phy_reg);
      release `AC.ac_16.phy_reg.NOTIFIER;
      $enable_warnings("timing",`AC.ac_16.phy_reg);
      release `AC.ac_17.phy_reg.NOTIFIER;
      $enable_warnings("timing",`AC.ac_17.phy_reg);
      release `AC.ac_18.phy_reg.NOTIFIER;
      $enable_warnings("timing",`AC.ac_18.phy_reg);
      release `AC.ac_19.phy_reg.NOTIFIER;
      $enable_warnings("timing",`AC.ac_19.phy_reg);
      release `AC.ac_20.phy_reg.NOTIFIER;
      $enable_warnings("timing",`AC.ac_20.phy_reg);
      release `AC.ac_21.phy_reg.NOTIFIER;
      $enable_warnings("timing",`AC.ac_21.phy_reg);
      release `AC.ac_22.phy_reg.NOTIFIER;
      $enable_warnings("timing",`AC.ac_22.phy_reg);
      release `AC.ac_23.phy_reg.NOTIFIER;
      $enable_warnings("timing",`AC.ac_23.phy_reg);
      release `AC.ac_24.phy_reg.NOTIFIER;
      $enable_warnings("timing",`AC.ac_24.phy_reg);
      release `AC.ac_25.phy_reg.NOTIFIER;
      $enable_warnings("timing",`AC.ac_25.phy_reg);
      release `AC.ac_26.phy_reg.NOTIFIER;
      $enable_warnings("timing",`AC.ac_26.phy_reg);
      release `AC.ac_27.phy_reg.NOTIFIER;
      $enable_warnings("timing",`AC.ac_27.phy_reg);
      release `AC.ac_28.phy_reg.NOTIFIER;
      $enable_warnings("timing",`AC.ac_28.phy_reg);
      release `AC.ac_29.phy_reg.NOTIFIER;
      $enable_warnings("timing",`AC.ac_29.phy_reg);
      release `AC.ac_30.phy_reg.NOTIFIER;
      $enable_warnings("timing",`AC.ac_30.phy_reg);
      release `AC.ac_31.phy_reg.NOTIFIER;
      $enable_warnings("timing",`AC.ac_31.phy_reg);
      release `AC.ac_32.phy_reg.NOTIFIER;
      $enable_warnings("timing",`AC.ac_32.phy_reg);
      release `AC.ac_33.phy_reg.NOTIFIER;
      $enable_warnings("timing",`AC.ac_33.phy_reg);
      release `AC.ac_34.phy_reg.NOTIFIER;
      $enable_warnings("timing",`AC.ac_34.phy_reg);
      release `AC.ac_35.phy_reg.NOTIFIER;
      $enable_warnings("timing",`AC.ac_35.phy_reg);
    end

  generate
  for (dwc_byte=0; dwc_byte<`DWC_NO_OF_BYTES; dwc_byte=dwc_byte+1) 
    begin :gen_dwc_byte_train_declaration
      always@(release_train_notifiers)
        begin

            // CDC in the read data fifo from qs_clk to phy_clk
            release `DXn_inst.datx8_dq_0.qs_fifo_0.phy_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_0.qs_fifo_0.phy_ff);
            release `DXn_inst.datx8_dq_1.qs_fifo_0.phy_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_1.qs_fifo_0.phy_ff);
            release `DXn_inst.datx8_dq_2.qs_fifo_0.phy_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_2.qs_fifo_0.phy_ff);
            release `DXn_inst.datx8_dq_3.qs_fifo_0.phy_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_3.qs_fifo_0.phy_ff);
            release `DXn_inst.datx8_dq_4.qs_fifo_0.phy_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_4.qs_fifo_0.phy_ff);
            release `DXn_inst.datx8_dq_5.qs_fifo_0.phy_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_5.qs_fifo_0.phy_ff);
            release `DXn_inst.datx8_dq_6.qs_fifo_0.phy_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_6.qs_fifo_0.phy_ff);
            release `DXn_inst.datx8_dq_7.qs_fifo_0.phy_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_7.qs_fifo_0.phy_ff);
            release `DXn_inst.datx8_dq_8.qs_fifo_0.phy_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_8.qs_fifo_0.phy_ff);
            release `DXn_inst.datx8_dq_0.qs_fifo_1.phy_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_0.qs_fifo_1.phy_ff);
            release `DXn_inst.datx8_dq_1.qs_fifo_1.phy_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_1.qs_fifo_1.phy_ff);
            release `DXn_inst.datx8_dq_2.qs_fifo_1.phy_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_2.qs_fifo_1.phy_ff);
            release `DXn_inst.datx8_dq_3.qs_fifo_1.phy_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_3.qs_fifo_1.phy_ff);
            release `DXn_inst.datx8_dq_4.qs_fifo_1.phy_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_4.qs_fifo_1.phy_ff);
            release `DXn_inst.datx8_dq_5.qs_fifo_1.phy_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_5.qs_fifo_1.phy_ff);
            release `DXn_inst.datx8_dq_6.qs_fifo_1.phy_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_6.qs_fifo_1.phy_ff);
            release `DXn_inst.datx8_dq_7.qs_fifo_1.phy_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_7.qs_fifo_1.phy_ff);
            release `DXn_inst.datx8_dq_8.qs_fifo_1.phy_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_8.qs_fifo_1.phy_ff);
            release `DXn_inst.datx8_dq_0.qs_fifo_2.phy_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_0.qs_fifo_2.phy_ff);
            release `DXn_inst.datx8_dq_1.qs_fifo_2.phy_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_1.qs_fifo_2.phy_ff);
            release `DXn_inst.datx8_dq_2.qs_fifo_2.phy_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_2.qs_fifo_2.phy_ff);
            release `DXn_inst.datx8_dq_3.qs_fifo_2.phy_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_3.qs_fifo_2.phy_ff);
            release `DXn_inst.datx8_dq_4.qs_fifo_2.phy_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_4.qs_fifo_2.phy_ff);
            release `DXn_inst.datx8_dq_5.qs_fifo_2.phy_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_5.qs_fifo_2.phy_ff);
            release `DXn_inst.datx8_dq_6.qs_fifo_2.phy_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_6.qs_fifo_2.phy_ff);
            release `DXn_inst.datx8_dq_7.qs_fifo_2.phy_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_7.qs_fifo_2.phy_ff);
            release `DXn_inst.datx8_dq_8.qs_fifo_2.phy_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_8.qs_fifo_2.phy_ff);
            release `DXn_inst.datx8_dq_0.qs_fifo_3.phy_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_0.qs_fifo_3.phy_ff);
            release `DXn_inst.datx8_dq_1.qs_fifo_3.phy_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_1.qs_fifo_3.phy_ff);
            release `DXn_inst.datx8_dq_2.qs_fifo_3.phy_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_2.qs_fifo_3.phy_ff);
            release `DXn_inst.datx8_dq_3.qs_fifo_3.phy_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_3.qs_fifo_3.phy_ff);
            release `DXn_inst.datx8_dq_4.qs_fifo_3.phy_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_4.qs_fifo_3.phy_ff);
            release `DXn_inst.datx8_dq_5.qs_fifo_3.phy_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_5.qs_fifo_3.phy_ff);
            release `DXn_inst.datx8_dq_6.qs_fifo_3.phy_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_6.qs_fifo_3.phy_ff);
            release `DXn_inst.datx8_dq_7.qs_fifo_3.phy_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_7.qs_fifo_3.phy_ff);
            release `DXn_inst.datx8_dq_8.qs_fifo_3.phy_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_8.qs_fifo_3.phy_ff);

`ifdef DWC_DDRPHY_X4X2
            release `DXn_inst.datx8_dq_9.qs_fifo_3.phy_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_9.qs_fifo_3.phy_ff);
            release `DXn_inst.datx8_dq_9.qs_fifo_2.phy_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_9.qs_fifo_2.phy_ff);
            release `DXn_inst.datx8_dq_9.qs_fifo_1.phy_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_9.qs_fifo_1.phy_ff);
            release `DXn_inst.datx8_dq_9.qs_fifo_0.phy_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_9.qs_fifo_0.phy_ff);
`endif

            // Some flops in the read FIFO may violate during training as the DQS gate or DQS or DQ are moved
            // around; same with QS/QSN pointer flops
            release `DXn_inst.datx8_dq_0.qs_fifo_0.qs_n_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_0.qs_fifo_0.qs_n_ff_0);
            release `DXn_inst.datx8_dq_1.qs_fifo_0.qs_n_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_1.qs_fifo_0.qs_n_ff_0);
            release `DXn_inst.datx8_dq_2.qs_fifo_0.qs_n_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_2.qs_fifo_0.qs_n_ff_0);
            release `DXn_inst.datx8_dq_3.qs_fifo_0.qs_n_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_3.qs_fifo_0.qs_n_ff_0);
            release `DXn_inst.datx8_dq_4.qs_fifo_0.qs_n_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_4.qs_fifo_0.qs_n_ff_0);
            release `DXn_inst.datx8_dq_5.qs_fifo_0.qs_n_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_5.qs_fifo_0.qs_n_ff_0);
            release `DXn_inst.datx8_dq_6.qs_fifo_0.qs_n_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_6.qs_fifo_0.qs_n_ff_0);
            release `DXn_inst.datx8_dq_7.qs_fifo_0.qs_n_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_7.qs_fifo_0.qs_n_ff_0);
            release `DXn_inst.datx8_dq_8.qs_fifo_0.qs_n_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_8.qs_fifo_0.qs_n_ff_0);
            release `DXn_inst.datx8_dq_0.qs_fifo_1.qs_n_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_0.qs_fifo_1.qs_n_ff_0);
            release `DXn_inst.datx8_dq_1.qs_fifo_1.qs_n_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_1.qs_fifo_1.qs_n_ff_0);
            release `DXn_inst.datx8_dq_2.qs_fifo_1.qs_n_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_2.qs_fifo_1.qs_n_ff_0);
            release `DXn_inst.datx8_dq_3.qs_fifo_1.qs_n_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_3.qs_fifo_1.qs_n_ff_0);
            release `DXn_inst.datx8_dq_4.qs_fifo_1.qs_n_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_4.qs_fifo_1.qs_n_ff_0);
            release `DXn_inst.datx8_dq_5.qs_fifo_1.qs_n_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_5.qs_fifo_1.qs_n_ff_0);
            release `DXn_inst.datx8_dq_6.qs_fifo_1.qs_n_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_6.qs_fifo_1.qs_n_ff_0);
            release `DXn_inst.datx8_dq_7.qs_fifo_1.qs_n_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_7.qs_fifo_1.qs_n_ff_0);
            release `DXn_inst.datx8_dq_8.qs_fifo_1.qs_n_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_8.qs_fifo_1.qs_n_ff_0);
            release `DXn_inst.datx8_dq_0.qs_fifo_2.qs_n_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_0.qs_fifo_2.qs_n_ff_0);
            release `DXn_inst.datx8_dq_1.qs_fifo_2.qs_n_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_1.qs_fifo_2.qs_n_ff_0);
            release `DXn_inst.datx8_dq_2.qs_fifo_2.qs_n_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_2.qs_fifo_2.qs_n_ff_0);
            release `DXn_inst.datx8_dq_3.qs_fifo_2.qs_n_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_3.qs_fifo_2.qs_n_ff_0);
            release `DXn_inst.datx8_dq_4.qs_fifo_2.qs_n_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_4.qs_fifo_2.qs_n_ff_0);
            release `DXn_inst.datx8_dq_5.qs_fifo_2.qs_n_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_5.qs_fifo_2.qs_n_ff_0);
            release `DXn_inst.datx8_dq_6.qs_fifo_2.qs_n_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_6.qs_fifo_2.qs_n_ff_0);
            release `DXn_inst.datx8_dq_7.qs_fifo_2.qs_n_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_7.qs_fifo_2.qs_n_ff_0);
            release `DXn_inst.datx8_dq_8.qs_fifo_2.qs_n_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_8.qs_fifo_2.qs_n_ff_0);
            release `DXn_inst.datx8_dq_0.qs_fifo_3.qs_n_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_0.qs_fifo_3.qs_n_ff_0);
            release `DXn_inst.datx8_dq_1.qs_fifo_3.qs_n_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_1.qs_fifo_3.qs_n_ff_0);
            release `DXn_inst.datx8_dq_2.qs_fifo_3.qs_n_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_2.qs_fifo_3.qs_n_ff_0);
            release `DXn_inst.datx8_dq_3.qs_fifo_3.qs_n_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_3.qs_fifo_3.qs_n_ff_0);
            release `DXn_inst.datx8_dq_4.qs_fifo_3.qs_n_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_4.qs_fifo_3.qs_n_ff_0);
            release `DXn_inst.datx8_dq_5.qs_fifo_3.qs_n_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_5.qs_fifo_3.qs_n_ff_0);
            release `DXn_inst.datx8_dq_6.qs_fifo_3.qs_n_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_6.qs_fifo_3.qs_n_ff_0);
            release `DXn_inst.datx8_dq_7.qs_fifo_3.qs_n_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_7.qs_fifo_3.qs_n_ff_0);
            release `DXn_inst.datx8_dq_8.qs_fifo_3.qs_n_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_8.qs_fifo_3.qs_n_ff_0);

            release `DXn_inst.datx8_dq_0.qs_fifo_0.qs_n_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_0.qs_fifo_0.qs_n_ff_1);
            release `DXn_inst.datx8_dq_1.qs_fifo_0.qs_n_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_1.qs_fifo_0.qs_n_ff_1);
            release `DXn_inst.datx8_dq_2.qs_fifo_0.qs_n_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_2.qs_fifo_0.qs_n_ff_1);
            release `DXn_inst.datx8_dq_3.qs_fifo_0.qs_n_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_3.qs_fifo_0.qs_n_ff_1);
            release `DXn_inst.datx8_dq_4.qs_fifo_0.qs_n_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_4.qs_fifo_0.qs_n_ff_1);
            release `DXn_inst.datx8_dq_5.qs_fifo_0.qs_n_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_5.qs_fifo_0.qs_n_ff_1);
            release `DXn_inst.datx8_dq_6.qs_fifo_0.qs_n_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_6.qs_fifo_0.qs_n_ff_1);
            release `DXn_inst.datx8_dq_7.qs_fifo_0.qs_n_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_7.qs_fifo_0.qs_n_ff_1);
            release `DXn_inst.datx8_dq_8.qs_fifo_0.qs_n_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_8.qs_fifo_0.qs_n_ff_1);
            release `DXn_inst.datx8_dq_0.qs_fifo_1.qs_n_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_0.qs_fifo_1.qs_n_ff_1);
            release `DXn_inst.datx8_dq_1.qs_fifo_1.qs_n_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_1.qs_fifo_1.qs_n_ff_1);
            release `DXn_inst.datx8_dq_2.qs_fifo_1.qs_n_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_2.qs_fifo_1.qs_n_ff_1);
            release `DXn_inst.datx8_dq_3.qs_fifo_1.qs_n_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_3.qs_fifo_1.qs_n_ff_1);
            release `DXn_inst.datx8_dq_4.qs_fifo_1.qs_n_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_4.qs_fifo_1.qs_n_ff_1);
            release `DXn_inst.datx8_dq_5.qs_fifo_1.qs_n_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_5.qs_fifo_1.qs_n_ff_1);
            release `DXn_inst.datx8_dq_6.qs_fifo_1.qs_n_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_6.qs_fifo_1.qs_n_ff_1);
            release `DXn_inst.datx8_dq_7.qs_fifo_1.qs_n_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_7.qs_fifo_1.qs_n_ff_1);
            release `DXn_inst.datx8_dq_8.qs_fifo_1.qs_n_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_8.qs_fifo_1.qs_n_ff_1);
            release `DXn_inst.datx8_dq_0.qs_fifo_2.qs_n_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_0.qs_fifo_2.qs_n_ff_1);
            release `DXn_inst.datx8_dq_1.qs_fifo_2.qs_n_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_1.qs_fifo_2.qs_n_ff_1);
            release `DXn_inst.datx8_dq_2.qs_fifo_2.qs_n_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_2.qs_fifo_2.qs_n_ff_1);
            release `DXn_inst.datx8_dq_3.qs_fifo_2.qs_n_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_3.qs_fifo_2.qs_n_ff_1);
            release `DXn_inst.datx8_dq_4.qs_fifo_2.qs_n_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_4.qs_fifo_2.qs_n_ff_1);
            release `DXn_inst.datx8_dq_5.qs_fifo_2.qs_n_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_5.qs_fifo_2.qs_n_ff_1);
            release `DXn_inst.datx8_dq_6.qs_fifo_2.qs_n_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_6.qs_fifo_2.qs_n_ff_1);
            release `DXn_inst.datx8_dq_7.qs_fifo_2.qs_n_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_7.qs_fifo_2.qs_n_ff_1);
            release `DXn_inst.datx8_dq_8.qs_fifo_2.qs_n_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_8.qs_fifo_2.qs_n_ff_1);
            release `DXn_inst.datx8_dq_0.qs_fifo_3.qs_n_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_0.qs_fifo_3.qs_n_ff_1);
            release `DXn_inst.datx8_dq_1.qs_fifo_3.qs_n_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_1.qs_fifo_3.qs_n_ff_1);
            release `DXn_inst.datx8_dq_2.qs_fifo_3.qs_n_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_2.qs_fifo_3.qs_n_ff_1);
            release `DXn_inst.datx8_dq_3.qs_fifo_3.qs_n_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_3.qs_fifo_3.qs_n_ff_1);
            release `DXn_inst.datx8_dq_4.qs_fifo_3.qs_n_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_4.qs_fifo_3.qs_n_ff_1);
            release `DXn_inst.datx8_dq_5.qs_fifo_3.qs_n_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_5.qs_fifo_3.qs_n_ff_1);
            release `DXn_inst.datx8_dq_6.qs_fifo_3.qs_n_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_6.qs_fifo_3.qs_n_ff_1);
            release `DXn_inst.datx8_dq_7.qs_fifo_3.qs_n_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_7.qs_fifo_3.qs_n_ff_1);
            release `DXn_inst.datx8_dq_8.qs_fifo_3.qs_n_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_8.qs_fifo_3.qs_n_ff_1);

            release `DXn_inst.datx8_dq_0.qs_fifo_0.qs_n_ff_2.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_0.qs_fifo_0.qs_n_ff_2);
            release `DXn_inst.datx8_dq_1.qs_fifo_0.qs_n_ff_2.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_1.qs_fifo_0.qs_n_ff_2);
            release `DXn_inst.datx8_dq_2.qs_fifo_0.qs_n_ff_2.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_2.qs_fifo_0.qs_n_ff_2);
            release `DXn_inst.datx8_dq_3.qs_fifo_0.qs_n_ff_2.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_3.qs_fifo_0.qs_n_ff_2);
            release `DXn_inst.datx8_dq_4.qs_fifo_0.qs_n_ff_2.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_4.qs_fifo_0.qs_n_ff_2);
            release `DXn_inst.datx8_dq_5.qs_fifo_0.qs_n_ff_2.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_5.qs_fifo_0.qs_n_ff_2);
            release `DXn_inst.datx8_dq_6.qs_fifo_0.qs_n_ff_2.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_6.qs_fifo_0.qs_n_ff_2);
            release `DXn_inst.datx8_dq_7.qs_fifo_0.qs_n_ff_2.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_7.qs_fifo_0.qs_n_ff_2);
            release `DXn_inst.datx8_dq_8.qs_fifo_0.qs_n_ff_2.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_8.qs_fifo_0.qs_n_ff_2);
            release `DXn_inst.datx8_dq_0.qs_fifo_1.qs_n_ff_2.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_0.qs_fifo_1.qs_n_ff_2);
            release `DXn_inst.datx8_dq_1.qs_fifo_1.qs_n_ff_2.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_1.qs_fifo_1.qs_n_ff_2);
            release `DXn_inst.datx8_dq_2.qs_fifo_1.qs_n_ff_2.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_2.qs_fifo_1.qs_n_ff_2);
            release `DXn_inst.datx8_dq_3.qs_fifo_1.qs_n_ff_2.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_3.qs_fifo_1.qs_n_ff_2);
            release `DXn_inst.datx8_dq_4.qs_fifo_1.qs_n_ff_2.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_4.qs_fifo_1.qs_n_ff_2);
            release `DXn_inst.datx8_dq_5.qs_fifo_1.qs_n_ff_2.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_5.qs_fifo_1.qs_n_ff_2);
            release `DXn_inst.datx8_dq_6.qs_fifo_1.qs_n_ff_2.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_6.qs_fifo_1.qs_n_ff_2);
            release `DXn_inst.datx8_dq_7.qs_fifo_1.qs_n_ff_2.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_7.qs_fifo_1.qs_n_ff_2);
            release `DXn_inst.datx8_dq_8.qs_fifo_1.qs_n_ff_2.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_8.qs_fifo_1.qs_n_ff_2);
            release `DXn_inst.datx8_dq_0.qs_fifo_2.qs_n_ff_2.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_0.qs_fifo_2.qs_n_ff_2);
            release `DXn_inst.datx8_dq_1.qs_fifo_2.qs_n_ff_2.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_1.qs_fifo_2.qs_n_ff_2);
            release `DXn_inst.datx8_dq_2.qs_fifo_2.qs_n_ff_2.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_2.qs_fifo_2.qs_n_ff_2);
            release `DXn_inst.datx8_dq_3.qs_fifo_2.qs_n_ff_2.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_3.qs_fifo_2.qs_n_ff_2);
            release `DXn_inst.datx8_dq_4.qs_fifo_2.qs_n_ff_2.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_4.qs_fifo_2.qs_n_ff_2);
            release `DXn_inst.datx8_dq_5.qs_fifo_2.qs_n_ff_2.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_5.qs_fifo_2.qs_n_ff_2);
            release `DXn_inst.datx8_dq_6.qs_fifo_2.qs_n_ff_2.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_6.qs_fifo_2.qs_n_ff_2);
            release `DXn_inst.datx8_dq_7.qs_fifo_2.qs_n_ff_2.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_7.qs_fifo_2.qs_n_ff_2);
            release `DXn_inst.datx8_dq_8.qs_fifo_2.qs_n_ff_2.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_8.qs_fifo_2.qs_n_ff_2);
            release `DXn_inst.datx8_dq_0.qs_fifo_3.qs_n_ff_2.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_0.qs_fifo_3.qs_n_ff_2);
            release `DXn_inst.datx8_dq_1.qs_fifo_3.qs_n_ff_2.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_1.qs_fifo_3.qs_n_ff_2);
            release `DXn_inst.datx8_dq_2.qs_fifo_3.qs_n_ff_2.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_2.qs_fifo_3.qs_n_ff_2);
            release `DXn_inst.datx8_dq_3.qs_fifo_3.qs_n_ff_2.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_3.qs_fifo_3.qs_n_ff_2);
            release `DXn_inst.datx8_dq_4.qs_fifo_3.qs_n_ff_2.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_4.qs_fifo_3.qs_n_ff_2);
            release `DXn_inst.datx8_dq_5.qs_fifo_3.qs_n_ff_2.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_5.qs_fifo_3.qs_n_ff_2);
            release `DXn_inst.datx8_dq_6.qs_fifo_3.qs_n_ff_2.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_6.qs_fifo_3.qs_n_ff_2);
            release `DXn_inst.datx8_dq_7.qs_fifo_3.qs_n_ff_2.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_7.qs_fifo_3.qs_n_ff_2);
            release `DXn_inst.datx8_dq_8.qs_fifo_3.qs_n_ff_2.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_8.qs_fifo_3.qs_n_ff_2);

            release `DXn_inst.datx8_dq_0.qs_fifo_0.qs_n_ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_0.qs_fifo_0.qs_n_ff_3);
            release `DXn_inst.datx8_dq_1.qs_fifo_0.qs_n_ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_1.qs_fifo_0.qs_n_ff_3);
            release `DXn_inst.datx8_dq_2.qs_fifo_0.qs_n_ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_2.qs_fifo_0.qs_n_ff_3);
            release `DXn_inst.datx8_dq_3.qs_fifo_0.qs_n_ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_3.qs_fifo_0.qs_n_ff_3);
            release `DXn_inst.datx8_dq_4.qs_fifo_0.qs_n_ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_4.qs_fifo_0.qs_n_ff_3);
            release `DXn_inst.datx8_dq_5.qs_fifo_0.qs_n_ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_5.qs_fifo_0.qs_n_ff_3);
            release `DXn_inst.datx8_dq_6.qs_fifo_0.qs_n_ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_6.qs_fifo_0.qs_n_ff_3);
            release `DXn_inst.datx8_dq_7.qs_fifo_0.qs_n_ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_7.qs_fifo_0.qs_n_ff_3);
            release `DXn_inst.datx8_dq_8.qs_fifo_0.qs_n_ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_8.qs_fifo_0.qs_n_ff_3);
            release `DXn_inst.datx8_dq_0.qs_fifo_1.qs_n_ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_0.qs_fifo_1.qs_n_ff_3);
            release `DXn_inst.datx8_dq_1.qs_fifo_1.qs_n_ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_1.qs_fifo_1.qs_n_ff_3);
            release `DXn_inst.datx8_dq_2.qs_fifo_1.qs_n_ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_2.qs_fifo_1.qs_n_ff_3);
            release `DXn_inst.datx8_dq_3.qs_fifo_1.qs_n_ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_3.qs_fifo_1.qs_n_ff_3);
            release `DXn_inst.datx8_dq_4.qs_fifo_1.qs_n_ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_4.qs_fifo_1.qs_n_ff_3);
            release `DXn_inst.datx8_dq_5.qs_fifo_1.qs_n_ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_5.qs_fifo_1.qs_n_ff_3);
            release `DXn_inst.datx8_dq_6.qs_fifo_1.qs_n_ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_6.qs_fifo_1.qs_n_ff_3);
            release `DXn_inst.datx8_dq_7.qs_fifo_1.qs_n_ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_7.qs_fifo_1.qs_n_ff_3);
            release `DXn_inst.datx8_dq_8.qs_fifo_1.qs_n_ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_8.qs_fifo_1.qs_n_ff_3);
            release `DXn_inst.datx8_dq_0.qs_fifo_2.qs_n_ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_0.qs_fifo_2.qs_n_ff_3);
            release `DXn_inst.datx8_dq_1.qs_fifo_2.qs_n_ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_1.qs_fifo_2.qs_n_ff_3);
            release `DXn_inst.datx8_dq_2.qs_fifo_2.qs_n_ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_2.qs_fifo_2.qs_n_ff_3);
            release `DXn_inst.datx8_dq_3.qs_fifo_2.qs_n_ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_3.qs_fifo_2.qs_n_ff_3);
            release `DXn_inst.datx8_dq_4.qs_fifo_2.qs_n_ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_4.qs_fifo_2.qs_n_ff_3);
            release `DXn_inst.datx8_dq_5.qs_fifo_2.qs_n_ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_5.qs_fifo_2.qs_n_ff_3);
            release `DXn_inst.datx8_dq_6.qs_fifo_2.qs_n_ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_6.qs_fifo_2.qs_n_ff_3);
            release `DXn_inst.datx8_dq_7.qs_fifo_2.qs_n_ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_7.qs_fifo_2.qs_n_ff_3);
            release `DXn_inst.datx8_dq_8.qs_fifo_2.qs_n_ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_8.qs_fifo_2.qs_n_ff_3);
            release `DXn_inst.datx8_dq_0.qs_fifo_3.qs_n_ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_0.qs_fifo_3.qs_n_ff_3);
            release `DXn_inst.datx8_dq_1.qs_fifo_3.qs_n_ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_1.qs_fifo_3.qs_n_ff_3);
            release `DXn_inst.datx8_dq_2.qs_fifo_3.qs_n_ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_2.qs_fifo_3.qs_n_ff_3);
            release `DXn_inst.datx8_dq_3.qs_fifo_3.qs_n_ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_3.qs_fifo_3.qs_n_ff_3);
            release `DXn_inst.datx8_dq_4.qs_fifo_3.qs_n_ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_4.qs_fifo_3.qs_n_ff_3);
            release `DXn_inst.datx8_dq_5.qs_fifo_3.qs_n_ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_5.qs_fifo_3.qs_n_ff_3);
            release `DXn_inst.datx8_dq_6.qs_fifo_3.qs_n_ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_6.qs_fifo_3.qs_n_ff_3);
            release `DXn_inst.datx8_dq_7.qs_fifo_3.qs_n_ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_7.qs_fifo_3.qs_n_ff_3);
            release `DXn_inst.datx8_dq_8.qs_fifo_3.qs_n_ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_8.qs_fifo_3.qs_n_ff_3);

`ifdef DWC_DDRPHY_X4X2  

	    release `DXn_inst.datx8_dq_9.qs_fifo_3.qs_n_ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_9.qs_fifo_3.qs_n_ff_0);
	    release `DXn_inst.datx8_dq_9.qs_fifo_3.qs_n_ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_9.qs_fifo_3.qs_n_ff_1);
	    release `DXn_inst.datx8_dq_9.qs_fifo_3.qs_n_ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_9.qs_fifo_3.qs_n_ff_2);
	    release `DXn_inst.datx8_dq_9.qs_fifo_3.qs_n_ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_9.qs_fifo_3.qs_n_ff_3);
	    release `DXn_inst.datx8_dq_9.qs_fifo_2.qs_n_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_9.qs_fifo_2.qs_n_ff_0);
	    release `DXn_inst.datx8_dq_9.qs_fifo_2.qs_n_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_9.qs_fifo_2.qs_n_ff_1);
	    release `DXn_inst.datx8_dq_9.qs_fifo_2.qs_n_ff_2.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_9.qs_fifo_2.qs_n_ff_2);
	    release `DXn_inst.datx8_dq_9.qs_fifo_2.qs_n_ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_9.qs_fifo_2.qs_n_ff_3);
	    release `DXn_inst.datx8_dq_9.qs_fifo_1.qs_n_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_9.qs_fifo_1.qs_n_ff_0);
	    release `DXn_inst.datx8_dq_9.qs_fifo_1.qs_n_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_9.qs_fifo_1.qs_n_ff_1);
	    release `DXn_inst.datx8_dq_9.qs_fifo_1.qs_n_ff_2.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_9.qs_fifo_1.qs_n_ff_2);
	    release `DXn_inst.datx8_dq_9.qs_fifo_1.qs_n_ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_9.qs_fifo_1.qs_n_ff_3);
	    release `DXn_inst.datx8_dq_9.qs_fifo_0.qs_n_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_9.qs_fifo_0.qs_n_ff_0);
	    release `DXn_inst.datx8_dq_9.qs_fifo_0.qs_n_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_9.qs_fifo_0.qs_n_ff_1);
	    release `DXn_inst.datx8_dq_9.qs_fifo_0.qs_n_ff_2.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_9.qs_fifo_0.qs_n_ff_2);
	    release `DXn_inst.datx8_dq_9.qs_fifo_0.qs_n_ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_9.qs_fifo_0.qs_n_ff_3);

`endif

            release `DXn_inst.datx8_dq_0.qs_q_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_0.qs_q_ff);
            release `DXn_inst.datx8_dq_1.qs_q_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_1.qs_q_ff);
            release `DXn_inst.datx8_dq_2.qs_q_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_2.qs_q_ff);
            release `DXn_inst.datx8_dq_3.qs_q_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_3.qs_q_ff);
            release `DXn_inst.datx8_dq_4.qs_q_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_4.qs_q_ff);
            release `DXn_inst.datx8_dq_5.qs_q_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_5.qs_q_ff);
            release `DXn_inst.datx8_dq_6.qs_q_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_6.qs_q_ff);
            release `DXn_inst.datx8_dq_7.qs_q_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_7.qs_q_ff);
            release `DXn_inst.datx8_dq_8.qs_q_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_8.qs_q_ff);
            release `DXn_inst.`DX_DQS0.qs_q_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS0.qs_q_ff);

`ifdef DWC_DDRPHY_X4X2  

	    release `DXn_inst.datx8_dq_9.qs_q_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_9.qs_q_ff);
            release `DXn_inst.`DX_DQS1.qs_q_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS1.qs_q_ff);
            release `DXn_inst.datx8_dq_9.qs_n_q_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_9.qs_n_q_ff_1);
            release `DXn_inst.datx8_dq_9.qs_n_q_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_9.qs_n_q_ff_0);

`endif

            release `DXn_inst.datx8_dq_0.qs_n_q_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_0.qs_n_q_ff_1);
            release `DXn_inst.datx8_dq_1.qs_n_q_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_1.qs_n_q_ff_1);
            release `DXn_inst.datx8_dq_2.qs_n_q_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_2.qs_n_q_ff_1);
            release `DXn_inst.datx8_dq_3.qs_n_q_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_3.qs_n_q_ff_1);
            release `DXn_inst.datx8_dq_4.qs_n_q_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_4.qs_n_q_ff_1);
            release `DXn_inst.datx8_dq_5.qs_n_q_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_5.qs_n_q_ff_1);
            release `DXn_inst.datx8_dq_6.qs_n_q_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_6.qs_n_q_ff_1);
            release `DXn_inst.datx8_dq_7.qs_n_q_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_7.qs_n_q_ff_1);
            release `DXn_inst.datx8_dq_8.qs_n_q_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_8.qs_n_q_ff_1);

            release `DXn_inst.datx8_dq_0.qs_n_q_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_0.qs_n_q_ff_0);
            release `DXn_inst.datx8_dq_1.qs_n_q_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_1.qs_n_q_ff_0);
            release `DXn_inst.datx8_dq_2.qs_n_q_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_2.qs_n_q_ff_0);
            release `DXn_inst.datx8_dq_3.qs_n_q_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_3.qs_n_q_ff_0);
            release `DXn_inst.datx8_dq_4.qs_n_q_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_4.qs_n_q_ff_0);
            release `DXn_inst.datx8_dq_5.qs_n_q_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_5.qs_n_q_ff_0);
            release `DXn_inst.datx8_dq_6.qs_n_q_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_6.qs_n_q_ff_0);
            release `DXn_inst.datx8_dq_7.qs_n_q_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_7.qs_n_q_ff_0);
            release `DXn_inst.datx8_dq_8.qs_n_q_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_8.qs_n_q_ff_0);

	    release `DXn_inst.`DX_DQS0.qs_n_q_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS0.qs_n_q_ff_0);
	    release `DXn_inst.`DX_DQS0.qs_n_q_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS0.qs_n_q_ff_1);

    	    release `DXn_inst.`DX_DQS0.qs_fifo_0.qs_n_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS0.qs_fifo_0.qs_n_ff_0);
	    release `DXn_inst.`DX_DQS0.qs_fifo_0.qs_n_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS0.qs_fifo_0.qs_n_ff_1);
    	    release `DXn_inst.`DX_DQS0.qs_fifo_0.qs_n_ff_2.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS0.qs_fifo_0.qs_n_ff_2);
	    release `DXn_inst.`DX_DQS0.qs_fifo_0.qs_n_ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS0.qs_fifo_0.qs_n_ff_3);

    	    release `DXn_inst.`DX_DQS0.qs_fifo_1.qs_n_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS0.qs_fifo_1.qs_n_ff_0);
	    release `DXn_inst.`DX_DQS0.qs_fifo_1.qs_n_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS0.qs_fifo_1.qs_n_ff_1);
    	    release `DXn_inst.`DX_DQS0.qs_fifo_1.qs_n_ff_2.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS0.qs_fifo_1.qs_n_ff_2);
	    release `DXn_inst.`DX_DQS0.qs_fifo_1.qs_n_ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS0.qs_fifo_1.qs_n_ff_3);

    	    release `DXn_inst.`DX_DQS0.qs_fifo_2.qs_n_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS0.qs_fifo_2.qs_n_ff_0);
	    release `DXn_inst.`DX_DQS0.qs_fifo_2.qs_n_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS0.qs_fifo_2.qs_n_ff_1);
    	    release `DXn_inst.`DX_DQS0.qs_fifo_2.qs_n_ff_2.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS0.qs_fifo_2.qs_n_ff_2);
	    release `DXn_inst.`DX_DQS0.qs_fifo_2.qs_n_ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS0.qs_fifo_2.qs_n_ff_3);

    	    release `DXn_inst.`DX_DQS0.qs_fifo_3.qs_n_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS0.qs_fifo_3.qs_n_ff_0);
	    release `DXn_inst.`DX_DQS0.qs_fifo_3.qs_n_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS0.qs_fifo_3.qs_n_ff_1);
    	    release `DXn_inst.`DX_DQS0.qs_fifo_3.qs_n_ff_2.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS0.qs_fifo_3.qs_n_ff_2);
	    release `DXn_inst.`DX_DQS0.qs_fifo_3.qs_n_ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS0.qs_fifo_3.qs_n_ff_3);

            release `DXn_inst.`DX_DQS0.qs_n_ptr_lwr_reg.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS0.qs_n_ptr_lwr_reg);
            release `DXn_inst.`DX_DQS0.qs_n_ptr_reg_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS0.qs_n_ptr_reg_0);
            release `DXn_inst.`DX_DQS0.qs_n_ptr_reg_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS0.qs_n_ptr_reg_1);


            release `DXn_inst.`DX_DQS0.get_rdata_reg.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS0.get_rdata_reg);
            release `DXn_inst.`DX_DQS0.rdptr_reg_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS0.rdptr_reg_0);
            release `DXn_inst.`DX_DQS0.rdptr_reg_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS0.rdptr_reg_1);
            release `DXn_inst.`DX_DQS0.phyqvld_reg.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS0.phyqvld_reg);
            release `DXn_inst.`DX_DQS0.dqs_gate.qs_n_cnt_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS0.dqs_gate.qs_n_cnt_ff);


`ifdef DWC_DDRPHY_X4X2  
            release `DXn_inst.`DX_DQS1.qs_n_ptr_lwr_reg.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS1.qs_n_ptr_lwr_reg);
            release `DXn_inst.`DX_DQS1.qs_n_ptr_reg_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS1.qs_n_ptr_reg_0);
            release `DXn_inst.`DX_DQS1.qs_n_ptr_reg_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS1.qs_n_ptr_reg_1);

 	    release `DXn_inst.`DX_DQS1.qs_n_q_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS1.qs_n_q_ff_0);
	    release `DXn_inst.`DX_DQS1.qs_n_q_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS1.qs_n_q_ff_1);

    	    release `DXn_inst.`DX_DQS1.qs_fifo_0.qs_n_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS1.qs_fifo_0.qs_n_ff_0);
	    release `DXn_inst.`DX_DQS1.qs_fifo_0.qs_n_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS1.qs_fifo_0.qs_n_ff_1);
    	    release `DXn_inst.`DX_DQS1.qs_fifo_0.qs_n_ff_2.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS1.qs_fifo_0.qs_n_ff_2);
	    release `DXn_inst.`DX_DQS1.qs_fifo_0.qs_n_ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS1.qs_fifo_0.qs_n_ff_3);

    	    release `DXn_inst.`DX_DQS1.qs_fifo_1.qs_n_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS1.qs_fifo_1.qs_n_ff_0);
	    release `DXn_inst.`DX_DQS1.qs_fifo_1.qs_n_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS1.qs_fifo_1.qs_n_ff_1);
    	    release `DXn_inst.`DX_DQS1.qs_fifo_1.qs_n_ff_2.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS1.qs_fifo_1.qs_n_ff_2);
	    release `DXn_inst.`DX_DQS1.qs_fifo_1.qs_n_ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS1.qs_fifo_1.qs_n_ff_3);

    	    release `DXn_inst.`DX_DQS1.qs_fifo_2.qs_n_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS1.qs_fifo_2.qs_n_ff_0);
	    release `DXn_inst.`DX_DQS1.qs_fifo_2.qs_n_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS1.qs_fifo_2.qs_n_ff_1);
    	    release `DXn_inst.`DX_DQS1.qs_fifo_2.qs_n_ff_2.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS1.qs_fifo_2.qs_n_ff_2);
	    release `DXn_inst.`DX_DQS1.qs_fifo_2.qs_n_ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS1.qs_fifo_2.qs_n_ff_3);

    	    release `DXn_inst.`DX_DQS1.qs_fifo_3.qs_n_ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS1.qs_fifo_3.qs_n_ff_0);
	    release `DXn_inst.`DX_DQS1.qs_fifo_3.qs_n_ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS1.qs_fifo_3.qs_n_ff_1);
    	    release `DXn_inst.`DX_DQS1.qs_fifo_3.qs_n_ff_2.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS1.qs_fifo_3.qs_n_ff_2);
	    release `DXn_inst.`DX_DQS1.qs_fifo_3.qs_n_ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS1.qs_fifo_3.qs_n_ff_3);
 
 	    release `DXn_inst.`DX_DQS1.get_rdata_reg.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS1.get_rdata_reg);
            release `DXn_inst.`DX_DQS1.rdptr_reg_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS1.rdptr_reg_0);
            release `DXn_inst.`DX_DQS1.rdptr_reg_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS1.rdptr_reg_1);
            release `DXn_inst.`DX_DQS1.phyqvld_reg.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS1.phyqvld_reg);
            release `DXn_inst.`DX_DQS1.dqs_gate.qs_n_cnt_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS1.dqs_gate.qs_n_cnt_ff);


`endif
 	    release `DXn_inst.`DX_CTRL.rd_rst_n_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_CTRL.rd_rst_n_ff);
 	    release `DXn_inst.`DX_CTRL.rdfifo_rst_n_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_CTRL.rdfifo_rst_n_ff);



            release `DXn_inst.datx8_dq_0.d_drmux.ddro.ddr_d_1_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_0.d_drmux.ddro.ddr_d_1_ff);
            release `DXn_inst.datx8_dq_1.d_drmux.ddro.ddr_d_1_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_1.d_drmux.ddro.ddr_d_1_ff);
            release `DXn_inst.datx8_dq_2.d_drmux.ddro.ddr_d_1_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_2.d_drmux.ddro.ddr_d_1_ff);
            release `DXn_inst.datx8_dq_3.d_drmux.ddro.ddr_d_1_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_3.d_drmux.ddro.ddr_d_1_ff);
            release `DXn_inst.datx8_dq_4.d_drmux.ddro.ddr_d_1_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_4.d_drmux.ddro.ddr_d_1_ff);
            release `DXn_inst.datx8_dq_5.d_drmux.ddro.ddr_d_1_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_5.d_drmux.ddro.ddr_d_1_ff);
            release `DXn_inst.datx8_dq_6.d_drmux.ddro.ddr_d_1_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_6.d_drmux.ddro.ddr_d_1_ff);
            release `DXn_inst.datx8_dq_7.d_drmux.ddro.ddr_d_1_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_7.d_drmux.ddro.ddr_d_1_ff);
            release `DXn_inst.datx8_dq_8.d_drmux.ddro.ddr_d_1_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.datx8_dq_8.d_drmux.ddro.ddr_d_1_ff);

            release `DXn_inst.`DX_DQS_DDRCNT.ddr_d_ld_0_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS_DDRCNT.ddr_d_ld_0_ff);
            release `DXn_inst.`DX_DQ_DDRCNT.ddr_d_ld_0_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQ_DDRCNT.ddr_d_ld_0_ff);
            release `DXn_inst.`DX_CTRL_DDRCNT.ddr_d_ld_0_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_CTRL_DDRCNT.ddr_d_ld_0_ff);

            release `DXn_inst.`DX_DQS_DDRCNT.ddr_d_ld_1_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS_DDRCNT.ddr_d_ld_1_ff);
            release `DXn_inst.`DX_DQ_DDRCNT.ddr_d_ld_1_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQ_DDRCNT.ddr_d_ld_1_ff);
            release `DXn_inst.`DX_CTRL_DDRCNT.ddr_d_ld_1_ff.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_CTRL_DDRCNT.ddr_d_ld_1_ff);

            release `DXn_inst.`DX_CLKGEN0.wl_dly_pipe.dly_p2_regx9.ff_8.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_CLKGEN0.wl_dly_pipe.dly_p2_regx9.ff_8);
            release `DXn_inst.`DX_CLKGEN0.wl_dly_pipe.dly_p2_regx9.ff_7.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_CLKGEN0.wl_dly_pipe.dly_p2_regx9.ff_7);
            release `DXn_inst.`DX_CLKGEN0.wl_dly_pipe.dly_p2_regx9.ff_6.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_CLKGEN0.wl_dly_pipe.dly_p2_regx9.ff_6);
            release `DXn_inst.`DX_CLKGEN0.wl_dly_pipe.dly_p2_regx9.ff_5.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_CLKGEN0.wl_dly_pipe.dly_p2_regx9.ff_5);
            release `DXn_inst.`DX_CLKGEN0.wl_dly_pipe.dly_p2_regx9.ff_4.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_CLKGEN0.wl_dly_pipe.dly_p2_regx9.ff_4);
            release `DXn_inst.`DX_CLKGEN0.wl_dly_pipe.dly_p2_regx9.ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_CLKGEN0.wl_dly_pipe.dly_p2_regx9.ff_3);
            release `DXn_inst.`DX_CLKGEN0.wl_dly_pipe.dly_p2_regx9.ff_2.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_CLKGEN0.wl_dly_pipe.dly_p2_regx9.ff_2);
            release `DXn_inst.`DX_CLKGEN0.wl_dly_pipe.dly_p2_regx9.ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_CLKGEN0.wl_dly_pipe.dly_p2_regx9.ff_1);
            release `DXn_inst.`DX_CLKGEN0.wl_dly_pipe.dly_p2_regx9.ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_CLKGEN0.wl_dly_pipe.dly_p2_regx9.ff_0);

            release `DXn_inst.`DX_CLKGEN0.wdq_dly_pipe.dly_p2_regx9.ff_8.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_CLKGEN0.wdq_dly_pipe.dly_p2_regx9.ff_8);
            release `DXn_inst.`DX_CLKGEN0.wdq_dly_pipe.dly_p2_regx9.ff_7.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_CLKGEN0.wdq_dly_pipe.dly_p2_regx9.ff_7);
            release `DXn_inst.`DX_CLKGEN0.wdq_dly_pipe.dly_p2_regx9.ff_6.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_CLKGEN0.wdq_dly_pipe.dly_p2_regx9.ff_6);
            release `DXn_inst.`DX_CLKGEN0.wdq_dly_pipe.dly_p2_regx9.ff_5.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_CLKGEN0.wdq_dly_pipe.dly_p2_regx9.ff_5);
            release `DXn_inst.`DX_CLKGEN0.wdq_dly_pipe.dly_p2_regx9.ff_4.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_CLKGEN0.wdq_dly_pipe.dly_p2_regx9.ff_4);
            release `DXn_inst.`DX_CLKGEN0.wdq_dly_pipe.dly_p2_regx9.ff_3.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_CLKGEN0.wdq_dly_pipe.dly_p2_regx9.ff_3);
            release `DXn_inst.`DX_CLKGEN0.wdq_dly_pipe.dly_p2_regx9.ff_2.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_CLKGEN0.wdq_dly_pipe.dly_p2_regx9.ff_2);
            release `DXn_inst.`DX_CLKGEN0.wdq_dly_pipe.dly_p2_regx9.ff_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_CLKGEN0.wdq_dly_pipe.dly_p2_regx9.ff_1);
            release `DXn_inst.`DX_CLKGEN0.wdq_dly_pipe.dly_p2_regx9.ff_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_CLKGEN0.wdq_dly_pipe.dly_p2_regx9.ff_0);

            release `DXn_inst.`DX_CLKGEN0.wdq_dly_pipe.dly_ld_drmux.ddro.ddr_d_ld_0_ff.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.`DX_CLKGEN0.wdq_dly_pipe.dly_ld_drmux.ddro.ddr_d_ld_0_ff);
            release `DXn_inst.`DX_CLKGEN0.wdq_dly_pipe.dly_ld_drmux.ddro.ddr_d_ld_1_ff.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.`DX_CLKGEN0.wdq_dly_pipe.dly_ld_drmux.ddro.ddr_d_ld_1_ff);
            release `DXn_inst.`DX_CLKGEN0.wdq_dly_pipe.dly_ld_drmux.ddro.ddr_d_0_ff.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.`DX_CLKGEN0.wdq_dly_pipe.dly_ld_drmux.ddro.ddr_d_0_ff);
            release `DXn_inst.`DX_CLKGEN0.wdq_dly_pipe.dly_ld_drmux.ddro.ddr_d_1_ff.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.`DX_CLKGEN0.wdq_dly_pipe.dly_ld_drmux.ddro.ddr_d_1_ff);
            release `DXn_inst.`DX_DQS0.ds_gate_lcdl_so_reg.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.`DX_DQS0.ds_gate_lcdl_so_reg);
            release `DXn_inst.`DX_DQS0.qs_q_ff.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.`DX_DQS0.qs_q_ff);

`ifdef DWC_DDRPHY_X4X2  
            release `DXn_inst.`DX_CLKGEN1.wl_dly_pipe.dly_p2_regx9.ff_8.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.`DX_CLKGEN1.wl_dly_pipe.dly_p2_regx9.ff_8);
            release `DXn_inst.`DX_CLKGEN1.wl_dly_pipe.dly_p2_regx9.ff_7.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.`DX_CLKGEN1.wl_dly_pipe.dly_p2_regx9.ff_7);
            release `DXn_inst.`DX_CLKGEN1.wl_dly_pipe.dly_p2_regx9.ff_6.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.`DX_CLKGEN1.wl_dly_pipe.dly_p2_regx9.ff_6);
            release `DXn_inst.`DX_CLKGEN1.wl_dly_pipe.dly_p2_regx9.ff_5.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.`DX_CLKGEN1.wl_dly_pipe.dly_p2_regx9.ff_5);
            release `DXn_inst.`DX_CLKGEN1.wl_dly_pipe.dly_p2_regx9.ff_4.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.`DX_CLKGEN1.wl_dly_pipe.dly_p2_regx9.ff_4);
            release `DXn_inst.`DX_CLKGEN1.wl_dly_pipe.dly_p2_regx9.ff_3.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.`DX_CLKGEN1.wl_dly_pipe.dly_p2_regx9.ff_3);
            release `DXn_inst.`DX_CLKGEN1.wl_dly_pipe.dly_p2_regx9.ff_2.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.`DX_CLKGEN1.wl_dly_pipe.dly_p2_regx9.ff_2);
            release `DXn_inst.`DX_CLKGEN1.wl_dly_pipe.dly_p2_regx9.ff_1.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.`DX_CLKGEN1.wl_dly_pipe.dly_p2_regx9.ff_1);
            release `DXn_inst.`DX_CLKGEN1.wl_dly_pipe.dly_p2_regx9.ff_0.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.`DX_CLKGEN1.wl_dly_pipe.dly_p2_regx9.ff_0);

            release `DXn_inst.`DX_CLKGEN1.wdq_dly_pipe.dly_p2_regx9.ff_8.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.`DX_CLKGEN1.wdq_dly_pipe.dly_p2_regx9.ff_8);
            release `DXn_inst.`DX_CLKGEN1.wdq_dly_pipe.dly_p2_regx9.ff_7.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.`DX_CLKGEN1.wdq_dly_pipe.dly_p2_regx9.ff_7);
            release `DXn_inst.`DX_CLKGEN1.wdq_dly_pipe.dly_p2_regx9.ff_6.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.`DX_CLKGEN1.wdq_dly_pipe.dly_p2_regx9.ff_6);
            release `DXn_inst.`DX_CLKGEN1.wdq_dly_pipe.dly_p2_regx9.ff_5.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.`DX_CLKGEN1.wdq_dly_pipe.dly_p2_regx9.ff_5);
            release `DXn_inst.`DX_CLKGEN1.wdq_dly_pipe.dly_p2_regx9.ff_4.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.`DX_CLKGEN1.wdq_dly_pipe.dly_p2_regx9.ff_4);
            release `DXn_inst.`DX_CLKGEN1.wdq_dly_pipe.dly_p2_regx9.ff_3.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.`DX_CLKGEN1.wdq_dly_pipe.dly_p2_regx9.ff_3);
            release `DXn_inst.`DX_CLKGEN1.wdq_dly_pipe.dly_p2_regx9.ff_2.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.`DX_CLKGEN1.wdq_dly_pipe.dly_p2_regx9.ff_2);
            release `DXn_inst.`DX_CLKGEN1.wdq_dly_pipe.dly_p2_regx9.ff_1.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.`DX_CLKGEN1.wdq_dly_pipe.dly_p2_regx9.ff_1);
            release `DXn_inst.`DX_CLKGEN1.wdq_dly_pipe.dly_p2_regx9.ff_0.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.`DX_CLKGEN1.wdq_dly_pipe.dly_p2_regx9.ff_0);

            release `DXn_inst.`DX_CLKGEN1.wdq_dly_pipe.dly_ld_drmux.ddro.ddr_d_ld_0_ff.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.`DX_CLKGEN1.wdq_dly_pipe.dly_ld_drmux.ddro.ddr_d_ld_0_ff);
            release `DXn_inst.`DX_CLKGEN1.wdq_dly_pipe.dly_ld_drmux.ddro.ddr_d_ld_1_ff.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.`DX_CLKGEN1.wdq_dly_pipe.dly_ld_drmux.ddro.ddr_d_ld_1_ff);
            release `DXn_inst.`DX_CLKGEN1.wdq_dly_pipe.dly_ld_drmux.ddro.ddr_d_0_ff.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.`DX_CLKGEN1.wdq_dly_pipe.dly_ld_drmux.ddro.ddr_d_0_ff);
            release `DXn_inst.`DX_CLKGEN1.wdq_dly_pipe.dly_ld_drmux.ddro.ddr_d_1_ff.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.`DX_CLKGEN1.wdq_dly_pipe.dly_ld_drmux.ddro.ddr_d_1_ff);
            release `DXn_inst.`DX_DQS1.ds_gate_lcdl_so_reg.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.`DX_DQS1.ds_gate_lcdl_so_reg);
            release `DXn_inst.`DX_DQS1.qs_q_ff.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.`DX_DQS1.qs_q_ff);
`endif

            release `DXn_inst.datx8_dq_0.d_drmux.ddro.ddr_d_ld_0_ff.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.datx8_dq_0.d_drmux.ddro.ddr_d_ld_0_ff);
            release `DXn_inst.datx8_dq_1.d_drmux.ddro.ddr_d_ld_0_ff.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.datx8_dq_1.d_drmux.ddro.ddr_d_ld_0_ff);
            release `DXn_inst.datx8_dq_2.d_drmux.ddro.ddr_d_ld_0_ff.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.datx8_dq_2.d_drmux.ddro.ddr_d_ld_0_ff);
            release `DXn_inst.datx8_dq_3.d_drmux.ddro.ddr_d_ld_0_ff.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.datx8_dq_3.d_drmux.ddro.ddr_d_ld_0_ff);
            release `DXn_inst.datx8_dq_4.d_drmux.ddro.ddr_d_ld_0_ff.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.datx8_dq_4.d_drmux.ddro.ddr_d_ld_0_ff);
            release `DXn_inst.datx8_dq_5.d_drmux.ddro.ddr_d_ld_0_ff.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.datx8_dq_5.d_drmux.ddro.ddr_d_ld_0_ff);
            release `DXn_inst.datx8_dq_6.d_drmux.ddro.ddr_d_ld_0_ff.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.datx8_dq_6.d_drmux.ddro.ddr_d_ld_0_ff);
            release `DXn_inst.datx8_dq_7.d_drmux.ddro.ddr_d_ld_0_ff.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.datx8_dq_7.d_drmux.ddro.ddr_d_ld_0_ff);
            release `DXn_inst.datx8_dq_8.d_drmux.ddro.ddr_d_ld_0_ff.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.datx8_dq_8.d_drmux.ddro.ddr_d_ld_0_ff);

            release `DXn_inst.datx8_dq_0.d_drmux.ddro.ddr_d_ld_1_ff.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.datx8_dq_0.d_drmux.ddro.ddr_d_ld_1_ff);
            release `DXn_inst.datx8_dq_1.d_drmux.ddro.ddr_d_ld_1_ff.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.datx8_dq_1.d_drmux.ddro.ddr_d_ld_1_ff);
            release `DXn_inst.datx8_dq_2.d_drmux.ddro.ddr_d_ld_1_ff.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.datx8_dq_2.d_drmux.ddro.ddr_d_ld_1_ff);
            release `DXn_inst.datx8_dq_3.d_drmux.ddro.ddr_d_ld_1_ff.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.datx8_dq_3.d_drmux.ddro.ddr_d_ld_1_ff);
            release `DXn_inst.datx8_dq_4.d_drmux.ddro.ddr_d_ld_1_ff.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.datx8_dq_4.d_drmux.ddro.ddr_d_ld_1_ff);
            release `DXn_inst.datx8_dq_5.d_drmux.ddro.ddr_d_ld_1_ff.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.datx8_dq_5.d_drmux.ddro.ddr_d_ld_1_ff);
            release `DXn_inst.datx8_dq_6.d_drmux.ddro.ddr_d_ld_1_ff.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.datx8_dq_6.d_drmux.ddro.ddr_d_ld_1_ff);
            release `DXn_inst.datx8_dq_7.d_drmux.ddro.ddr_d_ld_1_ff.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.datx8_dq_7.d_drmux.ddro.ddr_d_ld_1_ff);
            release `DXn_inst.datx8_dq_8.d_drmux.ddro.ddr_d_ld_1_ff.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.datx8_dq_8.d_drmux.ddro.ddr_d_ld_1_ff);

            release `DXn_inst.datx8_dq_0.d_drmux.ddro.ddr_d_0_ff.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.datx8_dq_0.d_drmux.ddro.ddr_d_0_ff);
            release `DXn_inst.datx8_dq_1.d_drmux.ddro.ddr_d_0_ff.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.datx8_dq_1.d_drmux.ddro.ddr_d_0_ff);
            release `DXn_inst.datx8_dq_2.d_drmux.ddro.ddr_d_0_ff.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.datx8_dq_2.d_drmux.ddro.ddr_d_0_ff);
            release `DXn_inst.datx8_dq_3.d_drmux.ddro.ddr_d_0_ff.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.datx8_dq_3.d_drmux.ddro.ddr_d_0_ff);
            release `DXn_inst.datx8_dq_4.d_drmux.ddro.ddr_d_0_ff.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.datx8_dq_4.d_drmux.ddro.ddr_d_0_ff);
            release `DXn_inst.datx8_dq_5.d_drmux.ddro.ddr_d_0_ff.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.datx8_dq_5.d_drmux.ddro.ddr_d_0_ff);
            release `DXn_inst.datx8_dq_6.d_drmux.ddro.ddr_d_0_ff.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.datx8_dq_6.d_drmux.ddro.ddr_d_0_ff);
            release `DXn_inst.datx8_dq_7.d_drmux.ddro.ddr_d_0_ff.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.datx8_dq_7.d_drmux.ddro.ddr_d_0_ff);
            release `DXn_inst.datx8_dq_8.d_drmux.ddro.ddr_d_0_ff.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.datx8_dq_8.d_drmux.ddro.ddr_d_0_ff);

            release `DXn_inst.datx8_dq_0.qs_q_ff.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.datx8_dq_0.qs_q_ff);
            release `DXn_inst.datx8_dq_1.qs_q_ff.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.datx8_dq_1.qs_q_ff);
            release `DXn_inst.datx8_dq_2.qs_q_ff.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.datx8_dq_2.qs_q_ff);
            release `DXn_inst.datx8_dq_3.qs_q_ff.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.datx8_dq_3.qs_q_ff);
            release `DXn_inst.datx8_dq_4.qs_q_ff.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.datx8_dq_4.qs_q_ff);
            release `DXn_inst.datx8_dq_5.qs_q_ff.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.datx8_dq_5.qs_q_ff);
            release `DXn_inst.datx8_dq_6.qs_q_ff.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.datx8_dq_6.qs_q_ff);
            release `DXn_inst.datx8_dq_7.qs_q_ff.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.datx8_dq_7.qs_q_ff);
            release `DXn_inst.datx8_dq_8.qs_q_ff.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.datx8_dq_8.qs_q_ff);

`ifdef DWC_DDRPHY_X4X2  
            release `DXn_inst.datx8_dq_9.d_drmux.ddro.ddr_d_ld_0_ff.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.datx8_dq_9.d_drmux.ddro.ddr_d_ld_0_ff);
            release `DXn_inst.datx8_dq_9.d_drmux.ddro.ddr_d_ld_1_ff.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.datx8_dq_9.d_drmux.ddro.ddr_d_ld_1_ff);
            release `DXn_inst.datx8_dq_9.d_drmux.ddro.ddr_d_0_ff.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.datx8_dq_9.d_drmux.ddro.ddr_d_0_ff);
            release `DXn_inst.datx8_dq_9.qs_q_ff.NOTIFIER;
            $enable_warnings("timing",`DXn_inst.datx8_dq_9.qs_q_ff);
`endif

            release `DXn_inst.`DX_DQS0.dqs_gate.qs_gate_status_reg_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS0.dqs_gate.qs_gate_status_reg_1);
            release `DXn_inst.`DX_DQS0.dqs_gate.qs_gate_status_reg_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS0.dqs_gate.qs_gate_status_reg_0);

`ifdef DWC_DDRPHY_X4X2  
            release `DXn_inst.`DX_DQS1.dqs_gate.qs_gate_status_reg_1.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS1.dqs_gate.qs_gate_status_reg_1);
            release `DXn_inst.`DX_DQS1.dqs_gate.qs_gate_status_reg_0.NOTIFIER ;
            $enable_warnings("timing",`DXn_inst.`DX_DQS1.dqs_gate.qs_gate_status_reg_0);

`endif
        end
    end
  endgenerate
  `endif //  `ifdef SDF_ANNOTATE
`endif //  `ifdef DWC_DDRPHY_EMUL_XILINX

`ifdef DWC_DDRPHY_EMUL_XILINX
  `ifdef SDF_ANNOTATE

    // Disable notifiers IDDR and DCU for TRAIN_DQS
    always@(force_emulXV6_notifiers) begin
      //Reset of FF
// 
// // ISERDES 
      force tc.ddr_tb.ddr_chip.u_DWC_DDRPHY_top.u_DWC_DDRPHY_dx_0__u_DWC_DDRPHYDATX8_ITMD_instantiation_0__u_itmd_dq_u_iserdes .notifier = 1'bx;
      force tc.ddr_tb.ddr_chip.u_DWC_DDRPHY_top.u_DWC_DDRPHY_dx_0__u_DWC_DDRPHYDATX8_ITMD_instantiation_1__u_itmd_dq_u_iserdes .notifier = 1'bx;
      force tc.ddr_tb.ddr_chip.u_DWC_DDRPHY_top.u_DWC_DDRPHY_dx_0__u_DWC_DDRPHYDATX8_ITMD_instantiation_2__u_itmd_dq_u_iserdes .notifier = 1'bx;
      force tc.ddr_tb.ddr_chip.u_DWC_DDRPHY_top.u_DWC_DDRPHY_dx_0__u_DWC_DDRPHYDATX8_ITMD_instantiation_3__u_itmd_dq_u_iserdes .notifier = 1'bx;
      force tc.ddr_tb.ddr_chip.u_DWC_DDRPHY_top.u_DWC_DDRPHY_dx_0__u_DWC_DDRPHYDATX8_ITMD_instantiation_4__u_itmd_dq_u_iserdes .notifier = 1'bx;
      force tc.ddr_tb.ddr_chip.u_DWC_DDRPHY_top.u_DWC_DDRPHY_dx_0__u_DWC_DDRPHYDATX8_ITMD_instantiation_5__u_itmd_dq_u_iserdes .notifier = 1'bx;
      force tc.ddr_tb.ddr_chip.u_DWC_DDRPHY_top.u_DWC_DDRPHY_dx_0__u_DWC_DDRPHYDATX8_ITMD_instantiation_6__u_itmd_dq_u_iserdes .notifier = 1'bx;
      force tc.ddr_tb.ddr_chip.u_DWC_DDRPHY_top.u_DWC_DDRPHY_dx_0__u_DWC_DDRPHYDATX8_ITMD_instantiation_7__u_itmd_dq_u_iserdes .notifier = 1'bx;
 // ISERDES
      $disable_warnings("timing", tc.ddr_tb.ddr_chip.u_DWC_DDRPHY_top.u_DWC_DDRPHY_dx_0__u_DWC_DDRPHYDATX8_ITMD_instantiation_0__u_itmd_dq_u_iserdes );
      $disable_warnings("timing", tc.ddr_tb.ddr_chip.u_DWC_DDRPHY_top.u_DWC_DDRPHY_dx_0__u_DWC_DDRPHYDATX8_ITMD_instantiation_1__u_itmd_dq_u_iserdes );
      $disable_warnings("timing", tc.ddr_tb.ddr_chip.u_DWC_DDRPHY_top.u_DWC_DDRPHY_dx_0__u_DWC_DDRPHYDATX8_ITMD_instantiation_2__u_itmd_dq_u_iserdes );
      $disable_warnings("timing", tc.ddr_tb.ddr_chip.u_DWC_DDRPHY_top.u_DWC_DDRPHY_dx_0__u_DWC_DDRPHYDATX8_ITMD_instantiation_3__u_itmd_dq_u_iserdes );
      $disable_warnings("timing", tc.ddr_tb.ddr_chip.u_DWC_DDRPHY_top.u_DWC_DDRPHY_dx_0__u_DWC_DDRPHYDATX8_ITMD_instantiation_4__u_itmd_dq_u_iserdes );
      $disable_warnings("timing", tc.ddr_tb.ddr_chip.u_DWC_DDRPHY_top.u_DWC_DDRPHY_dx_0__u_DWC_DDRPHYDATX8_ITMD_instantiation_5__u_itmd_dq_u_iserdes );
      $disable_warnings("timing", tc.ddr_tb.ddr_chip.u_DWC_DDRPHY_top.u_DWC_DDRPHY_dx_0__u_DWC_DDRPHYDATX8_ITMD_instantiation_6__u_itmd_dq_u_iserdes );
      $disable_warnings("timing", tc.ddr_tb.ddr_chip.u_DWC_DDRPHY_top.u_DWC_DDRPHY_dx_0__u_DWC_DDRPHYDATX8_ITMD_instantiation_7__u_itmd_dq_u_iserdes );
      
    end
    //Release notifiers IDDR and DCU for TRAIN_DQS
    always@(release_emulXV6_notifiers) begin
      //Reset of FF
// // ISERDES 
      release tc.ddr_tb.ddr_chip.u_DWC_DDRPHY_top.u_DWC_DDRPHY_dx_0__u_DWC_DDRPHYDATX8_ITMD_instantiation_0__u_itmd_dq_u_iserdes .notifier ;
      release tc.ddr_tb.ddr_chip.u_DWC_DDRPHY_top.u_DWC_DDRPHY_dx_0__u_DWC_DDRPHYDATX8_ITMD_instantiation_1__u_itmd_dq_u_iserdes .notifier ;
      release tc.ddr_tb.ddr_chip.u_DWC_DDRPHY_top.u_DWC_DDRPHY_dx_0__u_DWC_DDRPHYDATX8_ITMD_instantiation_2__u_itmd_dq_u_iserdes .notifier ;
      release tc.ddr_tb.ddr_chip.u_DWC_DDRPHY_top.u_DWC_DDRPHY_dx_0__u_DWC_DDRPHYDATX8_ITMD_instantiation_3__u_itmd_dq_u_iserdes .notifier ;
      release tc.ddr_tb.ddr_chip.u_DWC_DDRPHY_top.u_DWC_DDRPHY_dx_0__u_DWC_DDRPHYDATX8_ITMD_instantiation_4__u_itmd_dq_u_iserdes .notifier ;
      release tc.ddr_tb.ddr_chip.u_DWC_DDRPHY_top.u_DWC_DDRPHY_dx_0__u_DWC_DDRPHYDATX8_ITMD_instantiation_5__u_itmd_dq_u_iserdes .notifier ;
      release tc.ddr_tb.ddr_chip.u_DWC_DDRPHY_top.u_DWC_DDRPHY_dx_0__u_DWC_DDRPHYDATX8_ITMD_instantiation_6__u_itmd_dq_u_iserdes .notifier ;
      release tc.ddr_tb.ddr_chip.u_DWC_DDRPHY_top.u_DWC_DDRPHY_dx_0__u_DWC_DDRPHYDATX8_ITMD_instantiation_7__u_itmd_dq_u_iserdes .notifier ;
 // ISERDES
      $enable_warnings("timing", tc.ddr_tb.ddr_chip.u_DWC_DDRPHY_top.u_DWC_DDRPHY_dx_0__u_DWC_DDRPHYDATX8_ITMD_instantiation_0__u_itmd_dq_u_iserdes );
      $enable_warnings("timing", tc.ddr_tb.ddr_chip.u_DWC_DDRPHY_top.u_DWC_DDRPHY_dx_0__u_DWC_DDRPHYDATX8_ITMD_instantiation_1__u_itmd_dq_u_iserdes );
      $enable_warnings("timing", tc.ddr_tb.ddr_chip.u_DWC_DDRPHY_top.u_DWC_DDRPHY_dx_0__u_DWC_DDRPHYDATX8_ITMD_instantiation_2__u_itmd_dq_u_iserdes );
      $enable_warnings("timing", tc.ddr_tb.ddr_chip.u_DWC_DDRPHY_top.u_DWC_DDRPHY_dx_0__u_DWC_DDRPHYDATX8_ITMD_instantiation_3__u_itmd_dq_u_iserdes );
      $enable_warnings("timing", tc.ddr_tb.ddr_chip.u_DWC_DDRPHY_top.u_DWC_DDRPHY_dx_0__u_DWC_DDRPHYDATX8_ITMD_instantiation_4__u_itmd_dq_u_iserdes );
      $enable_warnings("timing", tc.ddr_tb.ddr_chip.u_DWC_DDRPHY_top.u_DWC_DDRPHY_dx_0__u_DWC_DDRPHYDATX8_ITMD_instantiation_5__u_itmd_dq_u_iserdes );
      $enable_warnings("timing", tc.ddr_tb.ddr_chip.u_DWC_DDRPHY_top.u_DWC_DDRPHY_dx_0__u_DWC_DDRPHYDATX8_ITMD_instantiation_6__u_itmd_dq_u_iserdes );
      $enable_warnings("timing", tc.ddr_tb.ddr_chip.u_DWC_DDRPHY_top.u_DWC_DDRPHY_dx_0__u_DWC_DDRPHYDATX8_ITMD_instantiation_7__u_itmd_dq_u_iserdes );
    end

  `endif // SDF_ANNOTATE
`endif // DWC_DDRPHY_EMUL_XILINX
         
task compute_code_variation;
input [27:0] exptd_zctrl;
input [27:0] actual_zctrl;
reg  [27:0] diff; 

begin
	diff[6:0] = actual_zctrl[6:0] >= exptd_zctrl[6:0] ? actual_zctrl[6:0]-exptd_zctrl[6:0] : exptd_zctrl[6:0]-actual_zctrl[6:0];
	diff[13:7] = actual_zctrl[13:7] >= exptd_zctrl[13:7] ? actual_zctrl[13:7]-exptd_zctrl[13:7] : exptd_zctrl[13:7]-actual_zctrl[13:7];
	diff[20:14] = actual_zctrl[20:14] >= exptd_zctrl[20:14] ? actual_zctrl[20:14]-exptd_zctrl[20:14] : exptd_zctrl[20:14]-actual_zctrl[20:14];
	diff[27:21] = actual_zctrl[27:21] >= exptd_zctrl[27:21] ? actual_zctrl[27:21]-exptd_zctrl[27:21] : exptd_zctrl[27:21]-actual_zctrl[27:21];
	$display("-> %0t: [MSV] zctrl_DRVPD_diff:%h\tAZCTRL:%h\tEZCTRL:%h",$time,diff[6:0],actual_zctrl[6:0],exptd_zctrl[6:0]);
        $display("-> %0t: [MSV] zctrl_DRVPU_diff:%h\tAZCTRL:%h\tEZCTRL:%h",$time,diff[13:7],actual_zctrl[13:7],exptd_zctrl[13:7]);
        $display("-> %0t: [MSV] zctrl_ODTPD_diff:%h\tAZCTRL:%h\tEZCTRL:%h",$time,diff[20:14],actual_zctrl[20:14],exptd_zctrl[20:14]);
        $display("-> %0t: [MSV] zctrl_ODTPU_diff:%h\tAZCTRL:%h\tEZCTRL:%h",$time,diff[27:21],actual_zctrl[27:21],exptd_zctrl[27:21]);
end
endtask

task force_zcal_update; 
    begin
        `GRM.zqcr[27] = 1'b1;
         $display("-> %0t: ==== force zcal update ===========",$time);
        `CFG.write_register(`ZQCR, `GRM.zqcr);
        repeat (5) @(posedge `CFG.clk);
        `GRM.zqcr[27] = 1'b0;
         $display("-> %0t: ==== de-assert zcal update =======",$time);
        `CFG.write_register(`ZQCR, `GRM.zqcr);
    end
endtask

`ifndef DWC_DDRPHY_EMUL_XILINX
  task force_zcomp;
    input zcomp;
      begin
`ifndef DWC_DDRPHY_NO_PZQ          
          force `ZCAL_FSM.zcomp = zcomp;
`endif          
          force_zcomp_status = zcomp;
      end
  endtask

  task release_zcomp;
      begin
`ifndef DWC_DDRPHY_NO_PZQ          
          release `ZCAL_FSM.zcomp;
`endif          
          force_zcomp_status = 1'b0;
      end
  endtask
`endif


// will move it to the begining later
// Results of each traing

  reg [7:0] mrep_result[`DWC_NO_OF_RANKS-1:0][pNUM_LANES-1:0];    
  reg       mrd_find_right_edge[`DWC_NO_OF_BYTES-1 :0]; 
  reg       mrd_find_left_edge[`DWC_NO_OF_BYTES-1: 0];     
  reg       mwd_find_right_edge[`DWC_NO_OF_BYTES-1 :0]; 
  reg       mwd_find_left_edge[`DWC_NO_OF_BYTES-1 :0];
  reg[7:0]  mrd_phase_result[`DWC_NO_OF_RANKS-1:0][pNUM_LANES-1:0]; 
  integer   mrd_cycle_result[`DWC_NO_OF_RANKS-1:0][pNUM_LANES-1:0];   
  reg[7:0]  mwd_phase_result[`DWC_NO_OF_RANKS-1:0][pNUM_LANES-1:0]; 
  integer   mwd_cycle_result[`DWC_NO_OF_RANKS-1:0][pNUM_LANES-1:0];   
  reg[`DWC_NO_OF_BYTES-1:0]     mrd_byte_done; 
  reg[`DWC_NO_OF_BYTES-1:0]     mwd_byte_done;
  reg[7:0] dwl_result[`DWC_NO_OF_RANKS][pNUM_LANES-1:0];  
//get delay for hir training and write leveling adjustment
  event     get_lrdimm_rd_delay;
  event     get_lrdimm_wr_delay;
  integer   sdram_width;
//Flag for each training
  reg       mrep_train = 1'b0;
  reg       dwl_train = 1'b0;
  reg       mrd_train = 1'b0;   
  reg       hwl_train = 1'b0;
  reg       mwd_train = 1'b0;
  reg       hir_train = 1'b0;  
  reg [31:0] reg_word;
  reg        rank_disable[`DWC_NO_OF_RANKS-1 : 0];
  reg        rdimm_addr_inv = `TRUE;
  initial begin
  `ifdef SDRAMx4
    sdram_width = 4;
  `endif
  `ifdef SDRAMx8
    sdram_width = 8;
  `endif
  `ifdef SDRAMx16
    sdram_width = 16;
  `endif
  `ifdef SDRAMx32
    sdram_width = 32;
  `endif

end


//============================================================================================
// send_bcw_read_cmd() - Sends BCW READ commands
//============================================================================================
task send_bcw_read_cmd;
  input reg [2:0] func_space;
  input reg [`SDRAM_RANK_WIDTH:0] rank;
  input int cw_bits;
  input reg [3:0] cw_n;
  
  reg [`CMD_WIDTH-1 :0] dcu_command;   
  reg [`SDRAM_RANK_WIDTH-1:0] device_rank;
  reg [`SDRAM_BANK_WIDTH-1:0] bank;
  reg [12  :0] addr;
  reg [`DCU_RPT_WIDTH-1 :0] dcu_rpt;
  reg [`DCU_DTP_WIDTH-1 :0] dcu_dtp;
  reg [`DCU_TAG_WIDTH-1 :0] dcu_tag;
  reg [`PUB_DQS_WIDTH-1 :0] mask={`PUB_DQS_WIDTH{`DDR_MASK_OFF}};
  reg [`DCU_DATA_WIDTH- 1 :0] data=`PUB_DATA_0000_0000;
  

  reg terminate = `FALSE;
  
  if(`DWC_RCD_MODE == `DIRECT_DUAL_CS) begin
    device_rank = rank - rank%2;
  end else if(`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS) begin
    device_rank = rank - rank%4;
  end
  
  dcu_command     = `LOAD_MODE;
  dcu_dtp         = `DTP_tMOD;
  dcu_tag         = `DCU_NOTAG;
  dcu_rpt         = `DCU_NORPT;
  bank            = 7;
  addr            = {1'h0, 4'h4, func_space, 1'h1, cw_n};//13'h0490;    
  `CFG.load_dcu_command(dcu_rpt, dcu_dtp, dcu_tag, dcu_command, device_rank, bank, addr, mask, data);
  
  dcu_command     = `LOAD_MODE;
  dcu_dtp         = `DTP_tMOD;
  dcu_tag         = `DCU_NOTAG;
  dcu_rpt         = `DCU_NORPT;
  bank            = 7;
  addr            = {1'h0, 4'h5, 8'h0};//13'h0500;    
  `CFG.load_dcu_command(dcu_rpt, dcu_dtp, dcu_tag, dcu_command, device_rank, bank, addr, mask, data);
  
  
  dcu_command     = `LOAD_MODE;
  dcu_dtp         = `DTP_tMOD;
  dcu_tag         = `DCU_NOTAG;
  dcu_rpt         = `DCU_NORPT;
  bank            = 7;
  addr            = {1'h0, 4'h6,8'h0};//13'h0600;    
  `CFG.load_dcu_command(dcu_rpt, dcu_dtp, dcu_tag, dcu_command, device_rank, bank, addr, mask, data);
  
  dcu_command     = `LOAD_MODE;
  dcu_dtp         = `DTP_tMOD;
  dcu_tag         = `DCU_NOTAG;
  dcu_rpt         = `DCU_NORPT;
  bank            = 7;
  addr            = 13'h0064;    
  `CFG.load_dcu_command(dcu_rpt, dcu_dtp, dcu_tag, dcu_command, device_rank, bank, addr, mask, data);
    
  dcu_command     = `SDRAM_READ;
  dcu_dtp         = `DTP_tRDAP2ACT;
  dcu_tag         = `DCU_NOTAG;
  dcu_rpt         = `DCU_NORPT;
  bank            = 7;
  addr            = 13'h1000;   
  `CFG.load_dcu_command(dcu_rpt, dcu_dtp, dcu_tag, dcu_command, device_rank, bank, addr, mask, data);
  
  dcu_command     = `LOAD_MODE;
  dcu_dtp         = `DTP_tMOD;
  dcu_tag         = `DCU_NOTAG;
  dcu_rpt         = `DCU_NORPT;
  bank            = 7;
  addr            = 13'h0065;    
  `CFG.load_dcu_command(dcu_rpt, dcu_dtp, dcu_tag, dcu_command, device_rank, bank, addr, mask, data);

  run_dcu_command(5); 

endtask 

//============================================================================================
// select_func_space() - Selects the Function Space for BCW commands - LRDIMM
//============================================================================================
task select_func_space;
  input reg [3:0] func_space;
  input reg [`SDRAM_RANK_WIDTH:0] rank;
  input reg [`DCU_DTP_WIDTH-1 :0] dcu_dtp;
  
  reg [`CMD_WIDTH-1 :0] dcu_command;   
  reg [`SDRAM_RANK_WIDTH-1:0] device_rank;
  reg [`SDRAM_BANK_WIDTH-1:0] bank;
  //reg [`DWC_PHY_ADDR_WIDTH-1  :0] addr;
  reg [12:0] addr;
  reg [`DCU_RPT_WIDTH-1 :0] dcu_rpt;
  reg [`DCU_TAG_WIDTH-1 :0] dcu_tag;
  reg [`PUB_DQS_WIDTH    - 1 : 0] mask={`PUB_DQS_WIDTH{`DDR_MASK_OFF}};
  reg [`DCU_DATA_WIDTH- 1 :0] data=`PUB_DATA_0000_0000;
  reg [3:0] dcu_special_cmd;
  if(`DWC_RCD_MODE == `DIRECT_DUAL_CS) begin
    device_rank = rank - rank%2;
  end else if(`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS) begin
    device_rank = rank - rank%4;
  end  
 
  //Select Func Space  
  dcu_command     = `LOAD_MODE;
  dcu_tag         = `DCU_NOTAG;
  dcu_rpt         = `DCU_NORPT;
  bank            = 7;
  //dcu_special_cmd = `RDIMMBCW;
  addr            = {9'h170 ,func_space};
  //addr            = {1'b1,func_space,5'h16,dcu_special_cmd};    
  `CFG.load_dcu_command(dcu_rpt, dcu_dtp, dcu_tag, dcu_command, device_rank, bank, addr, mask, data);
  run_dcu_command(0);

endtask 


//============================================================================================
// load_db_dq_register_8bit() - Load the value on HOST interface for DQ - LRDIMM training
//============================================================================================
task load_db_dq_register_8bit ;
  input reg [3:0] register;
  input reg [7:0] data;
  input reg [`SDRAM_RANK_WIDTH:0] rank;
  input reg [`DCU_DTP_WIDTH-1 :0] dcu_dtp;

  reg [`CMD_WIDTH-1 :0] dcu_command;   
  reg [`SDRAM_RANK_WIDTH-1:0] device_rank;
  reg [`SDRAM_BANK_WIDTH-1:0] bank;
  reg [12  :0] addr;
  reg [`DCU_RPT_WIDTH-1 :0] dcu_rpt;
  reg [`DCU_TAG_WIDTH-1 :0] dcu_tag;
  reg [`PUB_DQS_WIDTH    - 1 : 0] mask={`PUB_DQS_WIDTH{`DDR_MASK_OFF}};
  reg [`DCU_DATA_WIDTH- 1 :0] dcu_data=`PUB_DATA_0000_0000;
  
  
  if(`DWC_RCD_MODE == `DIRECT_DUAL_CS) begin
    device_rank = rank - rank%2;
  end else if(`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS) begin
    device_rank = rank - rank%4;
  end    
  
  dcu_command     = `LOAD_MODE;
  dcu_tag         = `DCU_NOTAG;
  dcu_rpt         = `DCU_NORPT;
  bank            = 7;
  addr            = {1'b1,register,data};    
  `CFG.load_dcu_command(dcu_rpt, dcu_dtp, dcu_tag, dcu_command, device_rank, bank, addr, mask, data);
  run_dcu_command(0);

endtask

//============================================================================================
// load_db_dq_register_4bit() - Load the value on HOST interface for DQ - LRDIMM training
//============================================================================================
task load_db_dq_register_4bit;
  input reg [7:0] register;
  input reg [3:0] data;
  input reg [`SDRAM_RANK_WIDTH:0] rank;
  input reg [`DCU_DTP_WIDTH-1 :0] dcu_dtp;

  reg [`CMD_WIDTH-1 :0] dcu_command;   
  reg [`SDRAM_RANK_WIDTH-1:0] device_rank;
  reg [`SDRAM_BANK_WIDTH-1:0] bank;
  reg [12  :0] addr;
  reg [`DCU_RPT_WIDTH-1 :0] dcu_rpt;
  reg [`DCU_TAG_WIDTH-1 :0] dcu_tag;
  reg [`PUB_DQS_WIDTH-1 :0] mask={`PUB_DQS_WIDTH{`DDR_MASK_OFF}};
  reg [`DCU_DATA_WIDTH-1 :0] dcu_data=`PUB_DATA_0000_0000;
  
  if(`DWC_RCD_MODE == `DIRECT_DUAL_CS) begin
    device_rank = rank - rank%2;
  end else if(`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS) begin
    device_rank = rank - rank%4;
  end      
  
  dcu_command     = `LOAD_MODE;
  dcu_tag         = `DCU_NOTAG;
  dcu_rpt         = `DCU_NORPT;
  bank            = 7;
  addr            = {1'b1,register,data};
  `CFG.load_dcu_command(dcu_rpt, dcu_dtp, dcu_tag, dcu_command, device_rank, bank, addr, mask, data);
  run_dcu_command(0);


endtask
//============================================================================================
// do_lrdimm_training() - Runs LRDIMM training
//============================================================================================
task do_lrdimm_training;
  reg [`CMD_WIDTH-1 :0] dcu_command;   
  reg [`SDRAM_RANK_WIDTH-1:0] rank;
  integer rank_no;
  reg [`DWC_PHY_BG_WIDTH + `DWC_PHY_BA_WIDTH  -1:0] bank;
  reg [12  :0] addr;
  reg [`DCU_RPT_WIDTH-1 :0] dcu_rpt;
  reg [`DCU_DTP_WIDTH-1 :0] dcu_dtp;
  reg [`DCU_TAG_WIDTH-1 :0] dcu_tag;
  reg [`DCU_DATA_WIDTH   - 1 : 0] data=`PUB_DATA_0000_0000;
  reg [`PUB_DQS_WIDTH    - 1 : 0] mask={`PUB_DQS_WIDTH{`DDR_MASK_OFF}};
  reg [`REG_DATA_WIDTH-1 :0] reg_value;
  integer i;
  integer j;

  $display("-> %0t: [BENCH] Starting LRDIMM Software Training ", $time);
  `CFG.dcu_reset;
  `CFG.read_register_data(`PGCR2, reg_word);
    if (reg_word[18] == 1) begin  //csncidmux
      for(i=0;i<`DWC_NO_OF_RANKS;i++) begin
        if (i % 4 == 0) 
          rank_disable[i] = `FALSE;
        else 
          rank_disable[i] = `TRUE;
      end
    end
    else begin
      for(i=0;i<`DWC_NO_OF_RANKS;i++) 
          rank_disable[i] = `FALSE;
    end 

  `CFG.set_dcu_cache_access(`DCU_CCACHE, 1, 0, 0, 0);
  //==============================================
  // Disable the monitor's pub_training mode
  //==============================================
  `ifndef BL_8 
    for(rank_no=0; rank_no < `DWC_NO_OF_RANKS; rank_no = rank_no +1) begin
      rank = rank_no;
      //Set DRAM BL8
      dcu_command     = `LOAD_MODE;
      dcu_dtp         = `DTP_tMOD;
      dcu_tag         = `DCU_NOTAG;
      dcu_rpt         = `DCU_NORPT;
      bank            = 0;
      `CFG.read_register_data(`MR0_REG, reg_value);
      addr            = reg_value;      //regs.get_value("MR0");
      addr[1:0]       = 2'b00;
      `CFG.load_dcu_command(dcu_rpt, dcu_dtp, dcu_tag, dcu_command, rank, bank, addr, mask, data);

      //Set DRAM BL8
      dcu_command     = `LOAD_MODE;
      dcu_dtp         = `DTP_tMOD;
      dcu_tag         = `DCU_NOTAG;
      dcu_rpt         = `DCU_NORPT;
      bank            = 8;
      addr            = reg_value;      //regs.get_value("MR0");
      addr[1:0]       = 2'b00;
      `CFG.load_dcu_command(dcu_rpt, dcu_dtp, dcu_tag, dcu_command, rank, bank, addr, mask, data);
      run_dcu_command(1);
    end
  `endif
  `GRM.pgcr1[20]=1'b1;   //PGCR1.LRDIMMST Set LRDIMM Software Training
  `CFG.write_register(`PGCR1,`GRM.pgcr1);
  
  for (j=0; j<`DWC_NO_OF_BYTES; j=j+1) begin
    `GRM.dxngcr1[j][31:16] = 16'haaaa;  //DXPDRMODE
    `GRM.dxngcr2[j][15:0] = 16'h5555;   //DXTEMODE
    `CFG.write_register(`DX0GCR1 + ( j * `DX_REG_RANGE), `GRM.dxngcr1[j]);    
    `CFG.write_register(`DX0GCR2 + ( j * `DX_REG_RANGE), `GRM.dxngcr2[j]);    
  end   
  
    
  $display("-> %0t: [BENCH] Performing LRDIMM MREP Training ", $time);
  do_mrep_training();
  $display("-> %0t: [BENCH] Performing LRDIMM DWL Training ", $time);
  do_dwl_training();  
  $display("-> %0t: [BENCH] Performing LRDIMM HWL Training ", $time);
  do_hwl_training(); 
  $display("-> %0t: [BENCH] Performing LRDIMM MRD Training  ", $time);
  do_mrd_training();       
  $display("-> %0t: [BENCH] Performing LRDIMM MWD Training ", $time);
  do_mwd_training();   
 
  for (j=0; j<`DWC_NO_OF_BYTES; j=j+1) begin
    `CFG.read_register_data(`DX0GCR1 + ( j * `DX_REG_RANGE), reg_value);
    if(reg_value[0] == 0) begin        //DXnGCR.DXEN
      `GRM.dxngcr1[j][31:16] = 16'h5555;  //DXPDRMODE
      `GRM.dxngcr2[j][15:0] = 16'haaaa;   //DXTEMODE
    end else begin
      `GRM.dxngcr1[j][31:16] = 16'h0000;
      `GRM.dxngcr2[j][15:0] = 16'h0000;
    end
    `CFG.write_register(`DX0GCR1 + ( j * `DX_REG_RANGE), `GRM.dxngcr1[j]);    
    `CFG.write_register(`DX0GCR2 + ( j * `DX_REG_RANGE), `GRM.dxngcr2[j]);    
  end
  `GRM.pgcr1[20]=1'b0;   //PGCR1.LRDIMMST Disable LRDIMM Software Training
  `CFG.write_register(`PGCR1,`GRM.pgcr1); 
 
   

  $display("-> %0t: [BENCH] Performing LRDIMM HIR Training ", $time);
  do_hir_training(); 
  
  
  
  write_level_adjust(`DWC_NO_OF_RANKS);
    
  
      
  `ifndef BL_8 
    //for(rank=0; rank < `DWC_NO_OF_RANKS; rank++) begin    
    for(rank_no=0; rank_no < `DWC_NO_OF_RANKS; rank_no = rank_no +1) begin
      //Set DRAM MPR Side A
      rank = rank_no;
      dcu_command     = `LOAD_MODE;
      dcu_dtp         = `DTP_tMOD;
      dcu_tag         = `DCU_NOTAG;
      dcu_rpt         = `DCU_NORPT;
      bank            = 0;
      `CFG.read_register_data(`MR0_REG, reg_value);
      addr            = reg_value;      //MR0;
      `CFG.load_dcu_command(dcu_rpt, dcu_dtp, dcu_tag, dcu_command, rank, bank, addr, mask, data);

      //Set DRAM MPR Side B
      dcu_command     = `LOAD_MODE;
      dcu_dtp         = `DTP_tMOD;
      dcu_tag         = `DCU_NOTAG;
      dcu_rpt         = `DCU_NORPT;
      bank            = 8;
      addr            = reg_value;      //"MR0"
      `CFG.load_dcu_command(dcu_rpt, dcu_dtp, dcu_tag, dcu_command, rank, bank, addr, mask, data);
      run_dcu_command(1);
  end
  `endif    
      
 
      
endtask



//============================================================================================
// run_dcu_command() - Run specified number of commands
//===========================================================================================
task run_dcu_command;
  input integer end_addr;
  begin
  `CFG.dcu_run_special(0, end_addr, 0, 0, 0, 1, 1);
  // wait for the DCU commands run to be finished
  `ifdef SDF_ANNOTATE
     `CFG.polling_dcusr0_rdone();
  `elsif GATE_LEVEL_SIM
     `CFG.polling_dcusr0_rdone();
  `else
     @(posedge `PUB.dcu_done);
  `endif

  `CFG.dcu_reset;
  `CFG.ccache_loaded   = 0;
  `CFG.ccache_end_addr = 0;
  `CFG.set_dcu_cache_access(`DCU_CCACHE, 1, 0, 0, 0);
  end
endtask

//============================================================================================
// send_command_schcr() - Load the commands to register schcr0&1
//============================================================================================
task send_command_schcr;
  input reg [3:0] schcr0_schtrig;
  input reg [3:0] schcr0_cmd;
  input reg [3:0] schcr0_sp_cmd;
  input reg [17:0] schcr0_schdqv; 
  input reg schcr1_all_rank;                                        
  input reg [1:0] schcr1_scbk; 
  input reg [1:0] schcr1_scbg;
  input reg [19:0] schcr1_scaddr;
  input reg [3:0] schcr1_scrnk;

  `GRM.schcr1 = {schcr1_scrnk,schcr1_scaddr , schcr1_scbg,schcr1_scbk , 1'b0,schcr1_all_rank , 2'b00} ;
  `CFG.write_register(`SCHCR1, `GRM.schcr1);
        
  `GRM.schcr0  = { schcr0_schdqv, 2'b0, 4'b0,schcr0_cmd,schcr0_schtrig} ;
  `CFG.write_register(`SCHCR0, `GRM.schcr0);

  repeat(`DTP_tMOD) @(posedge `SYS.clk);
 
  repeat ((`DTP_tDLLK)/2) @(posedge `SYS.clk);
 
  repeat(100) @(posedge `SYS.clk);
 
 
  $display("-> %0t: [BENCH] Wait ! ", $time);



endtask




//============================================================================================
// do_mrep_training() - Runs LRDIMM MREP training
//============================================================================================
task do_mrep_training;
  reg [`CMD_WIDTH-1 :0] dcu_command;   
  reg [`SDRAM_RANK_WIDTH-1:0] rank;
  reg [`SDRAM_RANK_WIDTH-1:0] device_rank;
  integer rank_no;
  reg [`DWC_PHY_BG_WIDTH + `DWC_PHY_BA_WIDTH  -1:0] bank;
  reg [12  :0] addr;
  reg [`DCU_RPT_WIDTH-1 :0] dcu_rpt;
  reg [`DCU_DTP_WIDTH-1 :0] dcu_dtp;
  reg [`DCU_TAG_WIDTH-1 :0] dcu_tag;
  reg [`PUB_DQS_WIDTH-1 :0] mask={`PUB_DQS_WIDTH{`DDR_MASK_OFF}};
  reg [`DCU_DATA_WIDTH-1:0] data=`PUB_DATA_0000_0000;
  reg [`REG_DATA_WIDTH-1 :0] reg_value;
  reg [`REG_DATA_WIDTH-1 :0] reg_value_1;

  
  reg [`DWC_NO_OF_BYTES -1:0] dq_captured    = 0;
  reg [`DWC_NO_OF_BYTES -1:0] dq_captured_x4 = 0;
  reg [31:0] read_data;
  reg [`DWC_NO_OF_BYTES -1:0] previous_dq    = 0;
  reg [`DWC_NO_OF_BYTES -1:0] previous_dq_x4 = 0;  
  reg [3:0] rank_en = 4'hf;
  reg terminate = `FALSE;
  integer i;  
  integer j;  
  reg [3:0] temp;

  mrep_train = 1'b1;
  begin
  //for(rank=0; rank < `DWC_NO_OF_RANKS; rank = rank +1 ) begin
  for(rank_no=0; rank_no < `DWC_NO_OF_RANKS; rank_no = rank_no +1 ) begin
    rank = rank_no;
    $display("-> %0t: [BENCH] Rank %0d ! ", $time, rank);
 
 
    if(rank_disable[rank] == `FALSE) begin
      terminate = `FALSE;
      rank_en = 4'hf;
      if(`DWC_RCD_MODE == `DIRECT_DUAL_CS) begin
        rank_en[rank%2] = 1'h0;
      end else if(`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS) begin
        rank_en[rank%4] = 1'h0;
      end          
      previous_dq = 0;
      dq_captured = 0;

      // Set DRAM MPR Side A
      dcu_command     = `LOAD_MODE;
      dcu_dtp         = `DTP_tMOD;
      dcu_tag         = `DCU_NOTAG;
      dcu_rpt         = `DCU_NORPT;
      bank            = 3;
      `CFG.read_register_data(`MR3_REG, reg_value);
      addr            = reg_value;  //MR3_RNK0
      addr[2]         = 1'b1;
      `CFG.load_dcu_command(dcu_rpt, dcu_dtp, dcu_tag, dcu_command, rank, bank, addr, mask, data);
        
      // Set DRAM MPR Side B
      dcu_command     = `LOAD_MODE;
      dcu_dtp         = `DTP_tMOD;
      dcu_tag         = `DCU_NOTAG;
      dcu_rpt         = `DCU_NORPT;
      bank            = 11;
      addr            = reg_value;  //MR3_RNK0
      addr[2]         = 1'b1;
      `CFG.load_dcu_command(dcu_rpt, dcu_dtp, dcu_tag, dcu_command, rank, bank, addr, mask, data);

      // Set Dram Read Preamble Training Side A
      dcu_command     = `LOAD_MODE;
      dcu_dtp         = `DTP_tMOD;
      dcu_tag         = `DCU_NOTAG;
      dcu_rpt         = `DCU_NORPT;
      bank            = 4;
      `CFG.read_register_data(`MR4_REG, reg_value);
      addr            = reg_value;  //MR4
      addr[10]        = 1'b1;
      `CFG.load_dcu_command(dcu_rpt, dcu_dtp, dcu_tag, dcu_command, rank, bank, addr, mask, data);

      // Set Dram Read Preamble Training Side B
      dcu_command     = `LOAD_MODE;
      dcu_dtp         = `DTP_tMOD;
      dcu_tag         = `DCU_NOTAG;
      dcu_rpt         = `DCU_NORPT;
      bank            = 12;
      addr            = reg_value;  //MR4
      addr[10]        = 1'b1;
      `CFG.load_dcu_command(dcu_rpt, dcu_dtp, dcu_tag, dcu_command, rank, bank, addr, mask, data);
      run_dcu_command(3);



      // Set Rank 0 only for Data Buffer 
      // Select Func Space 0

      select_func_space(0, rank, `DTP_tMOD);
      // Write Buffer Register F0BC07=0xe  (Set enable for Rank 0 only)
      load_db_dq_register_4bit(8'h07,rank_en, rank, `DTP_tMOD);  

      if(rank%2==0 && `DWC_RCD_MODE == `DIRECT_DUAL_CS || ( rank%4==0 && (`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS)) )
        // Write Buffer Register F0BC0C=0x1 (Start MREP) 
        load_db_dq_register_4bit(8'h0c,4'h1, rank,  `DTP_tMOD);
        
      if(`DWC_RCD_MODE == `DIRECT_DUAL_CS) begin
        select_func_space(rank%2, rank,  `DTP_tMOD); 
      end else if(`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS) begin
        select_func_space(rank%4, rank,  `DTP_tMOD); 
      end 

      // Execute MREP Search
      for (i=0; i < 64; i=i+1) begin 
        $display("-> %0t: [BENCH] Search %0d ! ", $time, i);
        $display("-> %0t: [BENCH] SDRAM WIDTH:  %0d ! ", $time, sdram_width);
        // Write Buffer Register F0BC2x=i  
        load_db_dq_register_8bit(4'h2,i, rank, `DTP_tMOD);   

        // Write Buffer Register F0BC3x=i   
        load_db_dq_register_8bit(4'h3,i, rank, `DTP_tMOD); 


        //`CFG.read_register_data(`DTAR0, reg_value);
        //`CFG.read_register_data(`DTAR1, reg_value_1);
        
        // Send Read Command   
        dcu_command     = `SDRAM_READ;
        dcu_dtp         = `DTP_tRDAP2ACT;
        dcu_tag         = `DCU_NOTAG;
        dcu_rpt         = `DCU_tBL;
        `CFG.read_register_data(`DTAR0, reg_value);
        bank            = reg_value[27:24];  //DTAR0.DTBGBK1
        `CFG.read_register_data(`DTAR1, reg_value);
        addr            = {reg_value[8:0], 3'b000}; //DTAR1.DTCOL0 
        `CFG.load_dcu_command(dcu_rpt, dcu_dtp, dcu_tag, dcu_command, rank, bank, addr, mask, data);
        run_dcu_command(0);

        repeat (30) @(posedge `SYS.clk); //Wait some clocks to get data on DXNGSR2.DBDQ
        previous_dq    = dq_captured;
        previous_dq_x4 = dq_captured_x4;
        
        for (j=0; j<`DWC_NO_OF_BYTES; j=j+1) begin
          `CFG.read_register_data(`DSGCR, reg_value);  //DSGCR.BDISEN
          `CFG.read_register_data(`DX0GCR0 + ( j * `DX_REG_RANGE), reg_value_1);  //DXnGCR0.DXEN
         //if(!((tb_cfg.dfi_byte_disable[i] == TRUE && reg_value[1] == 1)  || reg_value_1[0] == 0)) begin
         //if(!((reg_value[1] == 1)  || reg_value_1[0] == 0)) begin
          if(!( reg_value_1[0] == 0)) begin
            $display("-> %0t: [BENCH] Enabled ", $time);
            `CFG.disable_read_compare;
            `CFG.read_register_data(`DX0GSR2 + ( j * `DX_REG_RANGE), read_data);
            dq_captured[j] = read_data[12]; 
            if(sdram_width == 4) begin
              dq_captured_x4[j] = read_data[16];
              if(previous_dq[j] == 1 && dq_captured[j] == 0)
                mrep_result[rank][j*2] = i;  
              if(previous_dq_x4[j] == 1 && dq_captured_x4[j] == 0)
                mrep_result[rank][j*2+1] = i;                             
            end else begin
              if(previous_dq[j] == 1 && dq_captured[j] == 0)
                mrep_result[rank][j] = i;
            end
          end else begin
            if(terminate == `TRUE)
              dq_captured[j] = 0;
            else
              dq_captured[j] = 1;
            previous_dq[j] = dq_captured[j];
            if(sdram_width == 4) begin
              if(terminate == `TRUE)
                dq_captured_x4[j] = 0;
              else
                dq_captured_x4[j] = 1;
              previous_dq_x4[j] = dq_captured_x4[j]; 
            end   
          end       
        end

        if(&previous_dq != 0 && (sdram_width != 4 || (&previous_dq_x4 != 0 && sdram_width == 4)))
          terminate = `TRUE;

        if((|previous_dq != 0  && dq_captured == 0) && (sdram_width != 4 || (|previous_dq_x4 != 0  && dq_captured_x4 == 0)) && terminate == `TRUE)
          break;

        $display("-> %0t: [BENCH] Loop %0d ! ", $time, i);
      end 

      if(terminate != `TRUE)
        $display("-> %0t: [BENCH] Could not find phase on MREP for rank %0d ! ", $time, rank);

      $display("-> %0t: [BENCH]  Find phase on MREP for rank %0d ! ", $time, rank);
      // Disable Dram Read Preamble Training Side A
      dcu_command     = `LOAD_MODE;
      dcu_dtp         = `DTP_tMOD;
      dcu_tag         = `DCU_NOTAG;
      dcu_rpt         = `DCU_NORPT;
      bank            = 4;
      `CFG.read_register_data(`MR4_REG, reg_value);  //MR4
      addr            = reg_value;
      addr[10]        = 1'b0;
      `CFG.load_dcu_command(dcu_rpt, dcu_dtp, dcu_tag, dcu_command, rank, bank, addr, mask, data);

      // Disable Dram Read Preamble Training Side B
      dcu_command     = `LOAD_MODE;
      dcu_dtp         = `DTP_tMOD;
      dcu_tag         = `DCU_NOTAG;
      dcu_rpt         = `DCU_NORPT;
      bank            = 12;
      addr            = reg_value;
      addr[10]        = 1'b0;
      `CFG.load_dcu_command(dcu_rpt, dcu_dtp, dcu_tag, dcu_command, rank, bank, addr, mask, data);

      // Disable DRAM MPR Side A
      dcu_command     = `LOAD_MODE;
      dcu_dtp         = `DTP_tMOD;
      dcu_tag         = `DCU_NOTAG;
      dcu_rpt         = `DCU_NORPT;
      bank            = 3;
      `CFG.read_register_data(`MR3_REG, reg_value);  //MR3
      addr            = reg_value;
      addr[2]         = 1'b0;
      `CFG.load_dcu_command(dcu_rpt, dcu_dtp, dcu_tag, dcu_command, rank, bank, addr, mask, data);

      // Disable DRAM MPR Side B
      dcu_command     = `LOAD_MODE;
      dcu_dtp         = `DTP_tMOD;
      dcu_tag         = `DCU_NOTAG;
      dcu_rpt         = `DCU_NORPT;
      bank            = 11;
      addr            = reg_value;
      addr[2]         = 1'b0;
      `CFG.load_dcu_command(dcu_rpt, dcu_dtp, dcu_tag, dcu_command, rank, bank, addr, mask, data);
    
      run_dcu_command(3);

    end

    // Select Func Space 0
    select_func_space(0, rank, `DTP_tMOD);  

    if(rank%2==1 && `DWC_RCD_MODE == `DIRECT_DUAL_CS || ( rank%4==3 && (`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS)) )
      // Write Buffer Register F0BC0C=0x0 (Exit MREP)   
      load_db_dq_register_4bit(8'h0c,4'h0, rank, `DTP_tMOD);        

    // Write Buffer Register F0BC07=0xf  (Enable all ranks)
    load_db_dq_register_4bit(8'h07,4'h0, rank, `DTP_tMOD);    
  end

  // Write the training result through PBA&PDA Mode
  // sending the commands through scheduler from now on
    // Set the chip to PUB mode
  `CFG.read_register_data(`PGCR1, reg_value);  //PUB Mode
  reg_value[6] =1;
  `CFG.write_register(`PGCR1, reg_value);
  repeat(100) @(posedge `SYS.clk);

  for(rank_no =0; rank_no < `DWC_NO_OF_RANKS; rank_no = rank_no +1) begin    

    rank = rank_no;
    $display("rank = %d", rank);

   
    if(`DWC_RCD_MODE == `DIRECT_DUAL_CS) begin
      device_rank = rank - rank%2;
    end else if(`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS) begin
      device_rank = rank - rank%4;
    end  


  
    
    `CFG.read_register_data(`MR3_REG, reg_value);

    if(rank_disable[rank] == `FALSE) begin

      //Write MREP values
      if(`DWC_NO_OF_BYTES > 1 && (rank%2==0 && `DWC_RCD_MODE == `DIRECT_DUAL_CS || (rank%4==0 && (`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS)))) begin
      //if(`DWC_NO_OF_BYTES > 1 ) begin
        
        $display("Rank%d : Put the DRAM into PDA mode - MR3 A4=1 - Side A", device_rank);
        send_command_schcr(4'h1, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b00, {reg_value[20:5], 1'b1, reg_value[3:0]}, device_rank);

        $display("Rank%d : Put the DRAM into PDA mode - MR3 A4=1 - Side B", rank);
        send_command_schcr(4'h1, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b10, {reg_value[20:5], 1'b1, reg_value[3:0]}, device_rank);

        $display("Rank%d : Put the DB into PBA mode - F0BC1x with DA0=1", rank);
        send_command_schcr(4'h3, 4'h1, 4'h0, 18'h1FF, 1'b0, 2'b11, 2'b01, 20'h1101, device_rank);

      end 
          
        

      if(`DWC_RCD_MODE == `DIRECT_DUAL_CS) begin
        $display("Select function space 0");
        temp = rank %2;
        //send_command_schcr(4'h1, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b01, {16'h0170,rank%2}, rank);
        send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b01, {16'h0170,temp}, device_rank);
      end else if(`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS) begin
        temp = rank %4;
        send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b01, {16'h0170,temp}, device_rank);
      end 
      


      for (j=0; j<`DWC_NO_OF_BYTES; j=j+1) begin 
        $display("-> %0t: [BENCH] Write the result to BYTE %d!", $time, j);
        // Check if there is any byte disabled
        `CFG.read_register_data(`DSGCR, reg_value);  //DSGCR.BDISEN
        `CFG.read_register_data(`DX0GCR0 + ( j * `DX_REG_RANGE), reg_value_1);  //DXnGCR0.DXEN

        //if(!((tb_cfg.dfi_byte_disable[i] == TRUE && reg_value[1] == 1)  || reg_value_1[0] == 0)) begin  
        if(!( reg_value_1[0] == 0)) begin
          // Set Host side DQ=0 on buffer0 for PBA access to buffer 0 only (DQS0 and DQS9) - F0BC2x  0xAC +33phase
          if(sdram_width == 4) begin
            //load_db_dq_register_8bit(4'h2,mrep_result[rank][i*2], rank, pda_mode, pda_device, pda_exit, `DTP_tMOD);

            // Set Host side DQ=0 on buffer0 for PBA access to buffer 0 only (DQS0 upper) - F0BC3x  0xB1 +33phase
            //load_db_dq_register_8bit(4'h3,mrep_result[rank][i*2+1], rank, pda_mode, pda_device, pda_exit, `DTP_tMOD); 
             case (j)
              0: begin
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h3FFFE, 1'b0, 2'b11, 2'b01, {12'h12,mrep_result[rank][j]}, device_rank);
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h3FFFE, 1'b0, 2'b11, 2'b01, {12'h13,mrep_result[rank][j]}, device_rank);
                 end
              1: begin
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h3FFFB, 1'b0, 2'b11, 2'b01, {12'h12,mrep_result[rank][j]}, device_rank);
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h3FFFB, 1'b0, 2'b11, 2'b01, {12'h13,mrep_result[rank][j]}, device_rank);
                 end
              2: begin
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h3FFEF, 1'b0, 2'b11, 2'b01, {12'h12,mrep_result[rank][j]}, device_rank);
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h3FFEF, 1'b0, 2'b11, 2'b01, {12'h13,mrep_result[rank][j]}, device_rank);
                 end
              3: begin
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h3FFBF, 1'b0, 2'b11, 2'b01, {12'h12,mrep_result[rank][j]}, device_rank);
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h3FFBF, 1'b0, 2'b11, 2'b01, {12'h13,mrep_result[rank][j]}, device_rank);
                 end
              4: begin
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h3FEFF, 1'b0, 2'b11, 2'b01, {12'h12,mrep_result[rank][j]}, device_rank);
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h3FEFF, 1'b0, 2'b11, 2'b01, {12'h13,mrep_result[rank][j]}, device_rank);
                 end
              5: begin
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h3FBFF, 1'b0, 2'b11, 2'b01, {12'h12,mrep_result[rank][j]}, device_rank);
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h3FBFF, 1'b0, 2'b11, 2'b01, {12'h13,mrep_result[rank][j]}, device_rank);
                 end
              6: begin
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h3EFFF, 1'b0, 2'b11, 2'b01, {12'h12,mrep_result[rank][j]}, device_rank);
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h3EFFF, 1'b0, 2'b11, 2'b01, {12'h13,mrep_result[rank][j]}, device_rank);
                 end
              7: begin
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h3BFFF, 1'b0, 2'b11, 2'b01, {12'h12,mrep_result[rank][j]}, device_rank);
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h3BFFF, 1'b0, 2'b11, 2'b01, {12'h13,mrep_result[rank][j]}, device_rank);
                 end
              8: begin
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h2FFFF, 1'b0, 2'b11, 2'b01, {12'h12,mrep_result[rank][j]}, device_rank);
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h2FFFF, 1'b0, 2'b11, 2'b01, {12'h13,mrep_result[rank][j]}, device_rank);
                 end
            endcase         
          end else begin
            //load_db_dq_register_8bit(4'h2,mrep_result[rank][i], rank, pda_mode, pda_device, pda_exit, `DTP_tMOD);

            // Set Host side DQ=0 on buffer0 for PBA access to buffer 0 only (DQS0 upper) - F0BC3x  0xB1 +33phase
            //load_db_dq_register_8bit(4'h3,mrep_result[rank][i], rank, pda_mode, pda_device, pda_exit, `DTP_tMOD);
            case (j)
              0: begin
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00FFE, 1'b0, 2'b11, 2'b01, {12'h12,mrep_result[rank][j]}, device_rank);
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00FFE, 1'b0, 2'b11, 2'b01, {12'h13,mrep_result[rank][j]}, device_rank);
                 end
              1: begin
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00FFD, 1'b0, 2'b11, 2'b01, {12'h12,mrep_result[rank][j]}, device_rank);
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00FFD, 1'b0, 2'b11, 2'b01, {12'h13,mrep_result[rank][j]}, device_rank);
                 end
              2: begin
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00FFB, 1'b0, 2'b11, 2'b01, {12'h12,mrep_result[rank][j]}, device_rank);
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00FFB, 1'b0, 2'b11, 2'b01, {12'h13,mrep_result[rank][j]}, device_rank);
                 end
              3: begin
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00FF7, 1'b0, 2'b11, 2'b01, {12'h12,mrep_result[rank][j]}, device_rank);
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00FF7, 1'b0, 2'b11, 2'b01, {12'h13,mrep_result[rank][j]}, device_rank);
                 end
              4: begin
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00FEF, 1'b0, 2'b11, 2'b01, {12'h12,mrep_result[rank][j]}, device_rank);
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00FEF, 1'b0, 2'b11, 2'b01, {12'h13,mrep_result[rank][j]}, device_rank);
                 end
              5: begin
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00FDF, 1'b0, 2'b11, 2'b01, {12'h12,mrep_result[rank][j]}, device_rank);
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00FDF, 1'b0, 2'b11, 2'b01, {12'h13,mrep_result[rank][j]}, device_rank);
                 end
              6: begin
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00FBF, 1'b0, 2'b11, 2'b01, {12'h12,mrep_result[rank][j]}, device_rank);
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00FBF, 1'b0, 2'b11, 2'b01, {12'h13,mrep_result[rank][j]}, device_rank);
                 end
              7: begin
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00F7F, 1'b0, 2'b11, 2'b01, {12'h12,mrep_result[rank][j]}, device_rank);
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00F7F, 1'b0, 2'b11, 2'b01, {12'h13,mrep_result[rank][j]}, device_rank);
                 end
              8: begin
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00EFF, 1'b0, 2'b11, 2'b01, {12'h12,mrep_result[rank][j]}, device_rank);
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00EFF, 1'b0, 2'b11, 2'b01, {12'h13,mrep_result[rank][j]}, device_rank);
                 end
            endcase
          end
        end  
      end
    end
  end

  for(rank_no=0; rank_no < `DWC_NO_OF_RANKS; rank_no = rank_no +1 ) begin    
    rank = rank_no;
    
    if(`DWC_RCD_MODE == `DIRECT_DUAL_CS) begin
      device_rank = rank - rank%2;
    end else if(`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS) begin
      device_rank = rank - rank%4;
    end   

    $display("MREP Training - Rank%d : Select Func Space 0 - F0BC7x with DA0=00", rank);   
    send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b01, 20'h01700, device_rank); 


    $display("-> %0t: [BENCH] Take the buffer out of PBA mode! ", $time, rank);
    if(rank_disable[rank] == `FALSE) begin   
  
      if(`DWC_NO_OF_BYTES > 1 && (rank%2==0 && `DWC_RCD_MODE == `DIRECT_DUAL_CS || (rank%4==0 && (`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS)))) begin
      //if(`DWC_NO_OF_BYTES > 1 ) begin
        $display("-> %0t: [BENCH] Rank! ", $time, rank);
    
        
        `CFG.read_register_data(`MR3_REG, reg_value);
    
        $display("Rank%d : Exit the DB from PBA mode - F0BC1x with DA0=0", rank);
        send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b01, 20'h1100, device_rank);


        $display("Rank%d : Put the DB into PDA mode - F0BC1x with DA2=1", rank);
        send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b01, 20'h1104, device_rank);
 

        $display("Rank%d : Exit the DRAM from PDA mode - MR3 A4=0 - Side A", rank);
        send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b00, {reg_value[20:5], 1'b0, reg_value[3:0]}, device_rank);
 

        $display("Rank%d : Exit the DRAM from PDA mode - MR3 A4=0 - Side B", rank);
        send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b10, {reg_value[20:5], 1'b0, reg_value[3:0]}, device_rank);


        $display("Rank%d : Exit the DB from PDA mode - F0BC1x with DA2=0", rank);
        send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b01, 20'h1100, device_rank);
       
      end 
    end
  end
  
 // Exit the chip from PUB mode
  `CFG.read_register_data(`PGCR1, reg_value);  //PUB Mode
  reg_value[6] =0;
  `CFG.write_register(`PGCR1, reg_value);
  repeat(100) @(posedge `SYS.clk); 

  mrep_train = 1'b0;     
end
endtask

//============================================================================================
// do_dwl_training() - Runs LRDIMM DWL training
//============================================================================================
task do_dwl_training;
  reg [`CMD_WIDTH-1 :0] dcu_command;   
  reg [`SDRAM_RANK_WIDTH-1:0] rank;
  reg [`SDRAM_RANK_WIDTH-1:0] device_rank;
  integer rank_no;
  //reg [`SDRAM_BANK_WIDTH-1:0] bank;
  reg [`DWC_PHY_BG_WIDTH + `DWC_PHY_BA_WIDTH  -1:0] bank;
  reg [12  :0] addr;
  reg [`DCU_RPT_WIDTH-1 :0] dcu_rpt;
  reg [`DCU_DTP_WIDTH-1 :0] dcu_dtp;
  reg [`DCU_TAG_WIDTH-1 :0] dcu_tag;
  reg [`PUB_DQS_WIDTH- 1 : 0] mask={`PUB_DQS_WIDTH{`DDR_MASK_OFF}};
  reg [`DCU_DATA_WIDTH- 1 :0] data=`PUB_DATA_0000_0000;


  reg [12:0] addr_dwl_ax = 13'h1a00;
  reg [12:0] addr_dwl_bx = 13'h1b00; 
  reg [`DWC_NO_OF_BYTES -1:0] dq_captured    = 0;
  reg [`DWC_NO_OF_BYTES -1:0] dq_captured_x4 = 0;
  reg [31:0] read_data;
  reg [31:0] reg_value;
  reg [31:0] reg_value_1;
  reg [`DWC_NO_OF_BYTES -1:0] previous_dq    = 0;
  reg [`DWC_NO_OF_BYTES -1:0] previous_dq_x4 = 0;  
  reg [`DWC_NO_OF_BYTES -1:0] initial_dq     = 0; 
  reg [`DWC_NO_OF_BYTES -1:0] initial_dq_x4  = 0;     
  reg [3:0] rank_en = 4'hf;  
  reg [3:0] rank_wl = 4'h0; 
  
  reg terminate = `FALSE; 
  reg [3:0] temp;

  integer i;
  integer j; 

  dwl_train = 1'b1;
  
  for(rank_no=0; rank_no < `DWC_NO_OF_RANKS; rank_no=rank_no+1) begin
    rank = rank_no;
    if(rank_disable[rank] == `FALSE) begin 
      terminate = `FALSE;
      rank_en = 4'hf;
      if(`DWC_RCD_MODE == `DIRECT_DUAL_CS) begin
        rank_en[rank%2] = 1'h0;
      end else if(`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS) begin
        rank_en[rank%4] = 1'h0;
      end    
      previous_dq    = 0;
      dq_captured    = 0;
      previous_dq_x4 = 0;
      dq_captured_x4 = 0;      

      //Set DRAM WL
      //Set WL for A-side
      dcu_command     = `LOAD_MODE;
      dcu_dtp         = `DTP_tMOD;
      dcu_tag         = `DCU_NOTAG;
      dcu_rpt         = `DCU_NORPT;
      bank            = 1;
      `CFG.read_register_data(`MR1_REG, reg_value);
      addr            = reg_value;
      addr[7]         = 1;
      `CFG.load_dcu_command(dcu_rpt, dcu_dtp, dcu_tag, dcu_command, rank, bank, addr, mask, data);

      //Set WL for B-side
      dcu_command     = `LOAD_MODE;
      dcu_dtp         = `DTP_tMOD;
      dcu_tag         = `DCU_NOTAG;
      dcu_rpt         = `DCU_NORPT;
      bank            = 9;
      addr            = reg_value;
      addr[7]         = 1;
      `CFG.load_dcu_command(dcu_rpt, dcu_dtp, dcu_tag, dcu_command, rank, bank, addr, mask, data);
      run_dcu_command(1);
      
      //Set Databuffer MWL Mode
      //Select Func Space 0
      select_func_space(0, rank, `DTP_tMOD);    

      // Write Buffer Register F0BC07=0xe  (Set enable for Rank 0 only)
      load_db_dq_register_4bit(8'h07,rank_en, rank, `DTP_tMOD);
      
      if(`DWC_RCD_MODE == `DIRECT_DUAL_CS) begin

        // Write Buffer Register F0BC08=0x0  (Set Rank 0 for WL)
        load_db_dq_register_4bit(8'h08,rank_wl%2, rank,  `DTP_tMOD);  
      end else if(`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS) begin

        // Write Buffer Register F0BC08=0x0  (Set Rank 0 for WL)
        load_db_dq_register_4bit(8'h08,rank_wl%4, rank,  `DTP_tMOD);  
      end          

      // Write Buffer Register F0BC0C=0x4  (Set DWL)
      load_db_dq_register_4bit(8'h0c,4'h4, rank, `DTP_tMOD);  

      for (i=0; i < 64; i=i+1) begin 
        $display("-> %0t: [BENCH]  Iterating  %0d ! ", $time, i);
        //Select Func Space 0
        if(`DWC_RCD_MODE == `DIRECT_DUAL_CS) begin
          select_func_space(rank%2, rank, `DTP_tMOD); 
        end else if(`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS) begin
          select_func_space(rank%4, rank, `DTP_tMOD); 
        end 

        // Write Buffer Register F0BCax=i 
        load_db_dq_register_8bit(4'ha,i, rank, `DTP_tMOD);   

        // Write Buffer Register F0BCbx=i   
        load_db_dq_register_8bit(4'hb,i, rank, `DTP_tMOD); 

        repeat (30) @(`SYS.clk); //Wait some clocks to get data on DXNGSR2.DBDQ


        for (j=0; j<`DWC_NO_OF_BYTES; j=j+1) begin
          `CFG.read_register_data(`DSGCR, reg_value);  //DSGCR.BDISEN
          `CFG.read_register_data(`DX0GCR0 + ( j * `DX_REG_RANGE), reg_value_1);  //DXnGCR0.DXEN
          //if(!((reg_value[1] == 1)  || reg_value_1[0] == 0)) begin
          if(!(reg_value_1[0] == 0)) begin
            `CFG.disable_read_compare;
          //if(!((tb_cfg.dfi_byte_disable[j] == TRUE && regs.get_field("DSGCR", "BDISEN") == 1)  || regs.get_field($psprintf("DX%0dGCR0", j), "DXEN") == 0)) begin
            `CFG.read_register_data(`DX0GSR2 + ( j * `DX_REG_RANGE), read_data);
            //regs.read($psprintf("DX%0dGSR2", j), read_data);
            dq_captured[j] = read_data[12];
            $display("-> %0t: [BENCH]  dq_captured :   %0d ! ", $time, dq_captured[j]);
            if(i==0)
              initial_dq[j] = read_data[12]; 
            if(sdram_width == 4) begin
              dq_captured_x4[j] = read_data[16];
              if(i==0)
                initial_dq_x4[j] = read_data[16];             
              if(previous_dq[j] == 0 && dq_captured[j] == 1) begin
                dwl_result[rank][j*2] = i; 
                previous_dq[j] = dq_captured[j];
              end  
              if(previous_dq_x4[j] == 0 && dq_captured_x4[j] == 1) begin
                dwl_result[rank][j*2+1] = i; 
                previous_dq_x4[j] = dq_captured_x4[j];
              end                          
            end else begin  
              if(previous_dq[j] == 0 && dq_captured[j] == 1) begin
                dwl_result[rank][j] = i; 
                previous_dq[j] = dq_captured[j];
              end 
            end
          end else begin
            previous_dq[j]    = 1;
            initial_dq[j]     = 1;
            dq_captured[j]    = 0;
            previous_dq_x4[j] = 1;
            initial_dq_x4[j]  = 1;
            dq_captured_x4[j] = 0;            
          end     
        end

        $display("-> %0t: [BENCH]  terminate  %0d ! ", $time, terminate);
        if(initial_dq == 1 && (initial_dq_x4 == 1 || sdram_width != 4) && terminate == `FALSE) begin
          $display("-> %0t: [BENCH]  Entering  ! ", $time);
          if(dq_captured == 0 || (dq_captured_x4 && sdram_width == 4))
            terminate = `TRUE;
        end
        else
          terminate = `TRUE;

        if(&previous_dq != 0 && (sdram_width != 4 || &previous_dq_x4 != 0) && terminate == `TRUE)
          break; 

      end  

      if(terminate != `TRUE)
        $display("-> %0t: [BENCH]  Could not find write leveling phase on DWL for rank %0d ! ", $time, rank);
        //`vmm_fatal(log, $psprintf("Could not find write leveling phase on DWL for rank %0d !",rank));

      //Disable DRAM WL
      //Set WL for A-side
      dcu_command     = `LOAD_MODE;
      dcu_dtp         = `DTP_tMOD;
      dcu_tag         = `DCU_NOTAG;
      dcu_rpt         = `DCU_NORPT;
      bank            = 1;
      `CFG.read_register_data(`MR1_REG, reg_value);
      addr            = reg_value;
      //addr            = regs.get_value("MR1_RNK0");
      addr[7]         = 0;
      `CFG.load_dcu_command(dcu_rpt, dcu_dtp, dcu_tag, dcu_command, rank, bank, addr, mask, data);

      //Disable WL for B-side
      dcu_command     = `LOAD_MODE;
      dcu_dtp         = `DTP_tMOD;
      dcu_tag         = `DCU_NOTAG;
      dcu_rpt         = `DCU_NORPT;
      bank            = 9;
      //addr            = regs.get_value("MR1_RNK0");
      addr            = reg_value;
      addr[7]         = 0;
      `CFG.load_dcu_command(dcu_rpt, dcu_dtp, dcu_tag, dcu_command, rank, bank, addr, mask, data);
      run_dcu_command(1);
      
      //Select Func Space 0
      select_func_space(0, rank,  `DTP_tMOD);       

      // Write Buffer Register F0BC07=0xf  (Enable all ranks)
      load_db_dq_register_4bit(8'h07,4'h0, rank,  `DTP_tMOD);  //??? 0 ou f

      // Disable DWL
      load_db_dq_register_4bit(8'h0c,4'h0, rank,  `DTP_tMOD); 

      rank_wl = rank_wl + 4'h1;
    end
  end
  
  // Enter pba mode to load results
  // Need to use schcr0 & 1 to send commands


  // Set the chip to PUB mode
  `CFG.read_register_data(`PGCR1, reg_value);  //PUB Mode
  reg_value[6] =1;
  `CFG.write_register(`PGCR1, reg_value);
  repeat(100) @(posedge `SYS.clk); 

  for(rank_no=0; rank_no < `DWC_NO_OF_RANKS; rank_no = rank_no +1) begin    
    rank = rank_no;


    if(`DWC_RCD_MODE == `DIRECT_DUAL_CS) begin
      device_rank = rank - rank%2;
    end else if(`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS) begin
      device_rank = rank - rank%4;
    end


    if(rank_disable[rank] == `FALSE) begin

      //Write MREP values
      if(`DWC_NO_OF_BYTES > 1 && (rank%2==0 && `DWC_RCD_MODE == `DIRECT_DUAL_CS || (rank%4==0 && (`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS)))) begin
      //if(`DWC_NO_OF_BYTES > 1) begin
        // Put the buffer into PBA mode - F0BC1x  0x01
        //load_db_dq_register_8bit(4'h1,8'h01, rank,  `DTP_tMOD);

        `CFG.read_register_data(`MR3_REG, reg_value);

        $display("Rank%d : Put the DRAM into PDA mode - MR3 A4=1 - Side A", rank);
        send_command_schcr(4'h1, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b00, {reg_value[20:5], 1'b1, reg_value[3:0]}, device_rank);

        $display("Rank%d : Put the DRAM into PDA mode - MR3 A4=1 - Side B", rank);
        send_command_schcr(4'h1, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b10, {reg_value[20:5], 1'b1, reg_value[3:0]}, device_rank);

        $display("Rank%d : Put the DB into PBA mode - F0BC1x with DA0=1", rank);
        send_command_schcr(4'h3, 4'h1, 4'h0, 18'h1FF, 1'b0, 2'b11, 2'b01, 20'h1101, device_rank);

      end 
          
      //if(`DWC_RCD_MODE == `DIRECT_DUAL_CS) begin
        //select_func_space(rank%2, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD); 
      //end else if(`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS) begin
        //select_func_space(rank%4, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD);
      //end  
      
      if(`DWC_RCD_MODE == `DIRECT_DUAL_CS) begin
        $display("Select function space 0");
        temp = rank %2;
        //send_command_schcr(4'h1, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b01, {16'h0170,rank%2}, rank);
        send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b01, {16'h0170,temp}, device_rank);
      end else if(`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS) begin
        temp = rank %4;
        send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b01, {16'h0170,temp}, device_rank);
      end 
      






      for (i=0; i<`DWC_NO_OF_BYTES; i=i+1) begin
        `CFG.read_register_data(`DSGCR, reg_value);  //DSGCR.BDISEN
        `CFG.read_register_data(`DX0GCR0 + ( i * `DX_REG_RANGE), reg_value_1);  //DXnGCR0.DXEN
        //if(!((reg_value[1] == 1)  || reg_value_1[0] == 0)) begin  
        if(!( reg_value_1[0] == 0)) begin  
        //if(!((tb_cfg.dfi_byte_disable[i] == TRUE && regs.get_field("DSGCR", "BDISEN") == 1)  || regs.get_field($psprintf("DX%0dGCR0", i), "DXEN") == 0)) begin 
          if(sdram_width == 4) begin
            // Write Buffer Register F0BCAx (DWL result)
            //load_db_dq_register_8bit(4'ha,dwl_result[rank][i*2], rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD); 

            // Write Buffer Register F0BCAx (DWL result)
            //load_db_dq_register_8bit(4'hb,dwl_result[rank][i*2+1], rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD); 
              case (i)
              0: begin
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h3FFFE, 1'b0, 2'b11, 2'b01, {16'h1a,dwl_result[rank][i]}, device_rank);
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h3FFFE, 1'b0, 2'b11, 2'b01, {16'h1b,dwl_result[rank][i]}, device_rank);
                 end
              1: begin
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h3FFFB, 1'b0, 2'b11, 2'b01, {16'h1a,dwl_result[rank][i]}, device_rank);
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h3FFFB, 1'b0, 2'b11, 2'b01, {16'h1b,dwl_result[rank][i]}, device_rank);
                 end
              2: begin
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h3FFEF, 1'b0, 2'b11, 2'b01, {16'h1a,dwl_result[rank][i]}, device_rank);
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h3FFEF, 1'b0, 2'b11, 2'b01, {16'h1b,dwl_result[rank][i]}, device_rank);
                 end
              3: begin
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h3FFBF, 1'b0, 2'b11, 2'b01, {16'h1a,dwl_result[rank][i]}, device_rank);
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h3FFBF, 1'b0, 2'b11, 2'b01, {16'h1b,dwl_result[rank][i]}, device_rank);
                 end
              4: begin
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h3FEFF, 1'b0, 2'b11, 2'b01, {16'h1a,dwl_result[rank][i]}, device_rank);
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h3FEFF, 1'b0, 2'b11, 2'b01, {16'h1b,dwl_result[rank][i]}, device_rank);
                 end
              5: begin
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h3FBFF, 1'b0, 2'b11, 2'b01, {16'h1a,dwl_result[rank][i]}, device_rank);
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h3FBFF, 1'b0, 2'b11, 2'b01, {16'h1b,dwl_result[rank][i]}, device_rank);
                 end
              6: begin
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h3EFFF, 1'b0, 2'b11, 2'b01, {16'h1a,dwl_result[rank][i]}, device_rank);
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h3EFFF, 1'b0, 2'b11, 2'b01, {16'h1b,dwl_result[rank][i]}, device_rank);
                 end
              7: begin
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h3BFFF, 1'b0, 2'b11, 2'b01, {16'h1a,dwl_result[rank][i]}, device_rank);
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h3BFFF, 1'b0, 2'b11, 2'b01, {16'h1b,dwl_result[rank][i]}, device_rank);
                 end
              8: begin
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h2FFFF, 1'b0, 2'b11, 2'b01, {16'h1a,dwl_result[rank][i]}, device_rank);
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h2FFFF, 1'b0, 2'b11, 2'b01, {16'h1b,dwl_result[rank][i]}, device_rank);
                 end
            endcase   

          end else begin
            // Write Buffer Register F0BCAx (DWL result)
            //load_db_dq_register_8bit(4'ha,dwl_result[rank][i], rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD); 

            // Write Buffer Register F0BCAx (DWL result)
            //load_db_dq_register_8bit(4'hb,dwl_result[rank][i], rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD); 
             case (i)
              0: begin
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00FFE, 1'b0, 2'b11, 2'b01, {16'h1a,dwl_result[rank][i]}, device_rank);
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00FFE, 1'b0, 2'b11, 2'b01, {16'h1b,dwl_result[rank][i]}, device_rank);
                 end
              1: begin
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00FFD, 1'b0, 2'b11, 2'b01, {16'h1a,dwl_result[rank][i]}, device_rank);
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00FFD, 1'b0, 2'b11, 2'b01, {16'h1b,dwl_result[rank][i]}, device_rank);
                 end
              2: begin
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00FFB, 1'b0, 2'b11, 2'b01, {16'h1a,dwl_result[rank][i]}, device_rank);
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00FFB, 1'b0, 2'b11, 2'b01, {16'h1b,dwl_result[rank][i]}, device_rank);
                 end
              3: begin
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00FF7, 1'b0, 2'b11, 2'b01, {16'h1a,dwl_result[rank][i]}, device_rank);
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00FF7, 1'b0, 2'b11, 2'b01, {16'h1b,dwl_result[rank][i]}, device_rank);
                 end
              4: begin
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00FEF, 1'b0, 2'b11, 2'b01, {16'h1a,dwl_result[rank][i]}, device_rank);
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00FEF, 1'b0, 2'b11, 2'b01, {16'h1b,dwl_result[rank][i]}, device_rank);
                 end
              5: begin
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00FDF, 1'b0, 2'b11, 2'b01, {16'h1a,dwl_result[rank][i]}, device_rank);
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00FDF, 1'b0, 2'b11, 2'b01, {16'h1b,dwl_result[rank][i]}, device_rank);
                 end
              6: begin
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00FBF, 1'b0, 2'b11, 2'b01, {16'h1a,dwl_result[rank][i]}, device_rank);
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00FBF, 1'b0, 2'b11, 2'b01, {16'h1b,dwl_result[rank][i]}, device_rank);
                 end
              7: begin
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00F7F, 1'b0, 2'b11, 2'b01, {16'h1a,dwl_result[rank][i]}, device_rank);
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00F7F, 1'b0, 2'b11, 2'b01, {16'h1b,dwl_result[rank][i]}, device_rank);
                 end
              8: begin
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00EFF, 1'b0, 2'b11, 2'b01, {16'h1a,dwl_result[rank][i]}, device_rank);
                   send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00EFF, 1'b0, 2'b11, 2'b01, {16'h1b,dwl_result[rank][i]}, device_rank);
                 end
            endcase






          end
        end
      end
    end
  end
  
  for(rank_no=0; rank_no < `DWC_NO_OF_RANKS; rank_no = rank_no+1) begin    
    rank = rank_no;

    if(`DWC_RCD_MODE == `DIRECT_DUAL_CS) begin
      device_rank = rank - rank%2;
    end else if(`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS) begin
      device_rank = rank - rank%4;
    end


    $display("DWL Training - Rank%d : Select Func Space 0 - F0BC7x with DA0=00", rank);   
    send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b01, 20'h01700, device_rank);


    if(rank_disable[rank] == `FALSE) begin   
  
      if(`DWC_NO_OF_BYTES > 1 && (rank%2==0 && `DWC_RCD_MODE == `DIRECT_DUAL_CS || (rank%4==0 && (`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS)))) begin
      //if(`DWC_NO_OF_BYTES > 1) begin
        
        `CFG.read_register_data(`MR3_REG, reg_value);
    
        $display("Rank%d : Exit the DB from PBA mode - F0BC1x with DA0=0", rank);
        send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b01, 20'h1100, device_rank);


        $display("Rank%d : Put the DB into PDA mode - F0BC1x with DA2=1", rank);
        send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b01, 20'h1104, device_rank);
 

        $display("Rank%d : Exit the DRAM from PDA mode - MR3 A4=0 - Side A", rank);
        send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b00, {reg_value[20:5], 1'b0, reg_value[3:0]}, device_rank);
 

        $display("Rank%d : Exit the DRAM from PDA mode - MR3 A4=0 - Side B", rank);
        send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b10, {reg_value[20:5], 1'b0, reg_value[3:0]}, device_rank);


        $display("Rank%d : Exit the DB from PDA mode - F0BC1x with DA2=0", rank);
        send_command_schcr(4'h1, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b01, 20'h1100, device_rank);





        // Select Func Space 0
        //select_func_space(0, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD);    

        // Take the buffer out of PBA mode
        //load_db_dq_register_8bit(4'h1,8'h00, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD);    
      end 
    end
  end
  

   // Exit the chip from PUB mode
  `CFG.read_register_data(`PGCR1, reg_value);  //PUB Mode
  reg_value[6] =0;
  `CFG.write_register(`PGCR1, reg_value);
  repeat(100) @(posedge `SYS.clk); 
  
  dwl_train = 1'b0;  
endtask


//============================================================================================
// do_hwl_training() - Runs LRDIMM HWL training
//============================================================================================
task do_hwl_training;
  reg [`CMD_WIDTH-1 :0] dcu_command;   
  reg [`SDRAM_RANK_WIDTH-1:0] rank;
  integer rank_no;
  //reg [`SDRAM_BANK_WIDTH-1:0] bank;
  reg [`DWC_PHY_BG_WIDTH + `DWC_PHY_BA_WIDTH  -1:0] bank;
  reg [12  :0] addr;
  reg [`DCU_RPT_WIDTH-1 :0] dcu_rpt;
  reg [`DCU_DTP_WIDTH-1 :0] dcu_dtp;
  reg [`DCU_TAG_WIDTH-1 :0] dcu_tag;
  reg [`PUB_DQS_WIDTH    - 1 : 0] mask={`PUB_DQS_WIDTH{`DDR_MASK_OFF}};
  reg [`DCU_DATA_WIDTH- 1 :0] data=`PUB_DATA_0000_0000;

  reg  [`DWC_NO_OF_LRANKS-1:0] rank_en;
   
  hwl_train = 1'b1;
  
  for(rank_no=0; rank_no < `DWC_NO_OF_RANKS; rank_no =  rank_no +1) begin
    $display("-> %0t: [BENCH] Training for rank %0d ! ", $time, rank_no);
    rank = rank_no;
    if(rank%2==0 && `DWC_RCD_MODE == `DIRECT_DUAL_CS || ( rank%4==0 && (`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS)) ) begin
      //Set Databuffer HWL Mode
      //Select Func Space 0 
      rank_en = 0;
      rank_en[rank] = 1'b1;
      
      //regs.set_field("DTCR1", "RANKEN", rank_en);
      //regs.flush("DTCR1"); 
      `GRM.dtcr1[31:16] = rank_en; 
      `CFG.write_register(`DTCR1, `GRM.dtcr1);
      
      select_func_space(0, rank,  `DTP_tMOD); 

      // Write Buffer Register F0BC07=0xe  (Set enable for Rank 0 only)
      load_db_dq_register_4bit(8'h07,4'he, rank, `DTP_tMOD); 

      // Write Buffer Register F0BC08=0x0  (Set Rank 0 for WL)
      load_db_dq_register_4bit(8'h08,4'h0, rank, `DTP_tMOD);   

      // Write Buffer Register F0BC0C=0x5  (Set HWL)
      load_db_dq_register_4bit(8'h0c,4'h5, rank, `DTP_tMOD);
  

      //do_write_leveling();
      write_level(`DWC_NO_OF_RANKS);
      //write_level_selected_ranks(rank_en);
      // Write Buffer Register F0BC07=0xf  (Enable all ranks)
      load_db_dq_register_4bit(8'h07,4'h0, rank, `DTP_tMOD); 

      // Disable HWL
      load_db_dq_register_4bit(8'h0c,4'h0, rank, `DTP_tMOD); 
      $display("-> %0t: [BENCH] End Training for rank %0d ! ", $time, rank_no);
    end
  end
  
  `GRM.dtcr1[31:16] = {`DWC_NO_OF_LRANKS{1'b1}}; 
  `CFG.write_register(`DTCR1, `GRM.dtcr1);
  //regs.set_field("DTCR1", "RANKEN", {`DWC_NO_OF_LRANKS{1'b1}});
  //regs.flush("DTCR1"); 
    
  hwl_train = 1'b0;  
  
endtask 


//============================================================================================
// do_mrd_training() - Runs LRDIMM MRD training
//============================================================================================
task do_mrd_training;
  reg [`CMD_WIDTH-1 :0] dcu_command;   
  reg [`SDRAM_RANK_WIDTH-1:0] rank;
  reg [`SDRAM_RANK_WIDTH-1:0] device_rank;
  integer rank_no;
  //reg [`SDRAM_BANK_WIDTH-1:0] bank;
  reg [`DWC_PHY_BG_WIDTH + `DWC_PHY_BA_WIDTH  -1:0] bank;
  reg [12  :0] addr;
  reg [`DCU_RPT_WIDTH-1 :0] dcu_rpt;
  reg [`DCU_DTP_WIDTH-1 :0] dcu_dtp;
  reg [`DCU_TAG_WIDTH-1 :0] dcu_tag;
  reg [`PUB_DQS_WIDTH-1 :0] mask={`PUB_DQS_WIDTH{`DDR_MASK_OFF}};
  reg [`DCU_DATA_WIDTH- 1 :0] data=`PUB_DATA_0000_0000;
  //temporary store register value
  reg [`REG_DATA_WIDTH-1 :0] reg_value;
  reg [`REG_DATA_WIDTH-1 :0] reg_value_1;

  reg [`DWC_NO_OF_BYTES -1:0]       dq_captured    = '0;
  reg [`DWC_NO_OF_BYTES -1:0]       previous_dq    = '0;
  reg [`DWC_NO_OF_BYTES -1:0]       dq_captured_x4 = '0;
  reg [`DWC_NO_OF_BYTES -1:0]       previous_dq_x4 = '0;  
  reg [3:0] rank_en = 4'hf;  
  reg [31:0] read_data;
  reg [3:0]  mrd_delay;
  integer        mrd_left_edge_cycle[pNUM_LANES-1 :0];
  integer        mrd_left_edge_delay[`DWC_NO_OF_BYTES-1 :0];
  integer        mrd_right_edge_cycle[`DWC_NO_OF_BYTES-1 :0];
  integer        mrd_right_edge_delay[`DWC_NO_OF_BYTES-1 :0];
  integer        mrd_left_unit[`DWC_NO_OF_BYTES-1 :0];
  integer        mrd_right_unit[`DWC_NO_OF_BYTES-1 :0];
  integer        mrd_left_edge_cycle_x4[`DWC_NO_OF_BYTES-1 :0];
  integer        mrd_left_edge_delay_x4[`DWC_NO_OF_BYTES-1 :0];
  integer        mrd_right_edge_cycle_x4[`DWC_NO_OF_BYTES-1 :0];
  integer        mrd_right_edge_delay_x4[`DWC_NO_OF_BYTES-1 :0];
  integer        mrd_left_unit_x4[`DWC_NO_OF_BYTES-1 :0];
  integer        mrd_right_unit_x4[`DWC_NO_OF_BYTES-1 :0];  
  reg        mrd_find_right_edge[`DWC_NO_OF_BYTES-1 :0]; 
  reg        mrd_find_left_edge[`DWC_NO_OF_BYTES-1 :0];  
  reg        mrd_find_right_edge_x4[`DWC_NO_OF_BYTES-1 :0]; 
  reg        mrd_find_left_edge_x4[`DWC_NO_OF_BYTES-1 :0];    
  reg [`DWC_NO_OF_BYTES-1:0] mrd_byte_done;   
  reg [`DWC_NO_OF_BYTES-1:0] mrd_byte_done_x4;    
  reg [7:0]  mrd_cycle_x4; 
  integer        mrd_phase    = 0;
  integer        mrd_unit     = 0;
  integer       mrd_cycle    = 0;
  //real       mrd_cycle    = 0;
  integer       mrd_delay_aux;
  //real       mrd_delay_aux;
  
  reg terminate  = `FALSE; 
  reg [3:0] temp;
  reg [17:0] schdqv;

  integer i;
  integer j; 

  mrd_train = 1'b1; 
 
  //reg[7:0]  mrd_phase_result[`DWC_NO_OF_RANKS-1:0][pNUM_LANES-1:0]; 
  //integer   mrd_cycle_result[`DWC_NO_OF_RANKS-1:0][pNUM_LANES-1:0];  
  //for(j=0;j<`DWC_NO_OF_RANKS;j++) begin
  //  for(i=0;i<pNUM_LANES;i=i+1) begin
  //    mrd_phase_result[j][i] = 0;
  //    mrd_cycle_result[j][i] = -1;
  //  end
  //end

 // reg[7:0]  mwd_phase_result[`DWC_NO_OF_RANKS-1:0][pNUM_LANES-1:0]; 
 // integer   mwd_cycle_result[`DWC_NO_OF_RANKS-1:0][pNUM_LANES-1:0];
 
 for(rank_no=0; rank_no < `DWC_NO_OF_RANKS; rank_no= rank_no+1) begin
    rank = rank_no;
    `CFG.disable_read_compare;
    if(rank_disable[rank] == `FALSE) begin  
      terminate = `FALSE;
      rank_en = 4'hf;
      if(`DWC_RCD_MODE == `DIRECT_DUAL_CS) begin
        rank_en[rank%2] = 1'h0;
      end else if(`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS) begin
        rank_en[rank%4] = 1'h0;
      end    
      previous_dq_x4 = 0;
      dq_captured_x4 = 0; 
      previous_dq_x4 = 0;
      dq_captured_x4 = 0;       

      for (j=0; j<`DWC_NO_OF_BYTES; j=j+1) begin
        mrd_byte_done[j] = 1'b0;
        mrd_find_right_edge[j] = 1'b1;
        mrd_find_left_edge[j]  = 1'b0;
        mrd_byte_done_x4[j] = 1'b0;
        mrd_find_right_edge_x4[j] = 1'b1;
        mrd_find_left_edge_x4[j]  = 1'b0;        
      end   

      `ifndef BL_8
      //if(tb_cfg.ddr4_burst_length != DDR4_BL8) begin
        //Set DRAM BL8
        dcu_command     = `LOAD_MODE;
        dcu_dtp         = `DTP_tMOD;
        dcu_tag         = `DCU_NOTAG;
        dcu_rpt         = `DCU_NORPT;
        bank            = 0;
        `CFG.read_register_data(`MR0_REG, reg_value);
        addr            = reg_value;
        addr[1:0]       = 2'b00;
        `CFG.load_dcu_command(dcu_rpt, dcu_dtp, dcu_tag, dcu_command, rank, bank, addr, mask, data);

        //Set DRAM BL8
        dcu_command     = `LOAD_MODE;
        dcu_dtp         = `DTP_tMOD;
        dcu_tag         = `DCU_NOTAG;
        dcu_rpt         = `DCU_NORPT;
        bank            = 8;
        addr            = reg_value;
        addr[1:0]       = 2'b00;
        `CFG.load_dcu_command(dcu_rpt, dcu_dtp, dcu_tag, dcu_command, rank, bank, addr, mask, data);
        run_dcu_command(1);
      //end
      `endif

      // Select Func Space 0  
      select_func_space(0, rank, `DTP_tMOD);

      // Write Buffer Register F0BC07=0xe  (Set enable for Rank 0 only)  
      load_db_dq_register_4bit(8'h07,rank_en, rank,  `DTP_tMOD);

      // Turn on MPR mode for Side A
      dcu_command     = `LOAD_MODE;
      dcu_dtp         = `DTP_tMOD;
      dcu_tag         = `DCU_NOTAG;
      dcu_rpt         = `DCU_NORPT;
      bank            = 3; // side A 4'b0011
      `CFG.read_register_data(`MR3_REG, reg_value);
      addr            = reg_value;
      addr[2:0]       = 3'h4;
      `CFG.load_dcu_command(dcu_rpt, dcu_dtp, dcu_tag, dcu_command, rank, bank, addr, mask, data);

      // Turn on MPR mode for Side B
      dcu_command     = `LOAD_MODE;
      dcu_dtp         = `DTP_tMOD;
      dcu_tag         = `DCU_NOTAG;
      dcu_rpt         = `DCU_NORPT;
      bank            = 11; // side B 4'b1011
      addr            = reg_value;  //MR0
      addr[2:0]       = 3'h4;
      `CFG.load_dcu_command(dcu_rpt, dcu_dtp, dcu_tag, dcu_command, rank, bank, addr, mask, data);
      run_dcu_command(1);
      
      if(rank%2==0 && `DWC_RCD_MODE == `DIRECT_DUAL_CS || ( rank%4==0 && (`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS)) ) begin
        // Select Func Space 6  
        select_func_space(6, rank, `DTP_tMOD);    

        // Sending BCW F6BC4x 0x01  Status on DQ bits per lane
        load_db_dq_register_8bit(4'h4,8'h01, rank, `DTP_tMOD);    

        // Select Func Space 0  
        select_func_space(0, rank,  `DTP_tMOD);      

        // Put the buffer in normal mode - Sending BCW F0BC0 0x0
        load_db_dq_register_4bit(8'h0c,4'h0, rank,  `DTP_tMOD);
      end


      if(`DWC_RCD_MODE == `DIRECT_DUAL_CS) begin
        device_rank = rank - rank%2;
      end else if(`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS) begin
        device_rank = rank - rank%4;
      end  

      if(rank%2==0 && `DWC_RCD_MODE == `DIRECT_DUAL_CS || ( rank%4==0 && (`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS)) ) begin
        if(`DWC_NO_OF_BYTES > 1) begin
          // Put the buffer into PBA mode - F0BC1x  0x01
          // Need to use scheduler to send commands during pba mode
          // PBA mode
          //load_db_dq_register_8bit(4'h1,8'h01, rank,  `DTP_tMOD);
           

          // Set the chip to PUB mode
          `CFG.read_register_data(`PGCR1, reg_value);  //PUB Mode
          reg_value[6] =1;
          `CFG.write_register(`PGCR1, reg_value);

          repeat(100) @(posedge `SYS.clk); 
    
          `CFG.read_register_data(`MR3_REG, reg_value);

          $display("Rank%d : Put the DRAM into PDA mode - MR3 A4=1 - Side A", rank);
          send_command_schcr(4'h1, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b00, {reg_value[20:5], 1'b1, reg_value[3:0]}, device_rank);

          $display("Rank%d : Put the DRAM into PDA mode - MR3 A4=1 - Side B", rank);
          send_command_schcr(4'h1, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b10, {reg_value[20:5], 1'b1, reg_value[3:0]}, device_rank);

          $display("Rank%d : Put the DB into PBA mode - F0BC1x with DA0=1", rank);
          send_command_schcr(4'h3, 4'h1, 4'h0, 18'h1FF, 1'b0, 2'b11, 2'b01, 20'h1101, device_rank);




        end
        
        schdqv = 18'h00000;
        




        for (i=0; i<`DWC_NO_OF_BYTES; i=i+1) begin  
          `CFG.read_register_data(`DSGCR, reg_value);  //DSGCR.BDISEN
          `CFG.read_register_data(`DX0GCR0 + ( i * `DX_REG_RANGE), reg_value_1);  //DXnGCR0.DXEN
          //if(!((reg_value[1] == 1)  || reg_value_1[0] == 0)) begin
          if(!( reg_value_1[0] == 0)) begin
            $display("-> %0t: [BENCH]  Loading for Byte  %0d ! ", $time, i);
          //if (!((tb_cfg.dfi_byte_disable[i] == TRUE && regs.get_field("DSGCR", "BDISEN") == 1)  || regs.get_field($psprintf("DX%0dGCR0", i), "DXEN") == 0)) begin
            // Load 0x2B into the Data Buffer MPR
            // Select Func Space 5   
            
            send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b01, {20'h01705}, device_rank);
            //select_func_space(5, rank,  `DTP_tWR2RD);       
            if (sdram_width ==4) begin
              case (i)
                0: schdqv= 18'h3FFFE;
                1: schdqv= 18'h3FFFB;
                2: schdqv= 18'h3FFEF;
                3: schdqv= 18'h3FFBF;
                4: schdqv= 18'h3FEFF;
                5: schdqv= 18'h3FBFF;
                6: schdqv= 18'h3EFFF;
                7: schdqv= 18'h3BFFF;
                8: schdqv= 18'h2FFFF;
              endcase
              end 
            else begin
              case (i)
                0: schdqv= 18'h00FFE;
                1: schdqv= 18'h00FFD;
                2: schdqv= 18'h00FFB;
                3: schdqv= 18'h00FF7;
                4: schdqv= 18'h00FEF;
                5: schdqv= 18'h00FDF;
                6: schdqv= 18'h00FBF;
                7: schdqv= 18'h00F7F;
                8: schdqv= 18'h00EFF;
              endcase
            end
             
            // leave for ...
            //integer dbPerSdram   //the number of DB for each SDRAM 
            //dbPerSdram =(num_DB/num_sdram) ;


            // Sending BCW F5BC0x 0x00   MPR0
            send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h10,8'h00}, device_rank);
            //load_db_dq_register_8bit(4'h0,8'h00, rank, `DTP_tWR2RD);     

            // Sending BCW F5BC1x 0x00   MPR1
            send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h11,8'h00}, device_rank);
            //load_db_dq_register_8bit(4'h1,8'h00, rank, `DTP_tWR2RD); 
            
            if(sdram_width == 4 && rdimm_addr_inv == `TRUE) begin
              // Sending BCW F5BC2x 0xFF   MPR2 
              //load_db_dq_register_8bit(4'h2,8'h0f, rank, `DTP_tWR2RD);
              send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h12,8'h0f}, device_rank);

              // Sending BCW F5BC3x 0x00   MPR3 
              //load_db_dq_register_8bit(4'h3,8'h0f, rank, `DTP_tWR2RD);
              send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h13,8'h0f}, device_rank);
            end else begin
              // Sending BCW F5BC2x 0xFF   MPR2 
              //load_db_dq_register_8bit(4'h2,(i%2==0 || rdimm_addr_inv == `FALSE)?8'hff:8'h00, rank, `DTP_tWR2RD);
              send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h12,((i)%2==0 || rdimm_addr_inv == `FALSE)?8'hff:8'h00}, device_rank);

              // Sending BCW F5BC3x 0x00   MPR3 
              //load_db_dq_register_8bit(4'h3,(i%2==0 || rdimm_addr_inv == `FALSE)?8'hff:8'h00, rank, `DTP_tWR2RD);
              send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h13,((i)%2==0 || rdimm_addr_inv == `FALSE)?8'hff:8'h00}, device_rank);
            end

            // Select Func Space 6   
            send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b01, {20'h01706}, device_rank);
            //select_func_space(6, rank,  `DTP_tWR2RD);
              
            if(sdram_width == 4 && rdimm_addr_inv == `TRUE) begin   
              // Sending BCW F6BC0x 0xFF   MPR0
              //load_db_dq_register_8bit(4'h0,8'hf0, rank,  `DTP_tWR2RD);  
              send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h10,8'hf0}, device_rank);

              // Sending BCW F6BC1x 0x00   MPR1
              //load_db_dq_register_8bit(4'h1,8'hf0, rank,  `DTP_tWR2RD);                             
              send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h11,8'hf0}, device_rank);

            end else begin
              // Sending BCW F6BC0x 0xFF   MPR0
              //load_db_dq_register_8bit(4'h0,(i%2==0 || rdimm_addr_inv == `FALSE)?8'h00:8'hff, rank,  `DTP_tWR2RD);  
              send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h10,((i)%2==0 || rdimm_addr_inv == `FALSE)?8'h00:8'hff}, device_rank);

              // Sending BCW F6BC1x 0x00   MPR1
              //load_db_dq_register_8bit(4'h1,(i%2==0 || rdimm_addr_inv == `FALSE)?8'h00:8'hff, rank,  `DTP_tWR2RD); 
              send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h11,((i)%2==0 || rdimm_addr_inv == `FALSE)?8'h00:8'hff}, device_rank);
            end            

            // Sending BCW F6BC2x 0xFF   MPR2 
            //load_db_dq_register_8bit(4'h2,8'hff, rank,  `DTP_tWR2RD);        
            send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h12,8'hff}, device_rank);

            // Sending BCW F6BC3x 0xFF   MPR3  
            //load_db_dq_register_8bit(4'h3,8'hff, rank,  `DTP_tWR2RD); 
            send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h13,8'hff}, device_rank);
          end

        end

        if(`DWC_NO_OF_BYTES > 1) begin

          // Select Func Space 0  
          //select_func_space(0, rank,  `DTP_tWR2RD);     
          send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b01, {20'h01700}, device_rank);

          // Take the buffer out of PBA mode
          // Use the scheduler to send commands
          // Take the sdram out of PDA mode
          //load_db_dq_register_8bit(4'h1,8'h00, rank,  `DTP_tWR2RD);    
            
          `CFG.read_register_data(`MR3_REG, reg_value);
    
          $display("Rank%d : Exit the DB from PBA mode - F0BC1x with DA0=0", rank);
          send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b01, 20'h1100, device_rank);


          $display("Rank%d : Put the DB into PDA mode - F0BC1x with DA2=1", rank);
          send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b01, 20'h1104, device_rank);
 

          $display("Rank%d : Exit the DRAM from PDA mode - MR3 A4=0 - Side A", rank);
          send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b00, {reg_value[20:5], 1'b0, reg_value[3:0]}, device_rank);
 

          $display("Rank%d : Exit the DRAM from PDA mode - MR3 A4=0 - Side B", rank);
          send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b10, {reg_value[20:5], 1'b0, reg_value[3:0]}, device_rank);


          $display("Rank%d : Exit the DB from PDA mode - F0BC1x with DA2=0", rank);
          send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b01, 20'h1100, device_rank); 


        end else begin
          // Select Func Space 0  
          //select_func_space(0, rank,  `DTP_tWR2RD); 
          send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b01, {20'h01700}, device_rank);
        end
      end
     
       // Exit the chip from PUB mode

       `CFG.read_register_data(`PGCR1, reg_value);  //PUB Mode
       reg_value[6] =0;
       `CFG.write_register(`PGCR1, reg_value);  
       repeat(100) @(posedge `SYS.clk); 



      // Turn on MPR mode for Side A
      dcu_command     = `LOAD_MODE;
      dcu_dtp         = `DTP_tMOD;
      dcu_tag         = `DCU_NOTAG;
      dcu_rpt         = `DCU_NORPT;
      bank            = 3; // side A 4'b0011
      `CFG.read_register_data(`MR3_REG, reg_value);
      addr            = reg_value;
      addr[2:0]       = 3'h4;
      `CFG.load_dcu_command(dcu_rpt, dcu_dtp, dcu_tag, dcu_command, rank, bank, addr, mask, data);

      // Turn on MPR mode for Side B
      dcu_command     = `LOAD_MODE;
      dcu_dtp         = `DTP_tMOD;
      dcu_tag         = `DCU_NOTAG;
      dcu_rpt         = `DCU_NORPT;
      bank            = 11; // side B 4'b1011
      addr            = reg_value;  //MR0
      addr[2:0]       = 3'h4;
      `CFG.load_dcu_command(dcu_rpt, dcu_dtp, dcu_tag, dcu_command, rank, bank, addr, mask, data);
      run_dcu_command(1);

      // Exit pba mode, could use DCU to send commands then    
      // STEP #2
      // loop with 5 steps... Trying cycle with values -2,-1,0,+1,+2 
      for (mrd_cycle=-2; mrd_cycle<3; mrd_cycle=mrd_cycle+1) begin

        $display("-> %0t: [BENCH]  mrd_cycle  %0d ! ", $time, mrd_cycle);
        $display("-> %0t: [BENCH]  terminate  %0d ! ", $time, terminate);

        if ( terminate == `TRUE ) 
          break;                                        

        select_func_space(0, rank,  `DTP_tMOD);  

        if(rank%2==0 && `DWC_RCD_MODE == `DIRECT_DUAL_CS || ( rank%4==0 && (`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS)) )
          // Put the buffer in MRD training mode - Sending BCW F0BC0 0x6 
          load_db_dq_register_4bit(8'h0c,4'h6, rank,  `DTP_tMOD);             
          
        select_func_space(rank%2, rank, `DTP_tWR2RD); 
                                                                                                                                                   
        if(`DWC_RCD_MODE == `DIRECT_DUAL_CS || ((`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS) && rank%4 < 2))
          // Program the cycle bit to negative 2 for the MRD search  - F0BCCx  0xii (Rank 0 only)
          case (mrd_cycle)                                     
            -2: begin load_db_dq_register_8bit(4'hc,8'h66, rank,  `DTP_tMOD); mrd_unit = 0; end  
            -1: load_db_dq_register_8bit(4'hc,8'h55, rank,  `DTP_tMOD);    
             0: load_db_dq_register_8bit(4'hc,8'h00, rank,  `DTP_tMOD);    
             1: load_db_dq_register_8bit(4'hc,8'h11, rank,  `DTP_tMOD);    
             2: load_db_dq_register_8bit(4'hc,8'h22, rank,  `DTP_tMOD);    
          endcase 
        else
          case (mrd_cycle)                                     
            -2: begin load_db_dq_register_8bit(4'he,8'h66, rank,  `DTP_tMOD); mrd_unit = 0; end  
            -1: load_db_dq_register_8bit(4'he,8'h55, rank,  `DTP_tMOD);    
             0: load_db_dq_register_8bit(4'he,8'h00, rank,  `DTP_tMOD);    
             1: load_db_dq_register_8bit(4'he,8'h11, rank,  `DTP_tMOD);    
             2: load_db_dq_register_8bit(4'he,8'h22, rank,  `DTP_tMOD);    
          endcase         
          
          
        if(`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS) begin
          select_func_space(rank%4, rank,  `DTP_tWR2RD);
        end                                                  

        // STEP #4                                                                                                                                       
        // set MDQS Read delay to -15 (signal is in the addr load cmds)                                                                      
        mrd_delay = 4'hf;                                                                                                                              

        // -15 to 0 to +15 read delay trough F0BC4x and F0BC5x                                                                                     
        for (mrd_delay_aux = -15; mrd_delay_aux < 16; mrd_delay_aux=mrd_delay_aux+1) begin
          $display("-> %0t: [BENCH] mrd_delay_aux   %0d ! ", $time,mrd_delay_aux );
          if ( terminate == `TRUE )
            break;

          // decrement negative delay (-15 to -1)                                                                                          
          if (mrd_delay_aux<0) begin                                                                                                      
            // F0BC4x            
            load_db_dq_register_8bit(4'h4,{1'b1,mrd_delay}, rank,  `DTP_tMOD);
            // F0BC5x                             
            load_db_dq_register_8bit(4'h5,{1'b1,mrd_delay}, rank,  `DTP_tMOD); 

            // Issue a READ commands and check Host side DQ for compare status
            dcu_command     = `SDRAM_READ;                                          
            dcu_dtp         = `DTP_tRAS;                                        
            dcu_tag         = `DCU_NOTAG;                                    
            dcu_rpt         = `DCU_tBL;      
            `CFG.read_register_data(`DTAR0, reg_value); 
            //bank            = reg_value[27:24];  //DTAR0.DTBGBK1           
            bank            = 4'b0001;  //DTAR0.DTBGBK1           
            //bank            = regs.get_field("DTAR0", "DTBGBK1");        
            `CFG.read_register_data(`DTAR1, reg_value);            
            addr            = {reg_value[8:0], 3'b000}; //DTAR1.DTCOL0, the default value is not same for VMM&DTB
            //addr            = {9'b000011000, 3'b000}; //DTAR1.DTCOL0
            //addr            = {regs.get_field("DTAR1", "DTCOL0"), 3'b000};                                                        
            `CFG.load_dcu_command(dcu_rpt, dcu_dtp, dcu_tag, dcu_command, rank, bank, addr, mask, data);
            // decrement negative delay                                           
            mrd_delay = mrd_delay-1;                                           
          end                                                                 
          else begin // increment positive delay (0 to +15)                   
            // F0BC4x 
            load_db_dq_register_8bit(4'h4,{1'b0,mrd_delay}, rank,  `DTP_tMOD);         
            // F0BC5x   
            load_db_dq_register_8bit(4'h5,{1'b0,mrd_delay}, rank,  `DTP_tMOD);   

            // Issue a READ commands and check Host side DQ for compare status                                 
            dcu_command     = `SDRAM_READ;                                        
            dcu_dtp         = `DTP_tRAS;                                        
            dcu_tag         = `DCU_NOTAG;                                    
            dcu_rpt         = `DCU_tBL;                                         
            `CFG.read_register_data(`DTAR0, reg_value); 
            //bank            = reg_value[27:24];  //DTAR0.DTBGBK1           
            bank            = 4'b0001;  //DTAR0.DTBGBK1           
            //bank            = regs.get_field("DTAR0", "DTBGBK1");              
            `CFG.read_register_data(`DTAR1, reg_value);            
            addr            = {reg_value[8:0], 3'b000}; //DTAR1.DTCOL0
            //addr            = {9'b000011000, 3'b000}; //DTAR1.DTCOL0
            //addr            = {regs.get_field("DTAR1", "DTCOL0"), 3'b000};     
            `CFG.load_dcu_command(dcu_rpt, dcu_dtp, dcu_tag, dcu_command, rank, bank, addr, mask, data);
            // increment positive delay                                                                           
            mrd_delay = mrd_delay+1;                                           
          end 
          run_dcu_command(0);
          
          repeat (30) @(posedge `SYS.clk); //Wait some clocks to get data on DXNGSR2.DBDQ     

          for (j=0; j<`DWC_NO_OF_BYTES; j=j+1) begin 
            $display("Byte %d",j);
            `CFG.read_register_data(`DSGCR, reg_value);  //DSGCR.BDISEN
            `CFG.read_register_data(`DX0GCR0 + ( j * `DX_REG_RANGE), reg_value_1);  //DXnGCR0.DXEN
            //if(!((reg_value[1] == 1)  || reg_value_1[0] == 0)) begin
            if(!(reg_value_1[0] == 0)) begin
            //if (!((tb_cfg.dfi_byte_disable[j] == TRUE && regs.get_field("DSGCR", "BDISEN") == 1)  || regs.get_field($psprintf("DX%0dGCR0", j), "DXEN") == 0)) begin  
              previous_dq[j]    = dq_captured[j]; 
              previous_dq_x4[j] = dq_captured_x4[j];
              `CFG.read_register_data(`DX0GSR2 + ( j * `DX_REG_RANGE), read_data);
              //regs.read($psprintf("DX%0dGSR2", j), read_data);                              
              dq_captured[j] = read_data[12];  
              if(sdram_width==4) begin
                dq_captured_x4[j] = read_data[16];
                if (previous_dq_x4[j] == 0 && dq_captured_x4[j] == 1) begin // found the left edge           
                  mrd_find_left_edge_x4[j]   = 1'b0;                       
                  mrd_find_right_edge_x4[j]  = 1'b1;                        
                  mrd_left_edge_cycle_x4[j]          = mrd_cycle;                   
                  mrd_left_edge_delay_x4[j]          = mrd_delay_aux;               
                  mrd_left_unit_x4[j]                = mrd_unit;  
                end                                                              
                else if ((previous_dq_x4[j] == 1 && dq_captured_x4[j] == 0) || (mrd_left_edge_cycle_x4[j] == 2 && mrd_unit == 154)) begin // found the right edge       
                  mrd_find_right_edge_x4[j]  = 1'b0;                        
                  mrd_right_edge_cycle_x4[j]         = mrd_cycle;                   
                  mrd_right_edge_delay_x4[j]         = mrd_delay_aux;              
                  mrd_right_unit_x4[j]               = mrd_unit;     
                end                                                              
                if (mrd_find_right_edge_x4[j] == 1'b0 && mrd_find_left_edge_x4[j] == 1'b0) begin     
                  mrd_find_left_edge_x4[j]   = 1'b1;                        
                  mrd_phase = (mrd_right_unit_x4[j] + mrd_left_unit_x4[j])/2;  
                  mrd_cycle = (mrd_phase / 31) - 2;   
                  mrd_phase =  mrd_phase % 31 - 15; 
                  mrd_phase_result[rank][j*2+1] = mrd_phase;                    
                  mrd_cycle_result[rank][j*2+1] = mrd_cycle;                    
                  mrd_byte_done_x4[j]       = 1'b1;                        
                end // if (mrd_find_right_edge == 1'b0 && mrd_find_left_edge == 1'b0) begin                
              end else begin
                mrd_byte_done_x4[j]       = 1'b1;
              end                                
              if (previous_dq[j] == 0 && dq_captured[j] == 1) begin // found the left edge            
                mrd_find_left_edge[j]   = 1'b0;                         
                mrd_find_right_edge[j]  = 1'b1;                        
                mrd_left_edge_cycle[j]          = mrd_cycle;                  
                mrd_left_edge_delay[j]          = mrd_delay_aux;              
                mrd_left_unit[j]                = mrd_unit;  
              end                                                               
              else if ((previous_dq[j] == 1 && dq_captured[j] == 0) || (mrd_left_edge_cycle[j] == 2 && mrd_unit == 154)) begin // found the right edge    
                mrd_find_right_edge[j]  = 1'b0;                        
                mrd_right_edge_cycle[j]         = mrd_cycle;                       
                mrd_right_edge_delay[j]         = mrd_delay_aux;               
                mrd_right_unit[j]               = mrd_unit;     
              end                                                              
              if (mrd_find_right_edge[j] == 1'b0 && mrd_find_left_edge[j] == 1'b0) begin      
                mrd_find_left_edge[j]   = 1'b1;                        
                mrd_phase = (mrd_right_unit[j] + mrd_left_unit[j])/2;  
                mrd_cycle = (mrd_phase / 31) - 2;   
                mrd_phase =  mrd_phase % 31 - 15; 
                if(sdram_width == 4) begin
                  mrd_phase_result[rank][j*2] = mrd_phase;                      
                  mrd_cycle_result[rank][j*2] = mrd_cycle;  
                end else begin                                                                                                         
                  mrd_phase_result[rank][j] = mrd_phase;                    
                  mrd_cycle_result[rank][j] = mrd_cycle;  
                end                                                 
                mrd_byte_done[j]       = 1'b1;                         
              end // if (mrd_find_right_edge == 1'b0 && mrd_find_left_edge == 1'b0) begin         
            end  // if (!((tb_cfg.dfi_byte_disable[j] == TRUE && (...)) == 0)) begin     
            else begin
              mrd_byte_done[j]       = 1'b1;
              mrd_byte_done_x4[j]    = 1'b1; 
            end            
          end // for (int j=0; j<`DWC_NO_OF_BYTES; j++) begin   

          if(&mrd_byte_done == 1 && &mrd_byte_done_x4 == 1)
            terminate = `TRUE;
          mrd_unit = mrd_unit + 1;                                                                            

        end // for (mrd_delay_aux = -15; mrd_delay_aux < 16; mrd_delay_aux++) begin              
      end // for (mrd_cycle=-2; mrd_cycle<3; mrd_cycle++) begin 

      if(terminate != `TRUE)
        $display("-> %0t: [BENCH]  Could not find cycle on MRD for rank %0d ! ", $time, rank);

      // Turn off MPR mode for Side A
      dcu_command     = `LOAD_MODE;
      dcu_dtp         = `DTP_tMOD;
      dcu_tag         = `DCU_NOTAG;
      dcu_rpt         = `DCU_NORPT;
      bank            = 3; // side A 4'b0011
      addr            = 13'h0;
      `CFG.load_dcu_command(dcu_rpt, dcu_dtp, dcu_tag, dcu_command, rank, bank, addr, mask, data);

      // Turn off MPR mode for Side B
      dcu_command     = `LOAD_MODE;
      dcu_dtp         = `DTP_tMOD;
      dcu_tag         = `DCU_NOTAG;
      dcu_rpt         = `DCU_NORPT;
      bank            = 11; // side B 4'b1011
      addr            = 13'h0;
      `CFG.load_dcu_command(dcu_rpt, dcu_dtp, dcu_tag, dcu_command, rank, bank, addr, mask, data);
      run_dcu_command(1);
    end      
    if(rank%2==1 && `DWC_RCD_MODE == `DIRECT_DUAL_CS || ( rank%4==3 && (`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS)) ) begin
      select_func_space(0, rank,  `DTP_tMOD);  
      // Turn OFF MRD training mode - Sending BCW F0BC0 0x0
      load_db_dq_register_4bit(8'h0c,4'h0, rank, `DTP_tMOD); 
      // Write Buffer Register F0BC07=0xe  (Set enable for Rank 0 only)
      load_db_dq_register_4bit(8'h07,4'h0, rank, `DTP_tMOD);
    end    
  end 

  // Write the results to DB through PBA
  // Commands should be sent through scheduler 
  // Set the chip to PUB mode
  `CFG.read_register_data(`PGCR1, reg_value);  //PUB Mode
  reg_value[6] =1;
  `CFG.write_register(`PGCR1, reg_value);
  repeat(100) @(posedge `SYS.clk);


  for(rank_no=0; rank_no < `DWC_NO_OF_RANKS; rank_no = rank_no+1) begin  
    rank = rank_no;
    
    if(`DWC_RCD_MODE == `DIRECT_DUAL_CS) begin
      device_rank = rank - rank%2;
    end else if(`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS) begin
      device_rank = rank - rank%4;
    end
    

    

    if(rank_disable[rank] == `FALSE) begin   

       `CFG.read_register_data(`MR3_REG, reg_value);

    
      if(`DWC_NO_OF_BYTES > 1 && (rank%2==0 && `DWC_RCD_MODE == `DIRECT_DUAL_CS || (rank%4==0 && (`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS)))) begin
        // Put the buffer into PBA mode - F0BC1x  0x01
        //load_db_dq_register_8bit(4'h1,8'h01, rank,  `DTP_tMOD);


        $display("Rank%d : Put the DRAM into PDA mode - MR3 A4=1 - Side A", rank);
        send_command_schcr(4'h1, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b00, {reg_value[20:5], 1'b1, reg_value[3:0]}, device_rank);

        $display("Rank%d : Put the DRAM into PDA mode - MR3 A4=1 - Side B", rank);
        send_command_schcr(4'h1, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b10, {reg_value[20:5], 1'b1, reg_value[3:0]}, device_rank);

        $display("Rank%d : Put the DB into PBA mode - F0BC1x with DA0=1", rank);
        send_command_schcr(4'h3, 4'h1, 4'h0, 18'h1FF, 1'b0, 2'b11, 2'b01, 20'h1101, device_rank);
      end
      
     
      for (j=0; j<`DWC_NO_OF_BYTES; j=j+1) begin
        `CFG.read_register_data(`DSGCR, reg_value);  //DSGCR.BDISEN
        `CFG.read_register_data(`DX0GCR0 + ( j * `DX_REG_RANGE), reg_value_1);  //DXnGCR0.DXEN
        //if(!((reg_value[1] == 1)  || reg_value_1[0] == 0)) begin
        if(!( reg_value_1[0] == 0)) begin
        //if (!((tb_cfg.dfi_byte_disable[j] == TRUE && regs.get_field("DSGCR", "BDISEN") == 1)  || regs.get_field($psprintf("DX%0dGCR0", j), "DXEN") == 0)) begin

           if (sdram_width ==4) begin
              case (j)
                0: schdqv= 18'h3FFFE;
                1: schdqv= 18'h3FFFB;
                2: schdqv= 18'h3FFEF;
                3: schdqv= 18'h3FFBF;
                4: schdqv= 18'h3FEFF;
                5: schdqv= 18'h3FBFF;
                6: schdqv= 18'h3EFFF;
                7: schdqv= 18'h3BFFF;
                8: schdqv= 18'h2FFFF;
              endcase
            end
            else begin
              case (j)
                0: schdqv= 18'h00FFE;
                1: schdqv= 18'h00FFD;
                2: schdqv= 18'h00FFB;
                3: schdqv= 18'h00FF7;
                4: schdqv= 18'h00FEF;
                5: schdqv= 18'h00FDF;
                6: schdqv= 18'h00FBF;
                7: schdqv= 18'h00F7F;
                8: schdqv= 18'h00EFF;
              endcase
            end  

          //select_func_space(rank%2, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD); 
          temp = rank %2;    
          send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b01, {16'h0170,temp}, device_rank);
          
          if(`DWC_RCD_MODE == `DIRECT_DUAL_CS || ((`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS) && rank%4 < 2))
            if(sdram_width == 4) begin
              // Program the cycle cycle result from MRD training - F0BCCx  (Rank 0 only)
              case (mrd_cycle_result[rank][j*2])
                -2: mrd_cycle_x4[3:0] = 4'h6;
                -1: mrd_cycle_x4[3:0] = 4'h5;
                 0: mrd_cycle_x4[3:0] = 4'h0;
                 1: mrd_cycle_x4[3:0] = 4'h1;
                 2: mrd_cycle_x4[3:0] = 4'h2;
              endcase
              case (mrd_cycle_result[rank][j*2+1])
                -2: mrd_cycle_x4[7:4] = 4'h6;
                -1: mrd_cycle_x4[7:4] = 4'h5;
                 0: mrd_cycle_x4[7:4] = 4'h0;
                 1: mrd_cycle_x4[7:4] = 4'h1;
                 2: mrd_cycle_x4[7:4] = 4'h2;
              endcase
              //load_db_dq_register_8bit(4'hc,mrd_cycle_x4, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD);              
              send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h1c,mrd_cycle_x4}, device_rank);
            end else begin
              // Program the cycle cycle result from MRD training - F0BCCx  (Rank 0 only)
              case (mrd_cycle_result[rank][j])
                //-2: load_db_dq_register_8bit(4'hc,8'h66, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD);
                -2: send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h1c,8'h66}, device_rank);
                //-1: load_db_dq_register_8bit(4'hc,8'h55, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD); 
                -1: send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h1c,8'h55}, device_rank);
                //0: load_db_dq_register_8bit(4'hc,8'h00, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD);
                 0: send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h1c,8'h00}, device_rank);
                // 1: load_db_dq_register_8bit(4'hc,8'h11, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD);
                 1: send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h1c,8'h11}, device_rank);
                // 2: load_db_dq_register_8bit(4'hc,8'h22, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD);
                 2: send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h1c,8'h22}, device_rank);
              endcase            
            end
          else
            if(sdram_width == 4) begin
              // Program the cycle cycle result from MRD training - F0BCCx  (Rank 0 only)
              case (mrd_cycle_result[rank][j*2])
                -2: mrd_cycle_x4[3:0] = 4'h6;
                -1: mrd_cycle_x4[3:0] = 4'h5;
                 0: mrd_cycle_x4[3:0] = 4'h0;
                 1: mrd_cycle_x4[3:0] = 4'h1;
                 2: mrd_cycle_x4[3:0] = 4'h2;
              endcase
              case (mrd_cycle_result[rank][j*2+1])
                -2: mrd_cycle_x4[7:4] = 4'h6;
                -1: mrd_cycle_x4[7:4] = 4'h5;
                 0: mrd_cycle_x4[7:4] = 4'h0;
                 1: mrd_cycle_x4[7:4] = 4'h1;
                 2: mrd_cycle_x4[7:4] = 4'h2;
              endcase
              //load_db_dq_register_8bit(4'he,mrd_cycle_x4, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD);  
              send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h1e,mrd_cycle_x4}, device_rank);
            end else begin
              // Program the cycle cycle result from MRD training - F0BCCx  (Rank 0 only)
              case (mrd_cycle_result[rank][j])
                //-2: load_db_dq_register_8bit(4'he,8'h66, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD);
                -2: send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h1e,8'h66}, device_rank);

                //-1: load_db_dq_register_8bit(4'he,8'h55, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD); 
                -1: send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h1e,8'h55}, device_rank);

                // 0: load_db_dq_register_8bit(4'he,8'h00, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD);
                 0: send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h1e,8'h00}, device_rank);

                // 1: load_db_dq_register_8bit(4'he,8'h11, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD);
                 1: send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h1e,8'h11}, device_rank);

                // 2: load_db_dq_register_8bit(4'he,8'h22, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD);
                 2: send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h1e,8'h22}, device_rank);
              endcase 
            end         
          
          if(`DWC_RCD_MODE == `DIRECT_DUAL_CS) begin
            //select_func_space(rank%2, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD); 
            temp = rank %2;
            send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b01, {16'h0170,temp}, device_rank);
          end else if(`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS) begin
            //select_func_space(rank%4, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD);
            temp = rank %4;
            send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b01, {16'h0170,temp}, device_rank);
          end 
          
          if(sdram_width == 4) begin
            // Set Host side DQ=0 on buffer0 for PBA access to buffer 0 only (DQS0 and DQS9) - F0BC2x  0xAC +33phase
            //pda_mode = TRUE;
            //load_db_dq_register_8bit(4'h4,mrd_phase_result[rank][j*2], rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD);
            send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h14,mrd_phase_result[rank][j*2]}, device_rank);

            // Set Host side DQ=0 on buffer0 for PBA access to buffer 0 only (DQS0 upper) - F0BC3x  0xB1 +33phase
            //load_db_dq_register_8bit(4'h5,mrd_phase_result[rank][j*2+1], rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD);          
            send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h15,mrd_phase_result[rank][j*2+1]}, device_rank);
          
          end else begin
            // Set Host side DQ=0 on buffer0 for PBA access to buffer 0 only (DQS0 and DQS9) - F0BC2x  0xAC +33phase
            //pda_mode = TRUE;
            //load_db_dq_register_8bit(4'h4,mrd_phase_result[rank][j], rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD);
            send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h14,mrd_phase_result[rank][j]}, device_rank);

            // Set Host side DQ=0 on buffer0 for PBA access to buffer 0 only (DQS0 upper) - F0BC3x  0xB1 +33phase
            //load_db_dq_register_8bit(4'h5,mrd_phase_result[rank][j], rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD);
            send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h15,mrd_phase_result[rank][j]}, device_rank);
          end
        end
      end
    end
  end
  
  for(rank_no=0; rank_no < `DWC_NO_OF_RANKS; rank_no = rank_no+1) begin    
    rank = rank_no;

    if(`DWC_RCD_MODE == `DIRECT_DUAL_CS) begin
      device_rank = rank - rank%2;
    end else if(`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS) begin
      device_rank = rank - rank%4;
    end

    if(rank_disable[rank] == `FALSE) begin   
  
      //if(`DWC_NO_OF_BYTES > 1) begin
      if(`DWC_NO_OF_BYTES > 1 && (rank%2==0 && `DWC_RCD_MODE == `DIRECT_DUAL_CS || (rank%4==0 && (`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS)))) begin   

      

        // Select Func Space 0
        //select_func_space(0, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD);        
        send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b01, {20'h01700}, device_rank);

        // Take the buffer out of PBA mode
        //load_db_dq_register_8bit(4'h1,8'h00, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD);    
        
        `CFG.read_register_data(`MR3_REG, reg_value);

        $display("Rank%d : Exit the DB from PBA mode - F0BC1x with DA0=0", rank);
        send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b01, 20'h1100, device_rank);


        $display("Rank%d : Put the DB into PDA mode - F0BC1x with DA2=1", rank);
        send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b01, 20'h1104, device_rank);
 

        $display("Rank%d : Exit the DRAM from PDA mode - MR3 A4=0 - Side A", rank);
        send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b00, {reg_value[20:5], 1'b0, reg_value[3:0]}, device_rank);
 

        $display("Rank%d : Exit the DRAM from PDA mode - MR3 A4=0 - Side B", rank);
        send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b10, {reg_value[20:5], 1'b0, reg_value[3:0]}, device_rank);


        $display("Rank%d : Exit the DB from PDA mode - F0BC1x with DA2=0", rank);
        send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b01, 20'h1100, device_rank);

      end
    end
  end


   // Exit the chip from PUB mod
  `CFG.read_register_data(`PGCR1, reg_value);  //PUB Mode
  reg_value[6] =0;
  `CFG.write_register(`PGCR1, reg_value);
  repeat(100) @(posedge `SYS.clk); 

  mrd_train = 1'b0;   
    
endtask





//============================================================================================
//  new do_mwd_training() - Runs LRDIMM MWD training
//============================================================================================
task do_mwd_training;
  reg [`CMD_WIDTH-1 :0] dcu_command;   
  reg [`SDRAM_RANK_WIDTH-1:0] rank;
  reg [`SDRAM_RANK_WIDTH-1:0] device_rank;
  integer rank_no;
  //reg [`SDRAM_BANK_WIDTH-1:0] bank;
  reg [`DWC_PHY_BG_WIDTH + `DWC_PHY_BA_WIDTH  -1:0] bank;
  reg [12  :0] addr;
  reg [`DCU_RPT_WIDTH-1 :0] dcu_rpt;
  reg [`DCU_DTP_WIDTH-1 :0] dcu_dtp;
  reg [`DCU_TAG_WIDTH-1 :0] dcu_tag;
  reg [`PUB_DQS_WIDTH    - 1 : 0] mask={`PUB_DQS_WIDTH{`DDR_MASK_OFF}};
  reg [`DCU_DATA_WIDTH- 1 :0] data=`PUB_DATA_0000_0000;
  
  reg [pNUM_LANES -1:0]       dq_captured    = '0;
  reg [pNUM_LANES -1:0]       previous_dq    = '0;
  reg [pNUM_LANES -1:0]       dq_captured_x4 = '0;
  reg [pNUM_LANES -1:0]       previous_dq_x4 = '0;  
  reg [3:0] rank_en = 4'hf;  
  reg [31:0] read_data;
  reg [3:0]  mwd_delay;
  integer        mwd_left_edge_cycle[`DWC_NO_OF_BYTES-1 :0];
  integer        mwd_left_edge_delay[`DWC_NO_OF_BYTES-1 :0];
  integer        mwd_right_edge_cycle[`DWC_NO_OF_BYTES-1 :0];
  integer        mwd_right_edge_delay[`DWC_NO_OF_BYTES-1 :0];
  integer        mwd_left_unit[`DWC_NO_OF_BYTES-1 :0];
  integer        mwd_right_unit[`DWC_NO_OF_BYTES-1 :0];
  integer        mwd_left_edge_cycle_x4[`DWC_NO_OF_BYTES-1 :0];
  integer        mwd_left_edge_delay_x4[`DWC_NO_OF_BYTES-1 :0];
  integer        mwd_right_edge_cycle_x4[`DWC_NO_OF_BYTES-1 :0];
  integer        mwd_right_edge_delay_x4[`DWC_NO_OF_BYTES-1 :0];
  integer        mwd_left_unit_x4[`DWC_NO_OF_BYTES-1 :0];
  integer        mwd_right_unit_x4[`DWC_NO_OF_BYTES-1 :0];
  reg        mwd_find_right_edge[`DWC_NO_OF_BYTES-1 :0]; 
  reg        mwd_find_left_edge[`DWC_NO_OF_BYTES-1 :0];  
  reg        mwd_find_right_edge_x4[`DWC_NO_OF_BYTES-1 :0]; 
  reg        mwd_find_left_edge_x4[`DWC_NO_OF_BYTES-1 :0];       
  reg [`DWC_NO_OF_BYTES-1:0] mwd_byte_done;   
  reg [`DWC_NO_OF_BYTES-1:0] mwd_byte_done_x4; 
  reg[7:0] mwd_cycle_x4;       
  integer        mwd_phase = 0;
  integer        mwd_unit  = 0;
  integer       mwd_cycle = 0;
  integer       mwd_delay_aux = 0;
  reg terminate  = `FALSE;       
  integer i;
  integer j;
  reg [31:0] reg_value;
  reg [31:0] reg_value_1;
  reg [3:0] temp;
  reg [17:0] schdqv;
   
  mwd_train = 1'b1;
  `CFG.disable_read_compare;
   
  //for(j=0;j<`DWC_NO_OF_RANKS;j=j+1) begin
  //  for(i=0;i<pNUM_LANES;i=i+1) begin
  //    mwd_phase_result[j][i] = 0;
  //    mwd_cycle_result[j][i] = 0;
  //  end
  //end
  
  
  for(rank_no=0; rank_no < `DWC_NO_OF_RANKS; rank_no = rank_no +1) begin
    rank = rank_no;
    if(rank_disable[rank] == `FALSE) begin   
      terminate = `FALSE;
      rank_en = 4'hf;
      if(`DWC_RCD_MODE == `DIRECT_DUAL_CS) begin
        rank_en[rank%2] = 1'h0;
      end else if(`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS) begin
        rank_en[rank%4] = 1'h0;
      end  
      previous_dq    = 0;
      dq_captured    = 0; 
      previous_dq_x4 = 0;
      dq_captured_x4 = 0;       

      for (j=0; j<`DWC_NO_OF_BYTES; j=j+1) begin
        mwd_byte_done[j] = 1'b0;
        mwd_find_right_edge[j] = 1'b1;
        mwd_find_left_edge[j]  = 1'b0;
        mwd_byte_done_x4[j] = 1'b0;
        mwd_find_right_edge_x4[j] = 1'b1;
        mwd_find_left_edge_x4[j]  = 1'b0;        
      end       

      // Select Func Space 0  
      select_func_space(0, rank,  `DTP_tMOD);  

      if(`DWC_RCD_MODE == `DIRECT_DUAL_CS) begin
        device_rank = rank - rank%2;
      end else if(`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS) begin
        device_rank = rank - rank%4;
      end

      if(rank%2==0 && `DWC_RCD_MODE == `DIRECT_DUAL_CS || ( rank%4==0 && (`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS)) ) begin 
        if(`DWC_NO_OF_BYTES > 1) begin
          // Put the buffer into PBA mode - F0BC1x  0x01
          //load_db_dq_register_8bit(4'h1,8'h01, rank, `DTP_tMOD);
          
          
          // Set the chip to PUB mode
          `CFG.read_register_data(`PGCR1, reg_value);  //PUB Mode
          reg_value[6] =1;
          `CFG.write_register(`PGCR1, reg_value);

          repeat(100) @(posedge `SYS.clk); 
    
          `CFG.read_register_data(`MR3_REG, reg_value);

          $display("Rank%d : Put the DRAM into PDA mode - MR3 A4=1 - Side A", rank);
          send_command_schcr(4'h1, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b00, {reg_value[20:5], 1'b1, reg_value[3:0]}, device_rank);

          $display("Rank%d : Put the DRAM into PDA mode - MR3 A4=1 - Side B", rank);
          send_command_schcr(4'h1, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b10, {reg_value[20:5], 1'b1, reg_value[3:0]}, device_rank);

          $display("Rank%d : Put the DB into PBA mode - F0BC1x with DA0=1", rank);
          send_command_schcr(4'h3, 4'h1, 4'h0, 18'h1FF, 1'b0, 2'b11, 2'b01, 20'h1101, device_rank);



        end


        schdqv = 18'h00000;


        for (i=0; i<`DWC_NO_OF_BYTES; i=i+1) begin   
          $display("Byte %d", i);
          `CFG.read_register_data(`DSGCR, reg_value);  //DSGCR.BDISEN
          `CFG.read_register_data(`DX0GCR0 + ( i * `DX_REG_RANGE), reg_value_1);  //DXnGCR0.DXEN
          //if(!((reg_value[1] == 1)  || reg_value_1[0] == 0)) begin  
          if(!( reg_value_1[0] == 0)) begin  
          //if (!((tb_cfg.dfi_byte_disable[i] == TRUE && regs.get_field("DSGCR", "BDISEN") == 1)  || regs.get_field($psprintf("DX%0dGCR0", i), "DXEN") == 0)) begin

            if (sdram_width ==4) begin
              case (i)
                0: schdqv= 18'h3FFFE;
                1: schdqv= 18'h3FFFB;
                2: schdqv= 18'h3FFEF;
                3: schdqv= 18'h3FFBF;
                4: schdqv= 18'h3FEFF;
                5: schdqv= 18'h3FBFF;
                6: schdqv= 18'h3EFFF;
                7: schdqv= 18'h3BFFF;
                8: schdqv= 18'h2FFFF;
              endcase
              end 
            else begin
              case (i)
                0: schdqv= 18'h00FFE;
                1: schdqv= 18'h00FFD;
                2: schdqv= 18'h00FFB;
                3: schdqv= 18'h00FF7;
                4: schdqv= 18'h00FEF;
                5: schdqv= 18'h00FDF;
                6: schdqv= 18'h00FBF;
                7: schdqv= 18'h00F7F;
                8: schdqv= 18'h00EFF;
              endcase
            end

            // Load 0x2B into the Data Buffer MPR
            // Select Func Space 5   
            //select_func_space(5, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD);       
            send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b01, {20'h01705}, device_rank);

            // Sending BCW F5BC0x 0x00   MPR0
            //load_db_dq_register_8bit(4'h0,8'h00, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD);     
            send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h10,8'h00}, device_rank);

            // Sending BCW F5BC1x 0x00   MPR1
            //load_db_dq_register_8bit(4'h1,8'h00, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD);        
            send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h11,8'h00}, device_rank);

            if(sdram_width == 4 && rdimm_addr_inv == `TRUE) begin
              // Sending BCW F5BC2x 0xFF   MPR2 
              //load_db_dq_register_8bit(4'h2,8'h0f, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD);
              send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h12,8'h0f}, device_rank);

              // Sending BCW F5BC3x 0x00   MPR3 
              //load_db_dq_register_8bit(4'h3,8'h0f, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD);
              send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h13,8'h0f}, device_rank);
            end else begin
              // Sending BCW F5BC2x 0xFF   MPR2 
              //load_db_dq_register_8bit(4'h2,(pda_device%2==0 || rdimm_addr_inv == `FALSE)?8'hff:8'h00, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD);
              send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h12,(i%2==0 || rdimm_addr_inv == `FALSE)?8'hff:8'h00}, device_rank);

              // Sending BCW F5BC3x 0x00   MPR3 
              //load_db_dq_register_8bit(4'h3,(pda_device%2==0 || rdimm_addr_inv == `FALSE)?8'hff:8'h00, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD);
              send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h13,(i%2==0 || rdimm_addr_inv == `FALSE)?8'hff:8'h00}, device_rank);
            end

            // Select Func Space 6   
            //select_func_space(6, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD);         
            send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b01, {20'h01706}, device_rank);

            if(sdram_width == 4 && rdimm_addr_inv == `TRUE) begin   
              // Sending BCW F6BC0x 0xFF   MPR0
              //load_db_dq_register_8bit(4'h0,8'hf0, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD);  
              send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h10,8'h00}, device_rank);

              // Sending BCW F6BC1x 0x00   MPR1
              //load_db_dq_register_8bit(4'h1,8'hf0, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD);                             
              send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h11,8'h00}, device_rank);
            end else begin
              // Sending BCW F6BC0x 0xFF   MPR0
              //load_db_dq_register_8bit(4'h0,(pda_device%2==0 || rdimm_addr_inv == `FALSE)?8'h00:8'hff, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD);  
              send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h10,(i%2==0 || rdimm_addr_inv == `FALSE)?8'h00:8'hff}, device_rank);

              // Sending BCW F6BC1x 0x00   MPR1
              //load_db_dq_register_8bit(4'h1,(pda_device%2==0 || rdimm_addr_inv == `FALSE)?8'h00:8'hff, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD); 
              send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h11,(i%2==0 || rdimm_addr_inv == `FALSE)?8'h00:8'hff}, device_rank);
            end              

            // Sending BCW F6BC2x 0xFF   MPR2 
            //load_db_dq_register_8bit(4'h2,8'hff, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD);        
            send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h12,8'hff}, device_rank);

            // Sending BCW F6BC3x 0xFF   MPR3  
            //load_db_dq_register_8bit(4'h3,8'hff, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD); 
            send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h13,8'hff}, device_rank);
          end

        end

        if(`DWC_NO_OF_BYTES > 1) begin

          // Select Func Space 0  
          //select_func_space(0, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD);     
          send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b01, {20'h01700}, device_rank);

          // Take the buffer out of PBA mode
          //load_db_dq_register_8bit(4'h1,8'h00, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD);    
          `CFG.read_register_data(`MR3_REG, reg_value);
    
          $display("Rank%d : Exit the DB from PBA mode - F0BC1x with DA0=0", rank);
          send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b01, 20'h1100, device_rank);


          $display("Rank%d : Put the DB into PDA mode - F0BC1x with DA2=1", rank);
          send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b01, 20'h1104, device_rank);
 

          $display("Rank%d : Exit the DRAM from PDA mode - MR3 A4=0 - Side A", rank);
          send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b00, {reg_value[20:5], 1'b0, reg_value[3:0]}, device_rank);
 

          $display("Rank%d : Exit the DRAM from PDA mode - MR3 A4=0 - Side B", rank);
          send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b10, {reg_value[20:5], 1'b0, reg_value[3:0]}, device_rank);


          $display("Rank%d : Exit the DB from PDA mode - F0BC1x with DA2=0", rank);
          send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b01, 20'h1100, device_rank);

          send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b01, {20'h01700}, device_rank);

        end else begin
          // Select Func Space 0  
          //select_func_space(0, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD); 
          send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b01, {20'h01700}, device_rank);
        end
      end

        // Exit the chip from PUB mode

       `CFG.read_register_data(`PGCR1, reg_value);  //PUB Mode
       reg_value[6] =0;
       `CFG.write_register(`PGCR1, reg_value);  
       repeat(100) @(posedge `SYS.clk); 




      // Write Buffer Register F0BC07=0xe  (Set enable for Rank 0 only)
      load_db_dq_register_4bit(8'h07,rank_en, rank,  `DTP_tMOD);

      if(rank%2==0 && `DWC_RCD_MODE == `DIRECT_DUAL_CS || ( rank%4==0 && (`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS)) ) begin
        // Write Buffer Register F0BC0C=0x7  (Set MWD)
        load_db_dq_register_4bit(8'h0c,4'h7, rank, `DTP_tMOD);   
        for (j=0; j<`DWC_NO_OF_BYTES; j=j+1) begin
          `GRM.dxngcr2[j][31:16] = 16'haaaa;   //DXTEMODE
          `CFG.write_register(`DX0GCR2 + ( j * `DX_REG_RANGE), `GRM.dxngcr2[j]);
          //regs.set_field($psprintf("DX%0dGCR2", j),"DXOEMODE", 16'haaaa); 
          //regs.flush($psprintf("DX%0dGCR2", j));
        end  
      end

      // loop with 5 steps... Trying cycle with values -2,-1,0,+1,+2 
      for (mwd_cycle=-2; mwd_cycle<3; mwd_cycle=mwd_cycle +1) begin  

        if ( terminate == `TRUE )
          break;                                                                                                                                                                                                    
          
        select_func_space(rank%2, rank, `DTP_tWR2RD); 
                                                                                                                                                 
        if(`DWC_RCD_MODE == `DIRECT_DUAL_CS || ((`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS) && rank%4 < 2))
          // Program the cycle bit to negative 2 for the MRD search  - F0BCCx  0xii (Rank 0 only)
          case (mwd_cycle)                                     
            -2: begin load_db_dq_register_8bit(4'hd,8'h66, rank, `DTP_tMOD); mwd_unit = 0; end  
            -1: load_db_dq_register_8bit(4'hd,8'h55, rank,  `DTP_tMOD);    
             0: load_db_dq_register_8bit(4'hd,8'h00, rank,  `DTP_tMOD);    
             1: load_db_dq_register_8bit(4'hd,8'h11, rank,  `DTP_tMOD);    
             2: load_db_dq_register_8bit(4'hd,8'h22, rank,  `DTP_tMOD);    
          endcase  
        else
          // Program the cycle bit to negative 2 for the MRD search  - F0BCCx  0xii (Rank 0 only)
          case (mwd_cycle)                                     
            -2: begin load_db_dq_register_8bit(4'hf,8'h66, rank,  `DTP_tMOD); mwd_unit = 0; end  
            -1: load_db_dq_register_8bit(4'hf,8'h55, rank,  `DTP_tMOD);    
             0: load_db_dq_register_8bit(4'hf,8'h00, rank,  `DTP_tMOD);    
             1: load_db_dq_register_8bit(4'hf,8'h11, rank,  `DTP_tMOD);    
             2: load_db_dq_register_8bit(4'hf,8'h22, rank,  `DTP_tMOD);    
          endcase          
        
        if(`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS) begin
          select_func_space(rank%4, rank,  `DTP_tWR2RD);
        end                                                                                                      

        // STEP #4                                                                                                                                       
        // set MDQS Read delay to -15 (signal is in the addr load cmds)              
        mwd_delay = 4'hf;                                                      

        // -15 to 0 to +15 read delay trough F0BC4x and F0BC5x                  
        for (mwd_delay_aux = -15; mwd_delay_aux < 16; mwd_delay_aux++) begin   
          if ( terminate == `TRUE )
            break;

          // decrement negative delay (-15 to -1)                              
          if (mwd_delay_aux < 0) begin       

            // Write Buffer Register F0BC8x=0xi
            load_db_dq_register_8bit(4'h8,{1'b1,mwd_delay}, rank, `DTP_tMOD);

            // Write Buffer Register F0BC8x=0xi
            load_db_dq_register_8bit(4'h9,{1'b1,mwd_delay}, rank,  `DTP_tMOD);

            // Send ACT
            dcu_command     = `ACTIVATE;
            dcu_dtp         = `DTP_tACT2RW;
            dcu_tag         = `DCU_NOTAG;
            dcu_rpt         = `DCU_NORPT;
            `CFG.read_register_data(`DTAR0, reg_value);
            //bank            = reg_value[27:24];  //DTAR0.DTBGBK1
            bank            = 4'b0001;  //DTAR0.DTBGBK1
            //bank            = regs.get_field("DTAR0", "DTBGBK1");
            addr            = {reg_value[17:0], 3'b000};    //? width out of range
            //addr            = {regs.get_field("DTAR0", "DTROW"), 3'b000};
            `CFG.load_dcu_command(dcu_rpt, dcu_dtp, dcu_tag, dcu_command, rank, bank, addr, mask, data);
            run_dcu_command(0);



            // Send Write
            dcu_command     = `SDRAM_WRITE;
            dcu_dtp         = `DTP_tWR2RD;
            dcu_tag         = `DCU_NOTAG;
            dcu_rpt         = `DCU_NORPT;
            //bank            = regs.get_field("DTAR0", "DTBGBK1");
            //bank            = reg_value[27:24];
            bank            = 4'b0001;  //DTAR0.DTBGBK1
            //addr            = {regs.get_field("DTAR1", "DTCOL0"), 3'b000};
            `CFG.read_register_data(`DTAR1, reg_value);
            addr            = {reg_value[8:0], 3'b000};
            `CFG.load_dcu_command(dcu_rpt, dcu_dtp, dcu_tag, dcu_command, rank, bank, addr, mask, data);
            run_dcu_command(0);


            // Send Read
            dcu_command     = `SDRAM_READ;
            dcu_dtp         = `DTP_tRD2PRE;
            dcu_tag         = `DCU_NOTAG;
            dcu_rpt         = `DCU_NORPT;
            //bank            = regs.get_field("DTAR0", "DTBGBK1");
            `CFG.read_register_data(`DTAR0, reg_value);
            //bank            = reg_value[27:24];
            bank            = 4'b0001;  //DTAR0.DTBGBK1
            //addr            = {regs.get_field("DTAR1", "DTCOL0"), 3'b000};
            `CFG.read_register_data(`DTAR1, reg_value);
            addr            = {reg_value[8:0], 3'b000};
            `CFG.load_dcu_command(dcu_rpt, dcu_dtp, dcu_tag, dcu_command, rank, bank, addr, mask, data);
            run_dcu_command(0);

            // Send Precharge
            dcu_command     = `PRECHARGE;
            dcu_dtp         = `DTP_tRP;
            dcu_tag         = `DCU_NOTAG;
            dcu_rpt         = `DCU_NORPT;
            //bank            = regs.get_field("DTAR0", "DTBGBK1");
            `CFG.read_register_data(`DTAR0, reg_value);
            //bank            = reg_value[27:24];
            bank            = 4'b0001;  //DTAR0.DTBGBK1
            //addr            = {regs.get_field("DTAR1", "DTCOL0"), 3'b000};
            `CFG.read_register_data(`DTAR1, reg_value);
            addr            = {reg_value[8:0], 3'b000};
            `CFG.load_dcu_command(dcu_rpt, dcu_dtp, dcu_tag, dcu_command, rank, bank, addr, mask, data);
            run_dcu_command(0);
            // decrement negative delay                                        
            mwd_delay = mwd_delay-1; 
            //run_dcu_command(3);
          end
          else begin                                                                                                                                          

            // Write Buffer Register F0BC8x=0xi
            load_db_dq_register_8bit(4'h8,{1'b0,mwd_delay}, rank,  `DTP_tMOD);

            // Write Buffer Register F0BC8x=0xi
            load_db_dq_register_8bit(4'h9,{1'b0,mwd_delay}, rank,  `DTP_tMOD);

            // Send ACT
            dcu_command     = `ACTIVATE;
            dcu_dtp         = `DTP_tACT2RW;
            dcu_tag         = `DCU_NOTAG;
            dcu_rpt         = `DCU_NORPT;
            //bank            = regs.get_field("DTAR0", "DTBGBK1");
            `CFG.read_register_data(`DTAR0, reg_value);
            //bank            = reg_value[27:24];
            bank            = 4'b0001;  //DTAR0.DTBGBK1
            //addr            = {regs.get_field("DTAR0", "DTROW"), 3'b000};
            addr            = {reg_value[17:0], 3'b000};    //? width out of range
            `CFG.load_dcu_command(dcu_rpt, dcu_dtp, dcu_tag, dcu_command, rank, bank, addr, mask, data);
            run_dcu_command(0);


            // Send Write
            dcu_command     = `SDRAM_WRITE;
            dcu_dtp         = `DTP_tWR2RD;
            dcu_tag         = `DCU_NOTAG;
            dcu_rpt         = `DCU_NORPT;
            //bank            = regs.get_field("DTAR0", "DTBGBK1");
            `CFG.read_register_data(`DTAR0, reg_value);
            //bank            = reg_value[27:24];
            bank            = 4'b0001;  //DTAR0.DTBGBK1
            //addr            = {regs.get_field("DTAR1", "DTCOL0"), 3'b000};
            `CFG.read_register_data(`DTAR1, reg_value);
            addr            = {reg_value[8:0], 3'b000};
            `CFG.load_dcu_command(dcu_rpt, dcu_dtp, dcu_tag, dcu_command, rank, bank, addr, mask, data);
            run_dcu_command(0);


            // Send Read
            dcu_command     = `SDRAM_READ;
            dcu_dtp         = `DTP_tRD2PRE;
            dcu_tag         = `DCU_NOTAG;
            dcu_rpt         = `DCU_NORPT;
            //bank            = regs.get_field("DTAR0", "DTBGBK1");
            `CFG.read_register_data(`DTAR0, reg_value);
            //bank            = reg_value[27:24];
            bank            = 4'b0001;  //DTAR0.DTBGBK1
            //addr            = {regs.get_field("DTAR1", "DTCOL0"), 3'b000};
            `CFG.read_register_data(`DTAR1, reg_value);
            addr            = {reg_value[8:0], 3'b000};
            `CFG.load_dcu_command(dcu_rpt, dcu_dtp, dcu_tag, dcu_command, rank, bank, addr, mask, data);
            run_dcu_command(0);

            // Send Precharge
            dcu_command     = `PRECHARGE;
            dcu_dtp         = `DTP_tRP;
            dcu_tag         = `DCU_NOTAG;
            dcu_rpt         = `DCU_NORPT;
            //bank            = regs.get_field("DTAR0", "DTBGBK1");
            `CFG.read_register_data(`DTAR0, reg_value);
            //bank            = reg_value[27:24];
            bank            = 4'b0001;  //DTAR0.DTBGBK1
            //addr            = {regs.get_field("DTAR1", "DTCOL0"), 3'b000};
            `CFG.read_register_data(`DTAR1, reg_value);
            addr            = {reg_value[8:0], 3'b000};
            `CFG.load_dcu_command(dcu_rpt, dcu_dtp, dcu_tag, dcu_command, rank, bank, addr, mask, data);
            run_dcu_command(0);

            // increment positive delay                                                      
            mwd_delay = mwd_delay+1;     
            run_dcu_command(3);
          end

          repeat (30) @(posedge `SYS.clk); //Wait some clocks to get data on DXNGSR2.DBDQ                                                                     

          for (j=0; j<`DWC_NO_OF_BYTES; j=j+1) begin                                          
            `CFG.read_register_data(`DSGCR, reg_value);  //DSGCR.BDISEN
            `CFG.read_register_data(`DX0GCR0 + ( j * `DX_REG_RANGE), reg_value_1);  //DXnGCR0.DXEN
            //if(!((reg_value[1] == 1)  || reg_value_1[0] == 0)) begin  
            if(! (reg_value_1[0] == 0)) begin  
            //if (!((tb_cfg.dfi_byte_disable[j] == TRUE && regs.get_field("DSGCR", "BDISEN") == 1)  || regs.get_field($psprintf("DX%0dGCR0", j), "DXEN") == 0)) begin     
              previous_dq[j]    = dq_captured[j];
              previous_dq_x4[j] = dq_captured_x4[j];                                                                    
              `CFG.read_register_data(`DX0GSR2 + ( j * `DX_REG_RANGE), read_data);  //DXnGCR0.DXEN
              //regs.read($psprintf("DX%0dGSR2", j), read_data);                        
              dq_captured[j] = read_data[12]; 
              if(sdram_width == 4) begin
                dq_captured_x4[j] = read_data[16];
                if (previous_dq_x4[j] == 0 && dq_captured_x4[j] == 1) begin // found the left edge         
                  mwd_find_left_edge_x4[j]   = 1'b0;                                      
                  mwd_find_right_edge_x4[j]  = 1'b1;                           
                  mwd_left_edge_cycle_x4[j]          = mwd_cycle;                      
                  mwd_left_edge_delay_x4[j]          = mwd_delay_aux;                   
                  mwd_left_unit_x4[j]                = mwd_unit; 
                end                                                                 
                else if (previous_dq_x4[j] == 1 && dq_captured_x4[j] == 0 || (mwd_left_edge_cycle_x4[j] == 2 && mwd_unit == 154)) begin // found the right edge   
                  mwd_find_right_edge_x4[j]  = 1'b0;                          
                  mwd_right_edge_cycle_x4[j]         = mwd_cycle;                      
                  mwd_right_edge_delay_x4[j]         = mwd_delay_aux;                   
                  mwd_right_unit_x4[j]               = mwd_unit;   
                end                                                                      
                if (mwd_find_right_edge_x4[j] == 1'b0 && mwd_find_left_edge_x4[j] == 1'b0) begin      
                  mwd_find_left_edge_x4[j]   = 1'b1;                                        
                  mwd_phase = (mwd_right_unit_x4[j] + mwd_left_unit_x4[j])/2;  
                  mwd_cycle = (mwd_phase / 31) - 2;   
                  mwd_phase =  mwd_phase % 31 - 15; 
                  mwd_phase_result[rank][j*2+1] = mwd_phase;                       
                  mwd_cycle_result[rank][j*2+1] = mwd_cycle;                       
                  mwd_byte_done_x4[j]       = 1'b1;                            
                end   // if (mwd_find_right_edge == 1'b0 && mwd_find_left_edge == 1'b0) begin               
              end else begin
                mwd_byte_done_x4[j]    = 1'b1;
              end                                   
              if (previous_dq[j] == 0 && dq_captured[j] == 1) begin // found the left edge       
                mwd_find_left_edge[j]   = 1'b0;                           
                mwd_find_right_edge[j]  = 1'b1;                          
                mwd_left_edge_cycle[j]          = mwd_cycle;                      
                mwd_left_edge_delay[j]          = mwd_delay_aux;                   
                mwd_left_unit[j]                = mwd_unit; 
              end                                                                  
              else if (previous_dq[j] == 1 && dq_captured[j] == 0 || (mwd_left_edge_cycle[j] == 2 && mwd_unit == 154)) begin // found the right edge       
                mwd_find_right_edge[j]  = 1'b0;                          
                mwd_right_edge_cycle[j]         = mwd_cycle;                      
                mwd_right_edge_delay[j]         = mwd_delay_aux;                  
                mwd_right_unit[j]               = mwd_unit;   
              end                                                                 
              if (mwd_find_right_edge[j] == 1'b0 && mwd_find_left_edge[j] == 1'b0) begin      
                mwd_find_left_edge[j]   = 1'b1;                                          
                mwd_phase = (mwd_right_unit[j] + mwd_left_unit[j])/2;  
                mwd_cycle = (mwd_phase / 31) - 2;   
                mwd_phase =  mwd_phase % 31 - 15; 
                if(sdram_width == 4) begin
                  mwd_phase_result[rank][j*2] = mwd_phase;                      
                  mwd_cycle_result[rank][j*2] = mwd_cycle;
                end else begin                                                                                                            
                  mwd_phase_result[rank][j] = mwd_phase;                       
                  mwd_cycle_result[rank][j] = mwd_cycle;
                end                      
                mwd_byte_done[j]       = 1'b1;                                      
              end   // if (mwd_find_right_edge == 1'b0 && mwd_find_left_edge == 1'b0) begin                                                    
            end   // if (!((tb_cfg.dfi_byte_disable[j] == TRUE && (...)) == 0)) begin 
            else
              mwd_byte_done[j]       = 1'b1;  
              mwd_byte_done_x4[j]    = 1'b1;                      
          end   // for (int j=0; j<`DWC_NO_OF_BYTES; j++) begin     

          if(&mwd_byte_done == 1 && &mwd_byte_done_x4 == 1)
            terminate = `TRUE; 
          mwd_unit = mwd_unit + 1; 

        end  // for (mwd_delay_aux = -15; mwd_delay_aux < 16; mwd_delay_aux++) begin    
      end   // for (mwd_cycle=-2; mwd_cycle<3; mwd_cycle++) begin 

      if(terminate != `TRUE)
        $display("-> %0t: [BENCH] Could not find phase on MWD for rank %0d ! ", $time, rank);
        //`vmm_fatal(log, $psprintf("Could not find phase on MWD for rank %0d !",rank));
    end
    if(rank%2==1 && `DWC_RCD_MODE == `DIRECT_DUAL_CS || ( rank%4==3 && (`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS)) ) begin
      // Select Func Space 0  
      select_func_space(0, rank,  `DTP_tMOD);
      // Write Buffer Register F0BC0C=0x0  (Disable MWD)
      load_db_dq_register_4bit(8'h0c,4'h0, rank,  `DTP_tMOD);   
      // Write Buffer Register F0BC07=0xe  (Set enable for Rank 0 only)
      load_db_dq_register_4bit(8'h07,4'h0, rank,  `DTP_tMOD);   

      for ( j=0; j<`DWC_NO_OF_BYTES; j=j+1) begin
        `GRM.dxngcr2[j][31:16] = 16'h0000;
        `CFG.write_register(`DX0GCR2 + ( j * `DX_REG_RANGE), `GRM.dxngcr2[j]);
        //regs.set_field($psprintf("DX%0dGCR2", j),"DXOEMODE", 16'h0000); 
        //regs.flush($psprintf("DX%0dGCR2", j));
      end   

    end    
  end 
  
  
  // Set the chip to PUB mode
  `CFG.read_register_data(`PGCR1, reg_value);  //PUB Mode
  reg_value[6] =1;
  `CFG.write_register(`PGCR1, reg_value);
  repeat(100) @(posedge `SYS.clk);

  for(rank_no=0; rank_no < `DWC_NO_OF_RANKS; rank_no= rank_no+1) begin  
    rank = rank_no;

    if(`DWC_RCD_MODE == `DIRECT_DUAL_CS) begin
      device_rank = rank - rank%2;
    end else if(`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS) begin
      device_rank = rank - rank%4;
    end


    if(rank_disable[rank] == `FALSE) begin   
    
      if(`DWC_NO_OF_BYTES > 1 && (rank%2==0 && `DWC_RCD_MODE == `DIRECT_DUAL_CS || (rank%4==0 && (`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS)))) begin
        // Put the buffer into PBA mode - F0BC1x  0x01
        //load_db_dq_register_8bit(4'h1,8'h01, rank, pda_mode, pda_device, pda_exit, `DTP_tMOD);

        `CFG.read_register_data(`MR3_REG, reg_value);

        $display("Rank%d : Put the DRAM into PDA mode - MR3 A4=1 - Side A", rank);
        send_command_schcr(4'h1, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b00, {reg_value[20:5], 1'b1, reg_value[3:0]}, device_rank);

        $display("Rank%d : Put the DRAM into PDA mode - MR3 A4=1 - Side B", rank);
        send_command_schcr(4'h1, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b10, {reg_value[20:5], 1'b1, reg_value[3:0]}, device_rank);

        $display("Rank%d : Put the DB into PBA mode - F0BC1x with DA0=1", rank);
        send_command_schcr(4'h3, 4'h1, 4'h0, 18'h1FF, 1'b0, 2'b11, 2'b01, 20'h1101, device_rank);
      end
      
    
      for (j=0; j<`DWC_NO_OF_BYTES; j=j+1) begin
        `CFG.read_register_data(`DSGCR, reg_value);  //DSGCR.BDISEN
        `CFG.read_register_data(`DX0GCR0 + ( j * `DX_REG_RANGE), reg_value_1);  //DXnGCR0.DXEN
        //if(!((reg_value[1] == 1)  || reg_value_1[0] == 0)) begin
        if(!(reg_value_1[0] == 0)) begin
        //if (!((tb_cfg.dfi_byte_disable[j] == TRUE && regs.get_field("DSGCR", "BDISEN") == 1)  || regs.get_field($psprintf("DX%0dGCR0", j), "DXEN") == 0)) begin


            if (sdram_width ==4) begin
              case (j)
                0: schdqv= 18'h3FFFE;
                1: schdqv= 18'h3FFFB;
                2: schdqv= 18'h3FFEF;
                3: schdqv= 18'h3FFBF;
                4: schdqv= 18'h3FEFF;
                5: schdqv= 18'h3FBFF;
                6: schdqv= 18'h3EFFF;
                7: schdqv= 18'h3BFFF;
                8: schdqv= 18'h2FFFF;
              endcase
            end
            else begin
              case (j)
                0: schdqv= 18'h00FFE;
                1: schdqv= 18'h00FFD;
                2: schdqv= 18'h00FFB;
                3: schdqv= 18'h00FF7;
                4: schdqv= 18'h00FEF;
                5: schdqv= 18'h00FDF;
                6: schdqv= 18'h00FBF;
                7: schdqv= 18'h00F7F;
                8: schdqv= 18'h00EFF;
              endcase
            end

          //select_func_space(rank%2, rank,  `DTP_tWR2RD); 
          temp = rank %2;    
          send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b01, {16'h0170,temp}, device_rank);
               
          if(`DWC_RCD_MODE == `DIRECT_DUAL_CS || ((`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS) && rank%4 < 2))
            if(sdram_width == 4) begin
              // Program the cycle cycle result from MRD training - F0BCCx  (Rank 0 only)
              case (mwd_cycle_result[rank][j*2])
                -2: mwd_cycle_x4[3:0] = 4'h6;
                -1: mwd_cycle_x4[3:0] = 4'h5;
                 0: mwd_cycle_x4[3:0] = 4'h0;
                 1: mwd_cycle_x4[3:0] = 4'h1;
                 2: mwd_cycle_x4[3:0] = 4'h2;
              endcase
              case (mwd_cycle_result[rank][j*2+1])
                -2: mwd_cycle_x4[7:4] = 4'h6;
                -1: mwd_cycle_x4[7:4] = 4'h5;
                 0: mwd_cycle_x4[7:4] = 4'h0;
                 1: mwd_cycle_x4[7:4] = 4'h1;
                 2: mwd_cycle_x4[7:4] = 4'h2;
              endcase
              //load_db_dq_register_8bit(4'hd,mwd_cycle_x4, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD);              
              send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h1d,mwd_cycle_x4}, device_rank);
            end else begin
              // Program the cycle cycle result from MRD training - F0BCCx  (Rank 0 only)
              case (mwd_cycle_result[rank][j])
                //-2: load_db_dq_register_8bit(4'hd,8'h66, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD);
                -2: send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h1d,8'h66}, device_rank);
                //-1: load_db_dq_register_8bit(4'hd,8'h55, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD); 
                -1: send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h1d,8'h55}, device_rank);
                 //0: load_db_dq_register_8bit(4'hd,8'h00, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD);
                 0: send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h1d,8'h00}, device_rank);
                 //1: load_db_dq_register_8bit(4'hd,8'h11, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD);
                 1: send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h1d,8'h11}, device_rank);
                 //2: load_db_dq_register_8bit(4'hd,8'h22, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD);
                 2: send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h1d,8'h22}, device_rank);
              endcase            
            end
          else
            if(sdram_width == 4) begin
              // Program the cycle cycle result from MRD training - F0BCCx  (Rank 0 only)
              case (mwd_cycle_result[rank][j*2])
                -2: mwd_cycle_x4[3:0] = 4'h6;
                -1: mwd_cycle_x4[3:0] = 4'h5;
                 0: mwd_cycle_x4[3:0] = 4'h0;
                 1: mwd_cycle_x4[3:0] = 4'h1;
                 2: mwd_cycle_x4[3:0] = 4'h2;
              endcase
              case (mwd_cycle_result[rank][j*2+1])
                -2: mwd_cycle_x4[7:4] = 4'h6;
                -1: mwd_cycle_x4[7:4] = 4'h5;
                 0: mwd_cycle_x4[7:4] = 4'h0;
                 1: mwd_cycle_x4[7:4] = 4'h1;
                 2: mwd_cycle_x4[7:4] = 4'h2;
              endcase
              //load_db_dq_register_8bit(4'hf,mwd_cycle_x4, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD);  
              send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h1f,mwd_cycle_x4}, device_rank);
            end else begin
              // Program the cycle cycle result from MRD training - F0BCCx  (Rank 0 only)
              case (mwd_cycle_result[rank][j])
                //-2: load_db_dq_register_8bit(4'hf,8'h66, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD);
                -2: send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h1f,8'h66}, device_rank);
                //-1: load_db_dq_register_8bit(4'hf,8'h55, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD); 
                -1: send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h1f,8'h55}, device_rank);
                 //0: load_db_dq_register_8bit(4'hf,8'h00, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD);
                 0: send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h1f,8'h00}, device_rank);
                 //1: load_db_dq_register_8bit(4'hf,8'h11, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD);
                 1: send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h1f,8'h11}, device_rank);
                 //2: load_db_dq_register_8bit(4'hf,8'h22, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD);
                 2: send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h1f,8'h22}, device_rank);
              endcase 
            end        
          
          if(`DWC_RCD_MODE == `DIRECT_DUAL_CS) begin
            //select_func_space(rank%2, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD); 
            temp = rank %2;
            send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b01, {16'h0170,temp}, device_rank);
          end else if(`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS) begin
            //select_func_space(rank%4, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD);
            temp = rank %4;
            send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b01, {16'h0170,temp}, device_rank);
          end 
          
          if(sdram_width == 4) begin
            //pda_mode = TRUE;
            // Write Buffer Register F0BC8x=0xi
            //load_db_dq_register_8bit(4'h8,mwd_phase_result[rank][j*2], rank, pda_mode, pda_device, pda_exit, `DTP_tMOD);
            send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h18,mwd_phase_result[rank][j*2]}, device_rank);

            // Write Buffer Register F0BC9x=0xi
            //load_db_dq_register_8bit(4'h9,mwd_phase_result[rank][j*2+1], rank, pda_mode, pda_device, pda_exit, `DTP_tMOD);          
            send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h19,mwd_phase_result[rank][j*2]}, device_rank);
          end else begin
            //pda_mode = TRUE;
            // Write Buffer Register F0BC8x=0xi
            //load_db_dq_register_8bit(4'h8,mwd_phase_result[rank][j], rank, pda_mode, pda_device, pda_exit, `DTP_tMOD);
            send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h18,mwd_phase_result[rank][j]}, device_rank);

            // Write Buffer Register F0BC9x=0xi
            //load_db_dq_register_8bit(4'h9,mwd_phase_result[rank][j], rank, pda_mode, pda_device, pda_exit, `DTP_tMOD);
            send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h19,mwd_phase_result[rank][j]}, device_rank);
          end
        end
      end  
    end
  end 
  
  for(rank_no=0; rank_no < `DWC_NO_OF_RANKS; rank_no =rank_no +1) begin    
    rank = rank_no;
    if(`DWC_RCD_MODE == `DIRECT_DUAL_CS) begin
      device_rank = rank - rank%2;
    end else if(`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS) begin
      device_rank = rank - rank%4;
    end

    if(rank_disable[rank] == `FALSE) begin   
  
      //if(`DWC_NO_OF_BYTES > 1) begin
      if(`DWC_NO_OF_BYTES > 1 && (rank%2==0 && `DWC_RCD_MODE == `DIRECT_DUAL_CS || (rank%4==0 && (`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS)))) begin  

        // Select Func Space 0
        //select_func_space(0, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD);        
        send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b01, {20'h01700}, device_rank);

         `CFG.read_register_data(`MR3_REG, reg_value);


        // Take the buffer out of PBA mode
        //load_db_dq_register_8bit(4'h1,8'h00, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD);    
        $display("Rank%d : Exit the DB from PBA mode - F0BC1x with DA0=0", rank);
        send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b01, 20'h1100, device_rank);


        $display("Rank%d : Put the DB into PDA mode - F0BC1x with DA2=1", rank);
        send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b01, 20'h1104, device_rank);
 

        $display("Rank%d : Exit the DRAM from PDA mode - MR3 A4=0 - Side A", rank);
        send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b00, {reg_value[20:5], 1'b0, reg_value[3:0]}, device_rank);
 

        $display("Rank%d : Exit the DRAM from PDA mode - MR3 A4=0 - Side B", rank);
        send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b10, {reg_value[20:5], 1'b0, reg_value[3:0]}, device_rank);


        $display("Rank%d : Exit the DB from PDA mode - F0BC1x with DA2=0", rank);
        send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b01, 20'h1100, device_rank);
      end
    end
  end
  
  `CFG.read_register_data(`PGCR1, reg_value);  //PUB Mode
  reg_value[6] =0;
  `CFG.write_register(`PGCR1, reg_value); 
  repeat(100) @(posedge `SYS.clk); 

  mwd_train = 1'b0;  
  
endtask

//============================================================================================
// do_hir_training() - Runs LRDIMM HIR training
//============================================================================================
task do_hir_training;
  reg [`CMD_WIDTH-1 :0] dcu_command;   
  reg [`SDRAM_RANK_WIDTH-1:0] rank;
  reg [`SDRAM_RANK_WIDTH-1:0] device_rank;
  integer rank_no;
  //reg [`SDRAM_BANK_WIDTH-1:0] bank;
  reg [`DWC_PHY_BG_WIDTH + `DWC_PHY_BA_WIDTH  -1:0] bank;
  reg [12  :0] addr;
  reg [`DCU_RPT_WIDTH-1 :0] dcu_rpt;
  reg [`DCU_DTP_WIDTH-1 :0] dcu_dtp;
  reg [`DCU_TAG_WIDTH-1 :0] dcu_tag;
  reg [`PUB_DQS_WIDTH    - 1 : 0] mask={`PUB_DQS_WIDTH{`DDR_MASK_OFF}};
  reg [`DCU_DATA_WIDTH- 1 :0] data=`PUB_DATA_0000_0000;

  integer i;
  integer j;
  reg [31:0] reg_value;
  reg [31:0] reg_value_1; 
  reg [17:0] schdqv;
  hir_train = 1'b1;

  for (j=0; j<`DWC_NO_OF_BYTES; j=j+1) begin
   `GRM.dxngcr1[j][31:16] = 16'h0000;
   `GRM.dxngcr2[j][15:0] = 16'h0000;
   
   `CFG.write_register(`DX0GCR1 + ( j * `DX_REG_RANGE), `GRM.dxngcr1[j]);    
   `CFG.write_register(`DX0GCR2 + ( j * `DX_REG_RANGE), `GRM.dxngcr2[j]);
 end

  for(rank_no=0; rank_no < `DWC_NO_OF_RANKS; rank_no =rank_no +1) begin
    rank = rank_no;

    if(`DWC_RCD_MODE == `DIRECT_DUAL_CS) begin
      device_rank = rank - rank%2;
    end else if(`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS) begin
      device_rank = rank - rank%4;
    end


    if(rank%2==0 && `DWC_RCD_MODE == `DIRECT_DUAL_CS || ( rank%4==0 && (`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS)) ) begin
      //Set Databuffer MPR Override Mode
      //Select Func Space 0 
      select_func_space(0, rank, `DTP_tMOD);  

      // Set the chip to PUB mode
      `CFG.read_register_data(`PGCR1, reg_value);  //PUB Mode
      reg_value[6] =1;
      `CFG.write_register(`PGCR1, reg_value);
       
      `CFG.read_register_data(`MR3_REG, reg_value);

      if(`DWC_NO_OF_BYTES > 1) begin
        // Put the buffer into PBA mode - F0BC1x  0x01
        //load_db_dq_register_8bit(4'h1,8'h01, rank, pda_mode, pda_device, pda_exit, `DTP_tMOD);

        $display("Rank%d : Put the DRAM into PDA mode - MR3 A4=1 - Side A", rank);
        send_command_schcr(4'h1, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b00, {reg_value[20:5], 1'b1, reg_value[3:0]}, device_rank);

        $display("Rank%d : Put the DRAM into PDA mode - MR3 A4=1 - Side B", rank);
        send_command_schcr(4'h1, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b10, {reg_value[20:5], 1'b1, reg_value[3:0]}, device_rank);

        $display("Rank%d : Put the DB into PBA mode - F0BC1x with DA0=1", rank);
        send_command_schcr(4'h3, 4'h1, 4'h0, 18'h1FF, 1'b0, 2'b11, 2'b01, 20'h1101, device_rank);
      end


      for (i=0; i<`DWC_NO_OF_BYTES; i=i+1) begin   
        //Configure the schdqv for different byte
        if (sdram_width ==4) begin
              case (i)
                0: schdqv= 18'h3FFFE;
                1: schdqv= 18'h3FFFB;
                2: schdqv= 18'h3FFEF;
                3: schdqv= 18'h3FFBF;
                4: schdqv= 18'h3FEFF;
                5: schdqv= 18'h3FBFF;
                6: schdqv= 18'h3EFFF;
                7: schdqv= 18'h3BFFF;
                8: schdqv= 18'h2FFFF;
              endcase
              end 
            else begin
              case (i)
                0: schdqv= 18'h00FFE;
                1: schdqv= 18'h00FFD;
                2: schdqv= 18'h00FFB;
                3: schdqv= 18'h00FF7;
                4: schdqv= 18'h00FEF;
                5: schdqv= 18'h00FDF;
                6: schdqv= 18'h00FBF;
                7: schdqv= 18'h00F7F;
                8: schdqv= 18'h00EFF;
              endcase
            end
        `CFG.read_register_data(`DSGCR, reg_value);  //DSGCR.BDISEN
        `CFG.read_register_data(`DX0GCR0 + ( i * `DX_REG_RANGE), reg_value_1);  //DXnGCR0.DXEN
        //if(!((reg_value[1] == 1)  || reg_value_1[0] == 0)) begin
        if(!( reg_value_1[0] == 0)) begin
        //if (!((tb_cfg.dfi_byte_disable[i] == TRUE && regs.get_field("DSGCR", "BDISEN") == 1)  || regs.get_field($psprintf("DX%0dGCR0", i), "DXEN") == 0)) begin  
          // Load 0x2B into the Data Buffer MPR
          // Select Func Space 5
          //select_func_space(5, rank, pda_mode, pda_device, pda_exit, `DTP_tMOD);       
          send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b01, {20'h01705}, device_rank);

          // Sending BCW F5BC0x 0x55   MPR0
          //load_db_dq_register_8bit(4'h0,(j%2==0 || rdimm_addr_inv == `FALSE)?8'h55:8'haa, rank, pda_mode, pda_device, pda_exit, `DTP_tMOD);      
          send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h10,(i%2==0 || rdimm_addr_inv == `FALSE)?8'h55:8'h00}, device_rank);

          // Sending BCW F5BC1x 0x33   MPR1
          //load_db_dq_register_8bit(4'h1,(j%2==0 || rdimm_addr_inv == `FALSE)?8'h33:8'hcc, rank, pda_mode, pda_device, pda_exit, `DTP_tMOD);        
          send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h11,(i%2==0 || rdimm_addr_inv == `FALSE)?8'h33:8'h0f}, device_rank);

          // Sending BCW F5BC2x 0x0F   MPR2 
          //load_db_dq_register_8bit(4'h2,(j%2==0 || rdimm_addr_inv == `FALSE)?8'h0f:8'hf0, rank, pda_mode, pda_device, pda_exit, `DTP_tMOD);       
          send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h12,(i%2==0 || rdimm_addr_inv == `FALSE)?8'h0f:8'h33}, device_rank);

          // Sending BCW F5BC3x 0x00   MPR3  
          //load_db_dq_register_8bit(4'h3,(j%2==0 || rdimm_addr_inv == `FALSE)?8'h00:8'hff, rank, pda_mode, pda_device, pda_exit, `DTP_tMOD); 
          send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h13,(i%2==0 || rdimm_addr_inv == `FALSE)?8'h00:8'h55}, device_rank);

          // Select Func Space 6  
          //select_func_space(6, rank, pda_mode, pda_device, pda_exit, `DTP_tMOD);   
          send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b01, {20'h01706}, device_rank);

          // Sending BCW F6BC0x 0x55   MPR0
          //load_db_dq_register_8bit(4'h0,(j%2==0 || rdimm_addr_inv == `FALSE)?8'h55:8'haa, rank, pda_mode, pda_device, pda_exit, `DTP_tMOD);      
          send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h10,(i%2==0 || rdimm_addr_inv == `FALSE)?8'h55:8'h00}, device_rank);

          // Sending BCW F6BC1x 0x33   MPR1
          //load_db_dq_register_8bit(4'h1,(j%2==0 || rdimm_addr_inv == `FALSE)?8'h33:8'hcc, rank, pda_mode, pda_device, pda_exit, `DTP_tMOD);        
          send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h11,(i%2==0 || rdimm_addr_inv == `FALSE)?8'h33:8'h0f}, device_rank);

          // Sending BCW F6BC2x 0x0F   MPR2 
          //load_db_dq_register_8bit(4'h2,(j%2==0 || rdimm_addr_inv == `FALSE)?8'h0f:8'hf0, rank, pda_mode, pda_device, pda_exit, `DTP_tMOD);       
          send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h12,(i%2==0 || rdimm_addr_inv == `FALSE)?8'h0f:8'h33}, device_rank);

          // Sending BCW F6BC3x 0x00   MPR3  
          //load_db_dq_register_8bit(4'h3,(j%2==0 || rdimm_addr_inv == `FALSE)?8'h00:8'hff, rank, pda_mode, pda_device, pda_exit, `DTP_tMOD); 
          send_command_schcr(4'h3, 4'h1, 4'h0, schdqv, 1'b0, 2'b11, 2'b01, {12'h13,(i%2==0 || rdimm_addr_inv == `FALSE)?8'h00:8'h55}, device_rank);
        end
      end

      if(`DWC_NO_OF_BYTES > 1) begin

        // Select Func Space 0  
        //select_func_space(0, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD);     
        send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b01, 20'h01700, device_rank);

        // Take the buffer out of PBA mode
        //load_db_dq_register_8bit(4'h1,8'h00, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD);    
          
        `CFG.read_register_data(`MR3_REG, reg_value);
    
        $display("Rank%d : Exit the DB from PBA mode - F0BC1x with DA0=0", rank);
        send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b01, 20'h1100, device_rank);


        $display("Rank%d : Put the DB into PDA mode - F0BC1x with DA2=1", rank);
        send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b01, 20'h1104, device_rank);
 

        $display("Rank%d : Exit the DRAM from PDA mode - MR3 A4=0 - Side A", rank);
        send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b00, {reg_value[20:5], 1'b0, reg_value[3:0]}, device_rank);
 

        $display("Rank%d : Exit the DRAM from PDA mode - MR3 A4=0 - Side B", rank);
        send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b10, {reg_value[20:5], 1'b0, reg_value[3:0]}, device_rank);


        $display("Rank%d : Exit the DB from PDA mode - F0BC1x with DA2=0", rank);
        send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b01, 20'h1100, device_rank);

      end else begin
        // Select Func Space 0  
        //select_func_space(0, rank, pda_mode, pda_device, pda_exit, `DTP_tWR2RD); 
        send_command_schcr(4'h3, 4'h1, 4'h0, 18'h00000, 1'b0, 2'b11, 2'b01, 20'h01700, device_rank);
      end 
    end
  end

  // Exit the chip from PUB mode
  `CFG.read_register_data(`PGCR1, reg_value);  //PUB Mode
  reg_value[6] =0;
  `CFG.write_register(`PGCR1, reg_value);
  repeat(100) @(posedge `SYS.clk); 
  
  for(rank_no=0; rank_no < `DWC_NO_OF_RANKS; rank_no = rank_no +1) begin
    rank = rank_no;
    if(rank%2==0 && `DWC_RCD_MODE == `DIRECT_DUAL_CS || ( rank%4==0 && (`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS)) ) begin  
      // Write Buffer Register F0BC1x=0x2  (Enable Databuffer MPR Override Mode)
      load_db_dq_register_8bit(4'h1,8'h02, rank,`DTP_tMOD);    
    end
  end     
    
  
  //do_gate_training();
  dqs_gate_train(`DWC_NO_OF_RANKS,1);
    

  for(rank_no=0; rank_no < `DWC_NO_OF_RANKS; rank_no=rank_no+1) begin
    rank = rank_no;
    if(rank%2==0 && `DWC_RCD_MODE == `DIRECT_DUAL_CS || ( rank%4==0 && (`DWC_RCD_MODE == `DIRECT_QUAD_CS || `DWC_RCD_MODE == `ENCODED_QUAD_CS)) ) begin  
      // Write Buffer Register F0BC1x=0x2  (Disable Databuffer MPR Override Mode)
      load_db_dq_register_8bit(4'h1,8'h00, rank,`DTP_tMOD);    
    end
  end    
  
  hir_train = 1'b0;  
  
endtask  



endmodule // system
